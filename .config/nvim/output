Parsed codebase for the project: 


Directory Structure:
- /
- LICENSE (1070 bytes)
- .stylua.toml (195 bytes)
- oil:/
- oil:/home/
- oil:/home/mars/
- oil:/home/mars/Downloads/
- oil:/home/mars/Downloads/Torrents/
- after/
- after/queries/
- after/queries/bash/
- after/queries/bash/injections.scm (348 bytes)
- after/queries/rust/
- after/queries/rust/injections.scm (1029 bytes)
- after/queries/yaml/
- after/queries/yaml/injections.scm (233 bytes)
- after/queries/python/
- after/queries/python/textobjects.scm (67 bytes)
- after/queries/python/injections.scm (801 bytes)
- after/queries/toml/
- after/queries/toml/textobjects.scm (135 bytes)
- after/queries/haskell/
- after/ftplugin/
- after/ftplugin/sh.lua (821 bytes)
- after/ftplugin/haskell.lua (3648 bytes)
- after/ftplugin/markdown.lua (4659 bytes)
- after/ftplugin/gitignore.lua (37 bytes)
- after/ftplugin/cpp.lua (3526 bytes)
- after/ftplugin/rust.lua (1561 bytes)
- after/ftplugin/python.lua (2046 bytes)
- after/ftplugin/rsync.lua (67 bytes)
- after/ftplugin/yaml.lua (1346 bytes)
- after/ftplugin/text.lua (250 bytes)
- after/ftplugin/log.lua (63 bytes)
- after/ftplugin/vim.lua (1209 bytes)
- after/ftplugin/sql.lua (321 bytes)
- after/ftplugin/json.lua (921 bytes)
- after/ftplugin/toml.lua (756 bytes)
- after/ftplugin/tex.lua (1894 bytes)
- after/ftplugin/lua.lua (892 bytes)
- after/lsp/
- after/lsp/clangd.lua (46 bytes)
- after/lsp/texlab.lua (610 bytes)
- after/lsp/lua_ls.lua (553 bytes)
- after/lsp/bashls.lua (49 bytes)
- after/lsp/pyright.lua (775 bytes)
- after/lsp/rust_analyzer.lua (281 bytes)
- after/lsp/vimls.lua (57 bytes)
- after/lsp/ltex.lua (121 bytes)
- after/lsp/ruff.lua (80 bytes)
- after/lsp/hls.lua (472 bytes)
- docs/
- docs/nvim_resources.md (1089 bytes)
- docs/nvim_install_mac.sh (480 bytes)
- docs/nvim_setup_windows.ps1 (1570 bytes)
- docs/nvim_setup_linux.sh (9589 bytes)
- docs/README.md (7394 bytes)
- .ruff_cache/
- .ruff_cache/0.11.13/
- .ruff_cache/0.11.13/15656631170452948418 (15 bytes)
- .ruff_cache/CACHEDIR.TAG (43 bytes)
- resources/
- resources/head.tex (2587 bytes)
- autoload/
- autoload/text_obj.vim (2656 bytes)
- autoload/buf_utils.vim (1021 bytes)
- autoload/utils.vim (5175 bytes)
- plugin/
- plugin/abbrev.vim (69 bytes)
- plugin/command.lua (1749 bytes)
- plugin/log-autocmds.vim (2699 bytes)
- plugin/command.vim (1378 bytes)
- my_snippets/
- my_snippets/all.snippets (108 bytes)
- my_snippets/markdown.snippets (3318 bytes)
- my_snippets/snippets.snippets (260 bytes)
- my_snippets/cpp.snippets (3100 bytes)
- my_snippets/python.snippets (499 bytes)
- my_snippets/tex.snippets (16010 bytes)
- my_snippets/lua.snippets (1055 bytes)
- my_snippets/vim.snippets (216 bytes)
- lua/
- lua/diagnostic-conf.lua (1684 bytes)
- lua/globals.lua (2490 bytes)
- lua/oil:/
- lua/oil:/home/
- lua/oil:/home/mars/
- lua/oil:/home/mars/.dotfiles/
- lua/oil:/home/mars/.dotfiles/.config/
- lua/oil:/home/mars/.dotfiles/.config/nvim/
- lua/oil:/home/mars/.dotfiles/.config/nvim/lua/
- lua/config/
- lua/config/gitsigns.lua (1213 bytes)
- lua/config/git-linker.lua (1006 bytes)
- lua/config/nvim-statuscol.lua (622 bytes)
- lua/config/lsp.lua (7531 bytes)
- lua/config/ultisnips.lua (1127 bytes)
- lua/config/glance.lua (295 bytes)
- lua/config/vimtex.lua (3618 bytes)
- lua/config/lualine.lua (6934 bytes)
- lua/config/iron.lua (135 bytes)
- lua/config/obsidian-nvim.lua (5742 bytes)
- lua/config/nvim-notify.lua (225 bytes)
- lua/config/nvim-surround.lua (26792 bytes)
- lua/config/nvim-tree.lua (1794 bytes)
- lua/config/nvim_hop.lua (835 bytes)
- lua/config/dashboard-nvim.lua (2075 bytes)
- lua/config/nvim-cmp.lua (2934 bytes)
- lua/config/copilot.lua (821 bytes)
- lua/config/which-key.lua (87 bytes)
- lua/config/nvim-lint.lua (4063 bytes)
- lua/config/fugitive.lua (1098 bytes)
- lua/config/nvim_ufo.lua (1544 bytes)
- lua/config/fidget-nvim.lua (28 bytes)
- lua/config/fzf-lua.lua (757 bytes)
- lua/config/treesitter.lua (399 bytes)
- lua/config/lightbulb.lua (612 bytes)
- lua/config/blink-cmp.lua (1575 bytes)
- lua/config/treesitter-textobjects.lua (1636 bytes)
- lua/config/neorg.lua (8226 bytes)
- lua/config/yanky.lua (437 bytes)
- lua/config/oil.lua (7572 bytes)
- lua/config/bufferline.lua (1344 bytes)
- lua/config/indent-blankline.lua (796 bytes)
- lua/config/telescope.lua (1841 bytes)
- lua/config/git-conflict.lua (274 bytes)
- lua/config/bqf.lua (96 bytes)
- lua/config/hlslens.lua (2021 bytes)
- lua/config/live-command.lua (177 bytes)
- lua/improvements.lua (2060 bytes)
- lua/colorschemes.lua (3669 bytes)
- lua/utils.lua (7185 bytes)
- lua/custom-autocmd.lua (6561 bytes)
- lua/plugin_specs.lua (13130 bytes)
- lua/mappings.lua (9526 bytes)
- lua/lsp/
- lua/lsp/clangd.lua (571 bytes)
- lua/lsp/typescript.lua (261 bytes)
- lua/lsp/texlab.lua (619 bytes)
- lua/lsp/lua_ls.lua (405 bytes)
- lua/lsp/bashls.lua (141 bytes)
- lua/lsp/pyright.lua (540 bytes)
- lua/lsp/on_attach.lua (851 bytes)
- lua/lsp/rust_analyzer.lua (1194 bytes)
- lua/lsp/vimls.lua (472 bytes)
- lua/lsp/utils.lua (1070 bytes)
- lua/lsp/ltex.lua (396 bytes)
- lua/lsp/capabilities.lua (206 bytes)
- lua/lsp/ruff.lua (294 bytes)
- lua/lsp/yamlls.lua (1133 bytes)
- lua/lsp/json.lua (691 bytes)
- lua/lsp/hls.lua (330 bytes)
- lua/lsp/init.lua (2249 bytes)
- ftdetect/
- ftdetect/shell.vim (475 bytes)
- ftdetect/snippets.vim (105 bytes)
- ftdetect/pdc.vim (95 bytes)
- ginit.vim (2382 bytes)
- viml_conf/
- viml_conf/options.vim (6386 bytes)
- viml_conf/plugins.vim (8555 bytes)
- spell/
- spell/en.utf-8.add (3963 bytes)
- spell/es.utf-8.sug (15 bytes)
- spell/es.utf-8.spl (15 bytes)
- init.lua (891 bytes)
- Session.vim (3548 bytes)
- lazy-lock.json (8551 bytes)


Summary

- Total files: 132
- Total directories: 35
- Total text file size (including ignored): 277.44 KB
- Total tokens: 86379
- Analyzed text content size: 277.35 KB

Top largest non-ignored files:
- lua/config/nvim-surround.lua (26.16 kB)
- my_snippets/tex.snippets (15.63 kB)
- lua/plugin_specs.lua (12.82 kB)
- docs/nvim_setup_linux.sh (9.36 kB)
- lua/mappings.lua (9.30 kB)
- viml_conf/plugins.vim (8.35 kB)
- lazy-lock.json (8.35 kB)
- lua/config/neorg.lua (8.03 kB)
- lua/config/oil.lua (7.39 kB)
- lua/config/lsp.lua (7.35 kB)

Top largest non-ignored directories:
- lua (152.35 kB)
- lua/config (95.98 kB)
- after (28.98 kB)
- my_snippets (23.99 kB)
- after/ftplugin (23.45 kB)
- docs (19.65 kB)
- viml_conf (14.59 kB)
- lua/lsp (11.16 kB)
- autoload (8.64 kB)
- plugin (5.76 kB)

Ignore summary:
During the analysis, some files were ignored:
- No of files ignored during parsing: 2
- Patterns used to ignore files: {'en.utf-8.add.spl', '.vscode', '*.log', '*.tmp', '*.so', '.svn', '*.pyc', '.idea', 'build', '*.exe', '.DS_Store', '__pycache__', '*.egg-info', '.venv', '*.pyo', '*.dll', 'Thumbs.db', 'bower_components', '.gitignore', '.git', '.netrwhist', '*.bak', 'dist', 'venv', 'env', 'tags', 'node_modules', '.hg', '*.swp', '*.pyd', '*.dylib'}
Files:

File: LICENSE
---
Content:
MIT License

Copyright (c) 2018-2023 AlexONEX

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


File: .stylua.toml
---
Content:
# config for stylua, ref: https://github.com/JohnnyMorganz/StyLua
line_endings = "Unix"
indent_type = "Spaces"
indent_width = 2
quote_style = "AutoPreferDouble"
call_parentheses= "NoSingleTable"


File: after/queries/bash/injections.scm
---
Content:
; extends

;; TODO: Make this work for strings as well
;; Inject -c style strings
(command
  name: (command_name (word)) @injection.language (#any-of? @injection.language "bash" "fish" "julia" "nu" "python")
  argument: (
    (word) @_c_arg (#eq? @_c_arg "-c")
    .
    (raw_string) @injection.content)
    (#offset! @injection.content 0 1 0 -1))


File: after/queries/rust/injections.scm
---
Content:
; extends

;; SQL Queries
(call_expression
  function: (field_expression
    value: (identifier) @_obj (#any-of? @_obj "conn" "connection" "trans" "transaction")
    field: (field_identifier) @_fn (#vim-match? @_fn "^(execute|query|prepare)"))
  arguments: (arguments
    (raw_string_literal) @injection.content)
  (#offset! @injection.content 0 3 0 -2)
  (#set! injection.language "sql"))

;; Lua code in rlua's context.load
(call_expression
  function: (field_expression
    value: (identifier) @_obj (#any-of? @_obj "lua" "lua_ctx")
    field: (field_identifier) @_fn (#any-of? @_fn "load"))
  arguments: (arguments
    (raw_string_literal) @injection.content)
  (#offset! @injection.content 0 3 0 -2)
  (#set! injection.language "lua"))

; Regex
(call_expression
  function: (scoped_identifier
    path: (identifier) @_mod (#any-of? @_mod "Regex")
    name: (identifier) @_fn (#any-of? @_fn "new"))
  arguments: (arguments
    [(raw_string_literal) (string_literal)] @injection.content)
  (#set! injection.language "regex"))


File: after/queries/yaml/injections.scm
---
Content:
; extends

;; Regex
(block_mapping_pair
  key: (_) @_key (#any-of? @_key "re" "regex" "pattern")
  value: (flow_node [
    (single_quote_scalar)
    (double_quote_scalar)
  ] @injection.content)
  (#set! injection.language "regex"))


File: after/queries/python/textobjects.scm
---
Content:
; extends

;; Type annotation
(_ type: (type _) @annotation.outer)


File: after/queries/python/injections.scm
---
Content:
; extends

;; SQL Queries
(assignment
  left: (identifier) @_id (#contains? @_id "query")
  right: (string) @injection.content
  (#set! injection.language "sql"))

;; SQL Queries
(assignment
  left: (identifier) @_id
  right: (string) @injection.content
  (#lua-match? @injection.content "^\"+%s*-- [Qq]uery")
  (#set! injection.language "sql"))

;; Regex
;; FIXME: This currently doesn't work for calls to the regex module - presumably
;; this query is not being used at all.
(call
  function: (attribute
    object: (identifier) @_mod
    (#any-of? @_mod "re" "regex")
    attribute: (identifier) @_fn
    (#any-of? @_fn "compile" "search" "match" "fullmatch" "sub"))
  arguments: (argument_list [
    (string)
    (concatenated_string)
  ] @injection.content)
  (#set! injection.language "regex"))


File: after/queries/toml/textobjects.scm
---
Content:
; extends

; comment
(comment) @comment.outer

; class
(table) @class.outer

; function
[
  (table)
  (inline_table)
] @function.outer


File: after/ftplugin/sh.lua
---
Content:
vim.bo.expandtab = true
vim.bo.shiftwidth = 2
vim.bo.softtabstop = 2
vim.bo.tabstop = 2
vim.opt_local.formatoptions:remove({ "o", "r" })
vim.opt.isfname:remove("=")

local M = {}
local utils = require("utils")

function M.run_bash()
	if utils.executable("bash") then
		vim.cmd("!bash %")
	else
		vim.notify("Bash not found", vim.log.levels.ERROR)
	end
end

function M.format_bash()
	if utils.executable("shfmt") then
		vim.cmd("silent !shfmt -w %")
		vim.cmd("edit")
		vim.notify("Formatted with shfmt", vim.log.levels.INFO)
	else
		vim.notify("shfmt not found", vim.log.levels.WARN)
	end
end

_G.Ftplugin_Bash = M

local opts = { buffer = true, silent = true }
vim.keymap.set("n", "<F9>", function()
	Ftplugin_Bash.run_bash()
end, opts)
vim.keymap.set("n", "<space>f", function()
	Ftplugin_Bash.format_bash()
end, opts)


File: after/ftplugin/haskell.lua
---
Content:
vim.bo.commentstring = "-- %s"
vim.bo.expandtab = true
vim.bo.shiftwidth = 2
vim.bo.softtabstop = 2
vim.bo.tabstop = 2
vim.opt_local.formatoptions:remove({ "o", "r" })
vim.b.matchup_enabled = 0

local haskell_flags = table.concat({
	"-Wall",
	"-Wcompat",
	"-Wincomplete-record-updates",
	"-Wincomplete-uni-patterns",
	"-Wredundant-constraints",
	"-Wmissing-export-lists",
	"-Wpartial-fields",
	"-Wmissing-deriving-strategies",
	"-Wunused-packages",
	"-Widentities",
	"-fhide-source-paths",
	"-freverse-errors",
	"-fdefer-typed-holes",
	"-fdefer-type-errors",
	"-O2",
	"-dynamic",
	"-threaded",
	"-eventlog",
	"-debug",
}, " ")

local M = {}
local utils = require("utils")

local function create_term_buf(type, size)
	vim.opt.splitbelow = true
	vim.opt.splitright = true
	if type == "v" then
		vim.cmd("vnew")
	else
		vim.cmd("new")
	end
	vim.cmd("resize " .. size)
end

function M.compile_run_haskell()
	if not utils.executable("ghc") then
		vim.notify("GHC not found on the system!", vim.log.levels.ERROR)
		return
	end

	local src_path = vim.fn.expand("%:p:~")
	local src_noext = vim.fn.expand("%:p:~:r")

	create_term_buf("h", 20)
	local cmd = string.format("term ghc %s %s -o %s && %s", haskell_flags, src_path, src_noext, src_noext)
	vim.cmd(cmd)
	vim.cmd("startinsert")
end

function M.run_haskell()
	if not utils.executable("runhaskell") then
		vim.notify("runhaskell not found on the system!", vim.log.levels.ERROR)
		return
	end

	local src_path = vim.fn.expand("%:p:~")
	create_term_buf("h", 20)
	local cmd = string.format("term runhaskell %s", src_path)
	vim.cmd(cmd)
	vim.cmd("startinsert")
end

function M.format_haskell()
	if not utils.executable("ormolu") then
		vim.notify("ormolu not found on the system!", vim.log.levels.ERROR)
		return
	end

	local src_path = vim.fn.expand("%:p")
	vim.cmd("write")
	local result = vim.fn.system(string.format("ormolu --mode inplace %s", vim.fn.shellescape(src_path)))
	if vim.v.shell_error == 0 then
		vim.cmd("edit!")
		vim.notify("Formatted with ormolu", vim.log.levels.INFO)
	else
		vim.notify("Error formatting file: " .. result, vim.log.levels.ERROR)
	end
end

function M.run_hlint()
	vim.lsp.buf.code_action()
end

function M.compile_only_haskell()
	if not utils.executable("ghc") then
		vim.notify("GHC not found!", vim.log.levels.ERROR)
		return
	end

	local src_path = vim.fn.expand("%:p:~")
	local src_noext = vim.fn.expand("%:p:~:r")

	create_term_buf("h", 15)
	local cmd = string.format("term ghc %s %s -o %s", haskell_flags, src_path, src_noext)
	vim.cmd(cmd)
	vim.cmd("startinsert")
end

function M.run_executable()
	local exe_path = vim.fn.expand("%:p:~:r")
	if vim.fn.filereadable(exe_path) == 0 then
		vim.notify("Executable not found. Compile first!", vim.log.levels.WARN)
		return
	end

	create_term_buf("h", 15)
	local cmd = string.format("term %s", exe_path)
	vim.cmd(cmd)
	vim.cmd("startinsert")
end

_G.Ftplugin_Haskell = M

local opts = { buffer = true, silent = true }
vim.keymap.set("n", "<F9>", function()
	Ftplugin_Haskell.compile_run_haskell()
end, opts)
vim.keymap.set("n", "<F10>", function()
	Ftplugin_Haskell.run_haskell()
end, opts)
vim.keymap.set("n", "<F11>", function()
	Ftplugin_Haskell.compile_run_haskell()
end, opts)
vim.keymap.set("n", "<F5>", function()
	Ftplugin_Haskell.compile_only_haskell()
end, opts)
vim.keymap.set("n", "<F6>", function()
	Ftplugin_Haskell.run_executable()
end, opts)
vim.keymap.set("n", "<C-s>", function()
	Ftplugin_Haskell.format_haskell()
end, opts)
vim.keymap.set("n", "<space>f", function()
	Ftplugin_Haskell.format_haskell()
end, opts)
vim.keymap.set("n", "<leader>hl", function()
	Ftplugin_Haskell.run_hlint()
end, opts)


File: after/ftplugin/markdown.lua
---
Content:
vim.opt_local.concealcursor = "c"
vim.opt_local.synmaxcol = 3000
vim.opt_local.wrap = true
vim.opt_local.formatoptions:remove({ "o", "r" })

local M = {}

function M.add_list_symbol(start_line, end_line)
	for line = start_line, end_line do
		local text = vim.api.nvim_buf_get_lines(0, line - 1, line, false)[1]
		local indent = text:match("^%s*")
		local new_text = indent .. "+ " .. text:sub(#indent + 1)
		vim.api.nvim_buf_set_lines(0, line - 1, line, false, { new_text })
	end
end

function M.add_line_break(start_line, end_line)
	for line = start_line, end_line do
		local text = vim.api.nvim_buf_get_lines(0, line - 1, line, false)[1]
		vim.api.nvim_buf_set_lines(0, line - 1, line, false, { text .. "\\" })
	end
end

function M.format_and_save()
	vim.lsp.buf.format()
	vim.cmd("write")
end

function M.insert_code_block()
	vim.api.nvim_put({ "```", "", "```" }, "l", true, true)
	vim.api.nvim_win_set_cursor(0, { vim.api.nvim_win_get_cursor(0)[1] + 1, 0 })
	vim.cmd("startinsert!")
end

function M.add_reference_at_end(label, url, title)
	vim.schedule(function()
		local bufnr = vim.api.nvim_get_current_buf()
		local line_count = vim.api.nvim_buf_line_count(bufnr)
		local ref_def = "[" .. label .. "]: " .. url
		if title and title ~= "" then
			ref_def = ref_def .. ' "' .. title .. '"'
		end
		local buffer_lines = vim.api.nvim_buf_get_lines(bufnr, 0, -1, false)
		local has_ref_section = false
		for _, line in ipairs(buffer_lines) do
			if line:match("^%s*<!%-%-.*[Rr]eferences.*%-%->[%s]*$") then
				has_ref_section = true
				break
			end
		end
		local lines_to_add = {}
		if not has_ref_section then
			if #lines_to_add == 0 then
				table.insert(lines_to_add, "")
			end
			table.insert(lines_to_add, "<!-- References -->")
		end
		table.insert(lines_to_add, ref_def)
		vim.api.nvim_buf_set_lines(bufnr, line_count, line_count, false, lines_to_add)
	end)
end

function M.get_ref_link_labels()
	local labels = {}
	local seen = {}
	local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
	for _, line in ipairs(lines) do
		local start_pos = 1
		while start_pos <= #line do
			local match_start, match_end, label = string.find(line, "%[.-%]%[(.-)%]", start_pos)
			if not match_start then
				break
			end
			if label and label ~= "" and not seen[label] then
				table.insert(labels, label)
				seen[label] = true
			end
			start_pos = match_end + 1
		end
	end
	return labels
end

local function count_consecutive_spaces(str)
	local trimmed = str:match("^%s*(.*)")
	local count = 0
	for spaces in trimmed:gmatch("%s+") do
		count = count + 1
	end
	return count
end

local function setup_keymaps()
	local opts = { buffer = true, silent = true }

	vim.keymap.set("n", "+", ":set operatorfunc=v:lua.Ftplugin_Markdown.add_list_symbol<CR>g@", opts)
	vim.keymap.set(
		"x",
		"+",
		':<C-U>lua Ftplugin_Markdown.add_list_symbol(vim.fn.line("\'<"), vim.fn.line("\'>"))<CR>',
		opts
	)
	vim.keymap.set("n", "\\", ":set operatorfunc=v:lua.Ftplugin_Markdown.add_line_break<CR>g@", opts)
	vim.keymap.set(
		"x",
		"\\",
		':<C-U>lua Ftplugin_Markdown.add_line_break(vim.fn.line("\'<"), vim.fn.line("\'>"))<CR>',
		opts
	)
	vim.keymap.set("n", "<C-s>", function()
		Ftplugin_Markdown.format_and_save()
	end, opts)
	vim.keymap.set("n", "<space>mc", function()
		Ftplugin_Markdown.insert_code_block()
	end, opts)

	if vim.fn.exists(":FootnoteNumber") == 1 then
		vim.keymap.set("n", "^^", ":<C-U>call markdownfootnotes#VimFootnotes('i')<CR>", opts)
		vim.keymap.set("i", "^^", "<C-O>:<C-U>call markdownfootnotes#VimFootnotes('i')<CR>", opts)
		vim.keymap.set("i", "@@", "<Plug>ReturnFromFootnote", { buffer = true })
		vim.keymap.set("n", "@@", "<Plug>ReturnFromFootnote", { buffer = true })
	end

	vim.keymap.set("x", "ic", ":<C-U>lua require('text_obj').MdCodeBlock('i')<CR>", opts)
	vim.keymap.set("x", "ac", ":<C-U>lua require('text_obj').MdCodeBlock('a')<CR>", opts)
	vim.keymap.set("o", "ic", ":<C-U>lua require('text_obj').MdCodeBlock('i')<CR>", opts)
	vim.keymap.set("o", "ac", ":<C-U>lua require('text_obj').MdCodeBlock('a')<CR>", opts)
end

function M.setup()
	setup_keymaps()

	vim.api.nvim_buf_create_user_command(0, "AddRef", function(opts)
		local args = vim.split(opts.args, " ", { trimempty = true })
		if #args < 2 then
			vim.print("Usage: :AddRef <label> <url>")
			return
		end
		local label = args[1]
		local url = args[2]
		M.add_reference_at_end(label, url, "")
	end, {
		desc = "Add reference link at buffer end",
		nargs = "+",
		complete = function(arg_lead, cmdline, curpos)
			if count_consecutive_spaces(cmdline) > 1 then
				return {}
			end
			return M.get_ref_link_labels()
		end,
	})
end

_G.Ftplugin_Markdown = M
M.setup()


File: after/ftplugin/gitignore.lua
---
Content:
vim.opt_local.commentstring = "# %s"


File: after/ftplugin/cpp.lua
---
Content:
vim.bo.commentstring = "// %s"
vim.bo.expandtab = true
vim.bo.shiftwidth = 4
vim.bo.softtabstop = 4
vim.bo.tabstop = 4
vim.opt_local.formatoptions:remove({ "o", "r" })

local cpp_flags = table.concat({
	"-Wall",
	"-Wextra",
	"-pedantic",
	"-std=c++17",
	"-O2",
	"-Wshadow",
	"-Wformat=2",
	"-Wfloat-equal",
	"-Wconversion",
	"-Wcast-qual",
	"-Wcast-align",
	"-D_GLIBCXX_DEBUG",
	"-D_GLIBCXX_DEBUG_PEDANTIC",
	"-D_FORTIFY_SOURCE=2",
	"-fsanitize=address",
	"-fsanitize=undefined",
	"-fno-sanitize-recover",
	"-fstack-protector",
}, " ")

local M = {}
local utils = require("utils")

local function create_term_buf(type, size)
	vim.opt.splitbelow = true
	vim.opt.splitright = true
	if type == "v" then
		vim.cmd("vnew")
	else
		vim.cmd("new")
	end
	vim.cmd("resize " .. size)
end

local function get_cpp_compiler()
	if utils.executable("clang++") then
		return "clang++"
	elseif utils.executable("g++") then
		return "g++"
	else
		return nil
	end
end

function M.compile_run_cpp()
	local compiler = get_cpp_compiler()
	if not compiler then
		vim.notify("No C++ compiler found on the system!", vim.log.levels.ERROR)
		return
	end

	local src_path = vim.fn.expand("%:p:~")
	local src_noext = vim.fn.expand("%:p:~:r")

	create_term_buf("h", 20)
	local cmd = string.format("term %s %s %s -o %s && %s", compiler, cpp_flags, src_path, src_noext, src_noext)
	vim.cmd(cmd)
	vim.cmd("startinsert")
end

function M.compile_only_cpp()
	local compiler = get_cpp_compiler()
	if not compiler then
		vim.notify("No C++ compiler found!", vim.log.levels.ERROR)
		return
	end

	local src_path = vim.fn.expand("%:p:~")
	local src_noext = vim.fn.expand("%:p:~:r")

	create_term_buf("h", 15)
	local cmd = string.format("term %s %s %s -o %s", compiler, cpp_flags, src_path, src_noext)
	vim.cmd(cmd)
	vim.cmd("startinsert")
end

function M.run_executable()
	local exe_path = vim.fn.expand("%:p:~:r")
	if vim.fn.filereadable(exe_path) == 0 then
		vim.notify("Executable not found. Compile first!", vim.log.levels.WARN)
		return
	end

	create_term_buf("h", 15)
	local cmd = string.format("term %s", exe_path)
	vim.cmd(cmd)
	vim.cmd("startinsert")
end

function M.format_cpp()
	if utils.executable("clang-format") then
		vim.cmd("silent !clang-format -i %")
		vim.cmd("edit")
		vim.notify("Formatted with clang-format", vim.log.levels.INFO)
	else
		vim.notify("clang-format not found", vim.log.levels.WARN)
	end
end

function M.debug_cpp()
	local exe_path = vim.fn.expand("%:p:~:r")
	if vim.fn.filereadable(exe_path) == 0 then
		vim.notify("Executable not found. Compile first!", vim.log.levels.WARN)
		return
	end

	if utils.executable("gdb") then
		create_term_buf("h", 20)
		local cmd = string.format("term gdb %s", exe_path)
		vim.cmd(cmd)
		vim.cmd("startinsert")
	else
		vim.notify("gdb not found", vim.log.levels.WARN)
	end
end

_G.Ftplugin_Cpp = M

local opts = { buffer = true, silent = true }

vim.keymap.set("n", "<F9>", function()
	Ftplugin_Cpp.compile_run_cpp()
end, opts)

vim.keymap.set("n", "<F11>", function()
	Ftplugin_Cpp.compile_run_cpp()
end, opts)

vim.keymap.set("n", "<F5>", function()
	Ftplugin_Cpp.compile_only_cpp()
end, { buffer = true, desc = "Compile C++" })

vim.keymap.set("n", "<F6>", function()
	Ftplugin_Cpp.run_executable()
end, { buffer = true, desc = "Run executable" })

vim.keymap.set("n", "<space>f", function()
	Ftplugin_Cpp.format_cpp()
end, { buffer = true, desc = "Format with clang-format" })

vim.keymap.set("n", "<F7>", function()
	Ftplugin_Cpp.debug_cpp()
end, { buffer = true, desc = "Debug with GDB" })


File: after/ftplugin/rust.lua
---
Content:
vim.bo.expandtab = true
vim.bo.shiftwidth = 4
vim.bo.softtabstop = 4
vim.bo.tabstop = 4
vim.opt_local.formatoptions:remove({ "o", "r" })

local M = {}
local utils = require("utils")

function M.format_and_save()
	if utils.executable("rustfmt") then
		vim.cmd("silent !rustfmt %")
		vim.cmd("edit")
		vim.cmd("write")
		vim.notify("Formatted with rustfmt", vim.log.levels.INFO)
	else
		vim.notify("rustfmt not found. Install Rust toolchain", vim.log.levels.WARN)
	end
end

function M.run_rust()
	vim.cmd("!cargo run")
end

function M.build_rust()
	vim.cmd("!cargo build")
end

function M.test_rust()
	vim.cmd("!cargo test")
end

function M.check_rust()
	vim.cmd("!cargo check")
end

function M.clippy_rust()
	vim.cmd("!cargo clippy")
end

_G.Ftplugin_Rust = M

local opts = { buffer = true, silent = true }
vim.keymap.set("n", "<space>f", function()
	Ftplugin_Rust.format_and_save()
end, opts)

vim.keymap.set("n", "<F9>", function()
	Ftplugin_Rust.run_rust()
end, opts)

vim.keymap.set("n", "<space>rr", function()
	Ftplugin_Rust.run_rust()
end, { buffer = true, desc = "Cargo run" })

vim.keymap.set("n", "<space>rb", function()
	Ftplugin_Rust.build_rust()
end, { buffer = true, desc = "Cargo build" })

vim.keymap.set("n", "<space>rt", function()
	Ftplugin_Rust.test_rust()
end, { buffer = true, desc = "Cargo test" })

vim.keymap.set("n", "<space>rc", function()
	Ftplugin_Rust.check_rust()
end, { buffer = true, desc = "Cargo check" })

vim.keymap.set("n", "<space>rl", function()
	Ftplugin_Rust.clippy_rust()
end, { buffer = true, desc = "Cargo clippy" })


File: after/ftplugin/python.lua
---
Content:
vim.opt_local.wrap = false
vim.opt_local.sidescroll = 5
vim.opt_local.sidescrolloff = 2
vim.opt_local.colorcolumn = "100"
vim.bo.expandtab = true
vim.bo.shiftwidth = 4
vim.bo.softtabstop = 4
vim.bo.tabstop = 4
vim.opt_local.formatoptions:remove({ "o", "r" })

local M = {}
local utils = require("utils")

vim.api.nvim_create_autocmd("InsertCharPre", {
	pattern = { "*.py" },
	group = vim.api.nvim_create_augroup("py-fstring", { clear = true }),
	callback = function(params)
		if vim.v.char ~= "{" then
			return
		end
		local node = vim.treesitter.get_node({})
		if not node then
			return
		end
		if node:type() ~= "string" then
			node = node:parent()
		end
		if not node or node:type() ~= "string" then
			return
		end
		local row, col = vim.treesitter.get_node_range(node)
		local first_char = vim.api.nvim_buf_get_text(params.buf, row, col, row, col + 1, {})[1]
		if first_char == "f" or first_char == "r" then
			return
		end
		vim.api.nvim_input("<Esc>m'" .. row + 1 .. "gg" .. col + 1 .. "|if<esc>`'la")
	end,
})

function M.run_python()
	local python_info = utils.get_python_info()
	vim.cmd("AsyncRun " .. python_info.exe .. ' -u "%"')
end

function M.format_and_save()
	if utils.executable("ruff") then
		vim.cmd("silent !ruff format %")
		vim.cmd("silent !ruff check --fix %")
		vim.cmd("edit")
		vim.cmd("write")
		vim.notify("Formatted with Ruff", vim.log.levels.INFO)
	else
		vim.notify("Ruff not found. Install with: pip install ruff", vim.log.levels.WARN)
	end
end

function M.lint_python()
	if utils.executable("ruff") then
		vim.cmd("!ruff check %")
	else
		vim.notify("Ruff not found", vim.log.levels.WARN)
	end
end

_G.Ftplugin_Python = M

local opts = { buffer = true, silent = true }
vim.keymap.set("n", "<F9>", function()
	Ftplugin_Python.run_python()
end, opts)
vim.keymap.set("n", "<C-s>", function()
	Ftplugin_Python.format_and_save()
end, opts)
vim.keymap.set("n", "<space>f", function()
	Ftplugin_Python.format_and_save()
end, opts)
vim.keymap.set("n", "<space>l", function()
	Ftplugin_Python.lint_python()
end, opts)


File: after/ftplugin/rsync.lua
---
Content:
vim.opt_local.comments = ":#"
vim.opt_local.commentstring = "# %s"


File: after/ftplugin/yaml.lua
---
Content:
vim.bo.expandtab = true
vim.bo.shiftwidth = 2
vim.bo.softtabstop = 2
vim.bo.tabstop = 2
vim.opt_local.formatoptions:remove({ "o", "r" })

if vim.fn.line("$") > 500 then
	vim.opt_local.syntax = "OFF"
end

local M = {}
local utils = require("utils")

function M.format_and_save()
	local formatters = { "yamlfmt", "prettier" }
	local formatter = ""

	for _, fmt in ipairs(formatters) do
		if utils.executable(fmt) then
			formatter = fmt
			break
		end
	end

	if formatter ~= "" then
		local lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
		local content = table.concat(lines, "\n")
		local cmd = formatter == "prettier" and "prettier --parser yaml" or formatter
		local formatted = vim.fn.system(cmd, content)

		if vim.v.shell_error == 0 then
			vim.api.nvim_buf_set_lines(0, 0, -1, false, vim.split(formatted, "\n"))
			vim.notify("YAML formatted with " .. formatter, vim.log.levels.INFO)
		else
			vim.notify("Error formatting YAML: " .. formatted, vim.log.levels.ERROR)
		end
	else
		vim.notify("No YAML formatter found. Install yamlfmt or prettier", vim.log.levels.WARN)
	end
	vim.cmd("write")
end

_G.Ftplugin_Yaml = M

local opts = { buffer = true, silent = true }
vim.keymap.set("n", "<C-s>", function()
	Ftplugin_Yaml.format_and_save()
end, opts)
vim.keymap.set("n", "<space>f", function()
	Ftplugin_Yaml.format_and_save()
end, opts)


File: after/ftplugin/text.lua
---
Content:
vim.opt_local.commentstring = ""
vim.opt_local.comments = ""
vim.opt.wrap = true
vim.opt.breakindent = true
vim.opt.linebreak = true

vim.keymap.set("n", "j", "gj")
vim.keymap.set("n", "k", "gk")

--vim.opt.spelllang = "en_us"
--vim.opt.spell = true


File: after/ftplugin/log.lua
---
Content:
vim.opt_local.readonly = true
vim.opt_local.modifiable = false


File: after/ftplugin/vim.lua
---
Content:
vim.bo.expandtab = true
vim.bo.shiftwidth = 2
vim.bo.softtabstop = 2
vim.bo.tabstop = 2
vim.opt_local.foldmethod = "marker"
vim.opt_local.foldmarker = "{{{,}}}"
vim.opt_local.formatoptions:remove({ "o", "r" })

local M = {}

function M.format_and_save()
	local clients = vim.lsp.get_clients()
	local has_lsp = false
	for _, client in ipairs(clients) do
		if client.name == "vimls" and client.server_capabilities.documentFormattingProvider then
			has_lsp = true
			break
		end
	end

	local save_cursor = vim.fn.getpos(".")
	if has_lsp then
		vim.lsp.buf.format({
			timeout_ms = 2000,
			filter = function(client)
				return client.name == "vimls"
			end,
			async = false,
		})
	else
		vim.cmd([[silent! normal! gg=G]])
	end
	vim.fn.setpos(".", save_cursor)
	vim.cmd("write")
end

function M.run_vim_script()
	vim.cmd("source %")
	vim.notify("Vim script executed", vim.log.levels.INFO)
end

_G.Ftplugin_Vim = M

local opts = { buffer = true, silent = true }
vim.keymap.set("n", "<F9>", function()
	Ftplugin_Vim.run_vim_script()
end, opts)
vim.keymap.set("n", "<C-s>", function()
	Ftplugin_Vim.format_and_save()
end, opts)
vim.keymap.set("n", "<space>f", function()
	Ftplugin_Vim.format_and_save()
end, opts)


File: after/ftplugin/sql.lua
---
Content:
vim.bo.commentstring = "--\\ %s"
vim.opt_local.formatoptions:remove({ "o", "r" })

local M = {}

function M.format_and_save()
	vim.lsp.buf.format()
	vim.cmd("write")
end

_G.Ftplugin_Sql = M

local opts = { buffer = true, silent = true }
vim.keymap.set("n", "<C-s>", function()
	Ftplugin_Sql.format_and_save()
end, opts)


File: after/ftplugin/json.lua
---
Content:
local utils = require("utils")

vim.bo.expandtab = true
vim.bo.shiftwidth = 2
vim.bo.softtabstop = 2
vim.bo.tabstop = 2
vim.opt_local.formatoptions:remove { "o", "r" }

local M = {}

function M.format_json()
  if not utils.executable("jq") then
    vim.notify("jq not found in system", vim.log.levels.WARN, { title = "JSON Format" })
    return
  end

  local cursor_pos = vim.api.nvim_win_get_cursor(0)
  vim.cmd([[ silent %!jq . ]])
  vim.api.nvim_win_set_cursor(0, cursor_pos)
  vim.notify("JSON formateado con jq.", vim.log.levels.INFO, { title = "JSON Format" })
end

vim.keymap.set("n", "<leader>f", M.format_json, {
  buffer = true,
  desc = "Format JSON with jq",
})

vim.keymap.set("n", "o", function()
  local line = vim.api.nvim_get_current_line()
  if line:match("[^,{[]\\s*$") then
    return "A,<cr>"
  else
    return "o"
  end
end, { buffer = true, expr = true, desc = "Smart 'o' for commas" })

return M


File: after/ftplugin/toml.lua
---
Content:
vim.opt_local.formatoptions:remove({ "o", "r" })

local M = {}
local utils = require("utils")

function M.format_and_save()
	if utils.executable("taplo") then
		vim.cmd("silent !taplo format %")
		vim.cmd("edit")
		vim.cmd("write")
		vim.notify("Formatted with taplo", vim.log.levels.INFO)
	else
		vim.notify("taplo not found", vim.log.levels.WARN)
		vim.cmd("write")
	end
end

_G.Ftplugin_Toml = M

local opts = { buffer = true, silent = true }
vim.keymap.set("n", "<C-s>", function()
	Ftplugin_Toml.format_and_save()
end, opts)
vim.keymap.set("n", "<space>f", function()
	Ftplugin_Toml.format_and_save()
end, opts)

vim.api.nvim_buf_create_user_command(0, "FormatAndSaveToml", function()
	M.format_and_save()
end, { desc = "Format and save TOML file" })


File: after/ftplugin/tex.lua
---
Content:
vim.opt_local.textwidth = 120
vim.opt_local.wrap = true
vim.opt_local.linebreak = true
vim.opt_local.formatoptions:remove({ "o", "r" })
vim.bo.expandtab = true
vim.bo.shiftwidth = 2
vim.bo.softtabstop = 2
vim.bo.tabstop = 2
vim.opt_local.spell = true
vim.opt_local.spelllang = "es,en"
vim.opt_local.conceallevel = 2
vim.opt_local.concealcursor = "nc"

local M = {}

local function disable_treesitter()
	if vim.fn.exists(":TSBufDisable") == 2 then
		vim.cmd("TSBufDisable highlight")
	else
		vim.defer_fn(function()
			if vim.fn.exists(":TSBufDisable") == 2 then
				vim.cmd("TSBufDisable highlight")
			end
		end, 500)
	end
end

function M.format_and_save()
	vim.lsp.buf.format()
	vim.cmd("write")
end

function M.toggle_concealment()
	local current_level = vim.api.nvim_get_option_value("conceallevel", { scope = "local" })
	if current_level == 0 then
		vim.api.nvim_set_option_value("conceallevel", 2, { scope = "local" })
		vim.notify("Concealment enabled", vim.log.levels.INFO)
	else
		vim.api.nvim_set_option_value("conceallevel", 0, { scope = "local" })
		vim.notify("Concealment disabled", vim.log.levels.INFO)
	end
end

_G.Ftplugin_Tex = M

if vim.fn.filereadable(vim.fn.stdpath("config") .. "/lua/config/vimtex.lua") then
	local vimtex_config = require("config.vimtex")
	vimtex_config.setup()
end

vim.defer_fn(disable_treesitter, 100)

local opts = { buffer = true, silent = true }
vim.keymap.set("i", "<A-l>", "<c-g>u<Esc>[s1z=`]a<c-g>u", opts)
vim.keymap.set("n", "<C-s>", function()
	Ftplugin_Tex.format_and_save()
end, opts)
vim.keymap.set("n", "<leader>lh", function()
	Ftplugin_Tex.toggle_concealment()
end, opts)
vim.keymap.set("i", ";;", "\\", { buffer = true })
vim.keymap.set("i", "$$", "$$ $$<left><left><left>", { buffer = true })

vim.api.nvim_buf_create_user_command(0, "FormatAndSaveLatex", function()
	M.format_and_save()
end, { desc = "Format and save LaTeX file" })


File: after/ftplugin/lua.lua
---
Content:
vim.bo.expandtab = true
vim.bo.shiftwidth = 2
vim.bo.softtabstop = 2
vim.bo.tabstop = 2
vim.opt_local.formatoptions:remove({ "o", "r" })

local M = {}
local utils = require("utils")

function M.format_and_save()
	if utils.executable("stylua") then
		vim.cmd("silent !stylua %")
		vim.cmd("edit")
		vim.cmd("write")
		vim.notify("Formatted with StyLua", vim.log.levels.INFO)
	else
		vim.notify("StyLua not found. Install with: cargo install stylua", vim.log.levels.WARN)
	end
end

function M.run_lua()
	vim.cmd("luafile %")
	vim.notify("Lua file executed", vim.log.levels.INFO)
end

_G.Ftplugin_Lua = M

local opts = { buffer = true, silent = true }
vim.keymap.set("n", "<C-s>", function()
	Ftplugin_Lua.format_and_save()
end, opts)
vim.keymap.set("n", "<F9>", function()
	Ftplugin_Lua.run_lua()
end, opts)
vim.keymap.set("n", "<space>f", function()
	Ftplugin_Lua.format_and_save()
end, opts)


File: after/lsp/clangd.lua
---
Content:
return {
	filetypes = { "c", "cpp", "cc" },
}


File: after/lsp/texlab.lua
---
Content:
return {
	filetypes = { "tex", "latex", "bib" },
	settings = {
		texlab = {
			rootDirectory = nil,
			build = {
				executable = "latexmk",
				args = { "-pdf", "-interaction=nonstopmode", "-synctex=1", "%f" },
				onSave = false,
				forwardSearchAfter = false,
			},
			forwardSearch = {
				executable = nil,
				args = {},
			},
			chktex = {
				onOpenAndSave = false,
				onEdit = false,
			},
			diagnosticsDelay = 300,
			latexFormatter = "latexindent",
			latexindent = {
				["local"] = nil,
				modifyLineBreaks = false,
			},
			bibtexFormatter = "texlab",
			formatterLineLength = 80,
		},
	},
}


File: after/lsp/lua_ls.lua
---
Content:
return {
	settings = {
		Lua = {
			runtime = {
				version = "LuaJIT",
			},
			diagnostics = {
				globals = { "vim" },
			},
			workspace = {
				library = vim.api.nvim_get_runtime_file("", true),
				checkThirdParty = false,
			},
			telemetry = {
				enable = false,
			},
			hint = {
				enable = true,
			},
			format = {
				enable = true,
				defaultConfig = {
					indent_style = "space",
					indent_size = "2",
				},
			},
		},
	},
	filetypes = { "lua", "vim" },
	single_file_support = true,
	flags = {
		debounce_text_changes = 500,
	},
}


File: after/lsp/bashls.lua
---
Content:
return {
	filetypes = { "sh", "bash", "zsh" },
}


File: after/lsp/pyright.lua
---
Content:
local pyright_capability = {
	textDocument = {
		publishDiagnostics = {
			tagSupport = {
				valueSet = { 2 },
			},
		},
		hover = {
			contentFormat = { "plaintext" },
			dynamicRegistration = true,
		},
	},
}

return {
	cmd = { "pyright-langserver", "--stdio" },
	settings = {
		pyright = {
			disableOrganizeImports = true,
			disableTaggedHints = false,
		},
		python = {
			analysis = {
				autoSearchPaths = true,
				diagnosticMode = "workspace",
				typeCheckingMode = "standard",
				useLibraryCodeForTypes = true,
				diagnosticSeverityOverrides = {
					deprecateTypingAliases = false,
				},
				inlayHints = {
					callArgumentNames = "partial",
					functionReturnTypes = true,
					pytestParameters = true,
					variableTypes = true,
				},
			},
		},
	},
}


File: after/lsp/rust_analyzer.lua
---
Content:
return {
	settings = {
		["rust-analyzer"] = {
			assist = {
				importGranularity = "module",
				importPrefix = "self",
			},
			cargo = {
				loadOutDirsFromCheck = true,
				buildScripts = {
					enable = true,
				},
			},
			procMacro = {
				enable = true,
			},
		},
	},
}


File: after/lsp/vimls.lua
---
Content:
return {
	flags = {
		debounce_text_changes = 500,
	},
}


File: after/lsp/ltex.lua
---
Content:
return {
	filetypes = { "text", "plaintex", "tex", "markdown" },
	settings = {
		ltex = {
			language = "en",
		},
	},
}


File: after/lsp/ruff.lua
---
Content:
return {
	init_options = {
		settings = {
			organizeImports = true,
		},
	},
}


File: after/lsp/hls.lua
---
Content:
return {
	filetypes = { "haskell", "lhaskell" },
	settings = {
		haskell = {
			formattingProvider = "fourmolu",
			plugin = {
				stan = { globalOn = true },
				hlint = { globalOn = true },
				haddockComments = { globalOn = true },
				class = { globalOn = true },
				retrie = { globalOn = true },
				rename = { globalOn = true },
				importLens = { globalOn = true },
				alternateNumberFormat = { globalOn = true },
				eval = { globalOn = true },
			},
		},
	},
}


File: docs/nvim_resources.md
---
Content:
Below are a list of resources that inspire me. This list is non-exhaustive 

- [From .vimrc to .vim](https://vimways.org/2018/from-vimrc-to-vim/)
- http://stevelosh.com/blog/2010/09/coming-home-to-vim/
- https://github.com/tamlok/tvim/blob/master/.vimrc
- https://nvie.com/posts/how-i-boosted-my-vim/
- https://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/
- https://sanctum.geek.nz/arabesque/vim-anti-patterns/
- https://github.com/gkapfham/dotfiles/blob/master/.vimrc
- https://google.github.io/styleguide/vimscriptguide.xml
- https://github.com/romainl/idiomatic-vimrc
- https://github.com/mhinz/vim-galore
- https://learnvimscriptthehardway.stevelosh.com/
- https://vimways.org/2018/from-vimrc-to-vim/
- [vim script for Python developers](https://github.com/yegappan/VimScriptForPythonDevelopers)
- [Awesome neovim](https://github.com/rockerBOO/awesome-neovim): extensive list of neovim resources (plugins, mostly).
- [What is your favorite plugins for Nvim 0.5](https://www.reddit.com/r/neovim/comments/o20w3z/what_are_your_favorite_neovim_plugins_exclusive/)


File: docs/nvim_install_mac.sh
---
Content:
# This script is used to update Nvim on macOS
#!/bin/bash
set -eux

wget https://github.com/neovim/neovim/releases/download/stable/nvim-macos.tar.gz

if [[ ! -d "$HOME/tools/"  ]]; then
    mkdir -p "$HOME/tools"
fi

# Delete existing nvim installation.
# For newer release, the directory name is nvim-macos
if [[ -d "$HOME/tools/nvim-macos" ]]; then
    rm -rf "$HOME/tools/nvim-macos"
fi

# Extract the tar ball
tar zxvf nvim-macos.tar.gz -C "$HOME/tools"

rm nvim-macos.tar.gz


File: docs/nvim_setup_windows.ps1
---
Content:
# Set policy to avoid errors
Set-ExecutionPolicy RemoteSigned -scope CurrentUser

# Install scoop
Invoke-WebRequest -UseBasicParsing get.scoop.sh | Invoke-Expression

# Install node
scoop install nodejs

# Install ripgrep
scoop install ripgrep

# Install universal-ctags
scoop bucket add extras
scoop install universal-ctags

# Install vim-language-server
npm install -g vim-language-server

# Install bash-language-server
npm install -g bash-language-server

# Install miniconda3 (for Python)
scoop install miniconda3

# Install pynvim
pip install -U pynvim

# Install python-language-server
pip install 'python-lsp-server[all]' pylsp-mypy python-lsp-isort

# Install visual c++ redistribution
scoop install vcredist2022

# Install 7zip
scoop install 7zip

# Install lua-language-server
$lua_ls_link = "https://github.com/LuaLS/lua-language-server/releases/download/3.6.11/lua-language-server-3.6.11-win32-x64.zip"
$lua_ls_install_dir = "D:\portable_tools"
$lua_ls_src_path = "$lua_ls_install_dir\lua-language-server.zip"
$lua_ls_dir = "$lua_ls_install_dir\lua-language-server"

# Download file, ref: https://stackoverflow.com/a/51225744/6064933
Invoke-WebRequest $lua_ls_link -OutFile "$lua_ls_src_path"

# Extract the zip file using 7zip, ref: https://stackoverflow.com/a/41933215/6064933
7z x "$lua_ls_src_path" -o"$lua_ls_dir"

# Setup PATH env variable, ref: https://stackoverflow.com/q/714877/6064933
[Environment]::SetEnvironmentVariable("Path", $env:Path + ";$lua_ls_dir\bin", "Machine")

# Install neovim nightly
scoop bucket add versions
scoop install neovim


File: docs/nvim_setup_linux.sh
---
Content:
#!/bin/bash
set -exu
set -o pipefail

# Whether python3 has been installed on the system
PYTHON_INSTALLED=true

# If Python has been installed, then we need to know whether Python is provided
# by the system, or you have already installed Python under your HOME.
SYSTEM_PYTHON=false

# If SYSTEM_PYTHON is false, we need to decide whether to install
# Anaconda (INSTALL_ANACONDA=true) or Miniconda (INSTALL_ANACONDA=false)
INSTALL_ANACONDA=false

# Whether to add the path of the installed executables to system PATH
ADD_TO_SYSTEM_PATH=true

# select which shell we are using
USE_ZSH_SHELL=true
USE_BASH_SHELL=false

if [[ ! -d "$HOME/packages/" ]]; then
    mkdir -p "$HOME/packages/"
fi

if [[ ! -d "$HOME/tools/" ]]; then
    mkdir -p "$HOME/tools/"
fi

#######################################################################
#                    Anaconda or miniconda install                    #
#######################################################################
if [[ "$INSTALL_ANACONDA" = true ]]; then
    CONDA_DIR=$HOME/tools/anaconda
    CONDA_NAME=Anaconda.sh
    CONDA_LINK="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/Anaconda3-2021.11-Linux-x86_64.sh"
else
    CONDA_DIR=$HOME/tools/miniconda
    CONDA_NAME=Miniconda.sh
    CONDA_LINK="https://mirrors.tuna.tsinghua.edu.cn/anaconda/miniconda/Miniconda3-py39_4.10.3-Linux-x86_64.sh"
fi

if [[ ! "$PYTHON_INSTALLED" = true ]]; then
    echo "Installing Python in user HOME"

    SYSTEM_PYTHON=false

    echo "Downloading and installing conda"

    if [[ ! -f "$HOME/packages/$CONDA_NAME" ]]; then
        curl -Lo "$HOME/packages/$CONDA_NAME" $CONDA_LINK
    fi

    # Install conda silently
    if [[ -d $CONDA_DIR ]]; then
        rm -rf "$CONDA_DIR"
    fi
    bash "$HOME/packages/$CONDA_NAME" -b -p "$CONDA_DIR"

    # Setting up environment variables
    if [[ "$ADD_TO_SYSTEM_PATH" = true ]] && [[ "$USE_BASH_SHELL" = true ]]; then
        echo "export PATH=\"$CONDA_DIR/bin:\$PATH\"" >> "$HOME/.bash_profile"
    fi
else
    echo "Python is already installed. Skip installing it."
fi

# Install some Python packages used by Nvim plugins.
echo "Installing Python packages"
declare -a PY_PACKAGES=("pynvim" 'python-lsp-server[all]' "vim-vint" "python-lsp-isort" "pylsp-mypy" "python-lsp-black")

if [[ "$SYSTEM_PYTHON" = true ]]; then
    echo "Using system Python to install $(PY_PACKAGES)"

    # If we use system Python, we need to install these Python packages under
    # user HOME, since we do not have permissions to install them under system
    # directories.
    for p in "${PY_PACKAGES[@]}"; do
        pip install --user "$p"
    done
else
    echo "Using custom Python to install $(PY_PACKAGES)"
    for p in "${PY_PACKAGES[@]}"; do
        "$CONDA_DIR/bin/pip" install "$p"
    done
fi

#######################################################################
#                Install node and js-based language server            #
#######################################################################
NODE_DIR=$HOME/tools/nodejs
NODE_SRC_NAME=$HOME/packages/nodejs.tar.gz
# when download speed is slow, we can also use its mirror site: https://mirrors.ustc.edu.cn/node/v15.0.0/
NODE_LINK="https://mirrors.ustc.edu.cn/node/v15.0.0/node-v15.0.0-linux-x64.tar.xz"
if [[ -z "$(command -v node)" ]]; then
    echo "Install Node.js"
    if [[ ! -f $NODE_SRC_NAME ]]; then
        echo "Downloading Node.js and renaming"
        wget $NODE_LINK -O "$NODE_SRC_NAME"
    fi

    if [[ ! -d "$NODE_DIR" ]]; then
        echo "Creating Node.js directory under tools directory"
        mkdir -p "$NODE_DIR"
        echo "Extracting to $HOME/tools/nodejs directory"
        tar xvf "$NODE_SRC_NAME" -C "$NODE_DIR" --strip-components 1
    fi

    if [[ "$ADD_TO_SYSTEM_PATH" = true ]] && [[ "$USE_BASH_SHELL" = true ]]; then
        echo "export PATH=\"$NODE_DIR/bin:\$PATH\"" >> "$HOME/.bash_profile"
    fi
else
    echo "Node.js is already installed. Skip installing it."
    NODE_DIR="$(realpath $(dirname $(which node))/..)"
fi

# Install vim-language-server
"$NODE_DIR/bin/npm" install -g vim-language-server

# Install bash-language-server
"$NODE_DIR/bin/npm" install -g bash-language-server

#######################################################################
#                         lua-language-server                         #
#######################################################################
LUA_LS_DIR=$HOME/tools/lua-language-server
LUA_LS_SRC=$HOME/packages/lua-language-server.tar.gz
LUA_LS_LINK="https://github.com/LuaLS/lua-language-server/releases/download/3.6.11/lua-language-server-3.6.11-linux-x64.tar.gz"

if [[ -z "$(command -v lua-language-server)" ]] && [[ ! -f "$LUA_LS_DIR/bin/lua-language-server" ]]; then
    echo 'Install lua-language-server'
    if [[ ! -f $LUA_LS_SRC ]]; then
        echo "Downloading lua-language-server and renaming"
        wget $LUA_LS_LINK -O "$LUA_LS_SRC"
    fi

    if [[ ! -d "$LUA_LS_DIR" ]]; then
        echo "Creating lua-language-server directory under tools directory"
        mkdir -p "$LUA_LS_DIR"
        echo "Extracting to directory $LUA_LS_DIR"

        tar zxvf "$LUA_LS_SRC" -C "$LUA_LS_DIR"
    fi

    if [[ "$ADD_TO_SYSTEM_PATH" = true ]] && [[ "$USE_BASH_SHELL" = true ]]; then
        echo "export PATH=\"$LUA_LS_DIR/bin:\$PATH\"" >> "$HOME/.bash_profile"
    fi
else
    echo "lua-language-server is already installed. Skip installing it."
fi

#######################################################################
#                            Ripgrep part                             #
#######################################################################
RIPGREP_DIR=$HOME/tools/ripgrep
RIPGREP_SRC_NAME=$HOME/packages/ripgrep.tar.gz
RIPGREP_LINK="https://github.com/BurntSushi/ripgrep/releases/download/12.0.0/ripgrep-12.0.0-x86_64-unknown-linux-musl.tar.gz"
if [[ -z "$(command -v rg)" ]] && [[ ! -f "$RIPGREP_DIR/rg" ]]; then
    echo "Install ripgrep"
    if [[ ! -f $RIPGREP_SRC_NAME ]]; then
        echo "Downloading ripgrep and renaming"
        wget $RIPGREP_LINK -O "$RIPGREP_SRC_NAME"
    fi

    if [[ ! -d "$RIPGREP_DIR" ]]; then
        echo "Creating ripgrep directory under tools directory"
        mkdir -p "$RIPGREP_DIR"
        echo "Extracting to $HOME/tools/ripgrep directory"
        tar zxvf "$RIPGREP_SRC_NAME" -C "$RIPGREP_DIR" --strip-components 1
    fi

    if [[ "$ADD_TO_SYSTEM_PATH" = true ]] && [[ "$USE_BASH_SHELL" = true ]]; then
        echo "export PATH=\"$RIPGREP_DIR:\$PATH\"" >> "$HOME/.bash_profile"
    fi

    # set up manpath and zsh completion for ripgrep
    mkdir -p "$HOME/tools/ripgrep/doc/man/man1"
    mv "$HOME/tools/ripgrep/doc/rg.1" "$HOME/tools/ripgrep/doc/man/man1"

    if [[ "$USE_BASH_SHELL" = true ]]; then
        echo 'export MANPATH=$HOME/tools/ripgrep/doc/man:$MANPATH' >> "$HOME/.bash_profile"
    else
        echo 'export MANPATH=$HOME/tools/ripgrep/doc/man:$MANPATH' >> "$HOME/.zshrc"
        echo 'export FPATH=$HOME/tools/ripgrep/complete:$FPATH' >> "$HOME/.zshrc"
    fi
else
    echo "ripgrep is already installed. Skip installing it."
fi

#######################################################################
#                            Ctags install                            #
#######################################################################
CTAGS_SRC_DIR=$HOME/packages/ctags
CTAGS_DIR=$HOME/tools/ctags
CTAGS_LINK="https://github.com/universal-ctags/ctags.git"
if [[ ! -f "$CTAGS_DIR/bin/ctags" ]]; then
    echo "Install ctags"

    if [[ ! -d $CTAGS_SRC_DIR ]]; then
        mkdir -p "$CTAGS_SRC_DIR"
    else
        # Prevent an incomplete download.
        rm -rf "$CTAGS_SRC_DIR"
    fi

    git clone --depth=1 "$CTAGS_LINK" "$CTAGS_SRC_DIR" && cd "$CTAGS_SRC_DIR"
    ./autogen.sh && ./configure --prefix="$CTAGS_DIR"
    make -j && make install

    if [[ "$ADD_TO_SYSTEM_PATH" = true ]] && [[ "$USE_BASH_SHELL" = true ]]; then
        echo "export PATH=\"$CTAGS_DIR/bin:\$PATH\"" >> "$HOME/.bash_profile"
    fi
else
    echo "ctags is already installed. Skip installing it."
fi

#######################################################################
#                                Nvim install                         #
#######################################################################
NVIM_DIR=$HOME/tools/nvim
NVIM_SRC_NAME=$HOME/packages/nvim-linux64.tar.gz
NVIM_CONFIG_DIR=$HOME/.config/nvim
NVIM_LINK="https://github.com/neovim/neovim/releases/download/stable/nvim-linux-x86_64.tar.gz"
if [[ ! -f "$NVIM_DIR/bin/nvim" ]]; then
    echo "Installing Nvim"
    echo "Creating nvim directory under tools directory"

    if [[ ! -d "$NVIM_DIR" ]]; then
        mkdir -p "$NVIM_DIR"
    fi

    if [[ ! -f $NVIM_SRC_NAME ]]; then
        echo "Downloading Nvim"
        wget "$NVIM_LINK" -O "$NVIM_SRC_NAME"
    fi
    echo "Extracting neovim"
    tar zxvf "$NVIM_SRC_NAME" --strip-components 1 -C "$NVIM_DIR"

    if [[ "$ADD_TO_SYSTEM_PATH" = true ]] && [[ "$USE_BASH_SHELL" = true ]]; then
        echo "export PATH=\"$NVIM_DIR/bin:\$PATH\"" >> "$HOME/.bash_profile"
    fi
else
    echo "Nvim is already installed. Skip installing it."
fi

echo "Setting up config and installing plugins"
if [[ -d "$NVIM_CONFIG_DIR" ]]; then
    rm -rf "$NVIM_CONFIG_DIR.backup"
    mv "$NVIM_CONFIG_DIR" "$NVIM_CONFIG_DIR.backup"
fi

git clone --depth=1 https://github.com/jdhao/nvim-config.git "$NVIM_CONFIG_DIR"

echo "Installing nvim plugins, please wait"
"$NVIM_DIR/bin/nvim" -c "autocmd User LazyInstall quitall"  -c "lua require('lazy').install()"

echo "Finished installing Nvim and its dependencies!"


File: docs/README.md
---
Content:
This doc summarizes how to install and use this configuration in detail.

# Pre-requisite

## Terminal emulators

Which [terminal emulator](https://en.wikipedia.org/wiki/Terminal_emulator) we choose to use greatly affects the appearance and features of Nvim.
Since Nvim supports true colors, terminals that support true colors are preferred.
For a list of terminals that support true colors, see [here](https://github.com/termstandard/colors).

For macOS, we can use [kitty](https://sw.kovidgoyal.net/kitty/), [iterm2](https://www.iterm2.com/), [wezterm](https://wezfurlong.org/wezterm/) or [Alacritty](https://github.com/jwilm/alacritty).

If you ssh to Linux server on Windows, I recommend [wsltty](https://github.com/mintty/wsltty) and [Cygwin](https://www.cygwin.com/),
both of them use [mintty](https://github.com/mintty/mintty) as the terminal emulator.
For the latest version of Windows 10, you can also try [Windows Terminal](https://github.com/microsoft/terminal).

## Patched Fonts

Since statusline or file explorer plugins often use Unicode symbols not available in normal font,
we need to install a patched font from the [nerd-fonts](https://github.com/ryanoasis/nerd-fonts) project.

# Automatic installation

## Automatic Installation for Linux

To set up a workable Nvim environment on Linux,
I use [a bash script](nvim_setup_linux.sh) to automatically install necessary dependencies, Nvim itself and configs.

Note that the variable `PYTHON_INSTALLED`, `SYSTEM_PYTHON` and `ADD_TO_SYSTEM_PATH` in the script
should be set properly based on your environment.

## Automatic installation for Windows

Run the script [nvim_setup_windows.ps1](nvim_setup_windows.ps1) in PowerShell **with Administrator rights**:

```
.\docs\nvim_setup_windows.ps1
```

# Manual install

There are a few dependencies if we want to use Nvim for efficient editing and development work.

## Dependencies

### Python

A lot of Nvim plugins are mainly written in Python, so we must install Python 3.
The easiest way to install is via [Anaconda](https://docs.anaconda.com/anaconda/install/index.html) or [Miniconda](https://docs.conda.io/en/latest/miniconda.html).

After installation, make sure that you can run `python --version`,
and that the output should be Python 3.x.

### Pynvim

Nvim relies on [pynvim](https://github.com/neovim/pynvim) to communicate with plugins that utilize its Python binding.
Pynvim is required by plugins such as [wilder.nvim](https://github.com/gelguy/wilder.nvim).

```
pip install -U pynvim
```

### python-lsp-server

[python-lsp-server (pylsp)](https://github.com/python-lsp/python-lsp-server) is a Python [Language Server](https://microsoft.github.io/language-server-protocol/) for completion, linting, go to definition, etc.

```
pip install 'python-lsp-server[all]' pylsp-mypy python-lsp-isort python-lsp-black
```

Note the executable for pylsp is also named `pylsp`. You need to set its PATH correctly.
If you use pip from Anaconda, the executable path may be something like `$CONDA_ROOT/bin/pylsp`.
For native python, the path for pylsp may be like `$HOME/.local/bin/pylsp`

### Node

We need to install node.js from [here](https://nodejs.org/en/download/).
For Linux, you can use the following script:

```bash
# Ref: https://johnpapa.net/node-and-npm-without-sudo/
wget https://nodejs.org/dist/v14.15.4/node-v14.15.4-linux-x64.tar.xz

mkdir -p $HOME/tools
# extract node to a custom directory, the directory should exist.
tar xvf node-v14.15.4-linux-x64.tar.xz --directory=$HOME/tools
```

Then add the following config to `.bash_profile` or `.zshrc`

```bash
export PATH="$HOME/tools/node-v14.15.4-linux-x64/bin:$PATH"
```

Source the file:

```bash
source ~/.bash_profile
# source ~/.zshrc
```

### vim-language-server

[vim-language-server](https://github.com/iamcco/vim-language-server) provides completion for vim script. We can install vim-language-server globally:

```bash
npm install -g vim-language-server
```

vim-language-server is installed in the same directory as the node executable.

### Git

Git is required by plugin manager [lazy.nvim](https://github.com/folke/lazy.nvim) and other git-related plugins.

For Linux and macOS, Git is usually pre-installed.
The version of Git on the Linux system may be too old so that plugins may break.
Check [here](https://jdhao.github.io/2021/03/27/upgrade_git_on_linux/) on how to install and set up the latest version of Git.
For Windows, install [Git for Windows](https://git-scm.com/download/win) and make sure you can run `git` from command line.

### universal-ctags

In order to use tags related plugins such as [vista.vim](https://github.com/liuchengxu/vista.vim), we need to install a ctags distribution.
Universal-ctags is preferred.

To install it on Linux, we need to build it from source. See [here](https://askubuntu.com/a/836521/768311) for the details.
To install ctags on macOS, use [Homebrew](https://formulae.brew.sh/formula/universal-ctags):

```bash
brew install universal-ctags
```

To install it Windows, use [chocolatey](https://chocolatey.org/) or [scoop](https://scoop.sh/)

```
choco install universal-ctags

# scoop bucket add extras
# scoop install universal-ctags
```

Set its PATH properly and make sure you can run `ctags` from command line.

### Ripgrep

[Ripgrep](https://github.com/BurntSushi/ripgrep), aka, `rg`, is a fast grepping tool available for both Linux, Windows and macOS.
It is used by several searching plugins.

For Windows and macOS, we can install it via chocolatey and homebrew respectively.
For Linux, we can download the [binary release](https://github.com/BurntSushi/ripgrep/releases) and install it.

Set its PATH properly and make sure you can run `rg` from command line.

### Linters

A linter is a tool to check the source code for possible style and syntax issues.
Based on the programming languages we use, we may need to install various linters.

+ Python: [pylint](https://github.com/PyCQA/pylint) and [flake8](https://github.com/PyCQA/flake8).
+ Vim script: [vint](https://github.com/Kuniwak/vint).

Set their PATH properly and make sure you can run `pylint`, `flake8` and `vint` from command line.

## Install Nvim

There are various ways to install Nvim depending on your system.
This config is only maintained for [the latest nvim stable release](https://github.com/neovim/neovim/releases/tag/stable).

Please check the official doc on how to install Neovim on different systems: https://github.com/neovim/neovim/blob/master/INSTALL.md

After installing Nvim, we need to set the PATH to nvim correctly.
**Make sure that you can run `nvim` from the command line after all these setups**.

## Setting up Nvim

After installing nvim and all the dependencies, we will install plugin managers and set up this config.

### How to install this configuration

On Linux and macOS, the directory is `~/.config/nvim`.
On Windows, the config directory is `$HOME/AppData/Local/nvim`[^1].
First, we need to remove all the files under the config directory (including dot files),
then go to this directory, and run the following command:

```
git clone --depth=1 https://github.com/jdhao/nvim-config.git .
```

After that, when we first open nvim, all the plugins will be installed automatically.
Since I use quite a lot of plugins (more than 60), it may take some time to install all of them.

[^1]: Use `echo %userprofile%` to see where your `$HOME` is.


File: .ruff_cache/CACHEDIR.TAG
---
Content:
Signature: 8a477f597d28d172789f06886806bc55

File: resources/head.tex
---
Content:
\usepackage{fancyvrb,newverbs}
\usepackage[top=2cm, bottom=1.5cm, left=2cm, right=2cm]{geometry}

\PassOptionsToPackage{dvipsnames,svgnames,x11names}{xcolor}
\usepackage{hyperref}

% begin a new page for each section (first level header),
% we need to combine this with `-V subparagraph` when invoking pandc
% \usepackage{titlesec}
% \newcommand{\sectionbreak}{\clearpage}

% change background color for inline code in markdown files.
% The following code does not work well for long text, because the text will exceed the page boundary.
\definecolor{bgcolor}{HTML}{DADADA}
\let\oldtexttt\texttt

\renewcommand{\texttt}[1]{
  \colorbox{bgcolor}{\oldtexttt{#1}}
}

% change style of quote, see also https://tex.stackexchange.com/a/436253/114857
\usepackage[most]{tcolorbox}

\definecolor{linequote}{RGB}{224,215,188}
\definecolor{backquote}{RGB}{249,245,233}
\definecolor{bordercolor}{RGB}{221,221,221}

% change left border: https://tex.stackexchange.com/a/475716/114857
% change left margin: https://tex.stackexchange.com/a/457936/114857
\newtcolorbox{myquote}[1][]{%
    enhanced,
    breakable,
    size=minimal,
    left=10pt,
    top=5pt,
    bottom=5pt,
    frame hidden,
    boxrule=0pt,
    sharp corners=all,
    colback=backquote,
    borderline west={2pt}{0pt}{bordercolor},
    #1
}

% redefine quote environment to use the myquote environment, see https://tex.stackexchange.com/a/337587/114857
\renewenvironment{quote}{\begin{myquote}}{\end{myquote}}

% start a new page after toc, we need to save the old command before defining
% new one to avoid recursive command calls,
% see https://tex.stackexchange.com/questions/47351/can-i-redefine-a-command-to-contain-itself
\let\oldtoc\tableofcontents
\renewcommand{\tableofcontents}{\oldtoc\newpage}

% fix header level issue
\usepackage{enumitem}
\setlistdepth{9}

\setlist[itemize,1]{label=$\bullet$}
\setlist[itemize,2]{label=$\bullet$}
\setlist[itemize,3]{label=$\bullet$}
\setlist[itemize,4]{label=$\bullet$}
\setlist[itemize,5]{label=$\bullet$}
\setlist[itemize,6]{label=$\bullet$}
\setlist[itemize,7]{label=$\bullet$}
\setlist[itemize,8]{label=$\bullet$}
\setlist[itemize,9]{label=$\bullet$}
\renewlist{itemize}{itemize}{9}

\setlist[enumerate,1]{label=$\arabic*.$}
\setlist[enumerate,2]{label=$\alph*.$}
\setlist[enumerate,3]{label=$\roman*.$}
\setlist[enumerate,4]{label=$\arabic*.$}
\setlist[enumerate,5]{label=$\alpha*$}
\setlist[enumerate,6]{label=$\roman*.$}
\setlist[enumerate,7]{label=$\arabic*.$}
\setlist[enumerate,8]{label=$\alph*.$}
\setlist[enumerate,9]{label=$\roman*.$}
\renewlist{enumerate}{enumerate}{9}


File: autoload/text_obj.vim
---
Content:
function! text_obj#URL() abort
  if match(&runtimepath, 'vim-highlighturl') != -1
    " Note that we use https://github.com/itchyny/vim-highlighturl to get the URL pattern.
    let url_pattern = highlighturl#default_pattern()
  else
    let url_pattern = expand('<cfile>')
    " Since expand('<cfile>') also works for normal words, we need to check if
    " this is really URL using heuristics, e.g., URL length.
    if len(url_pattern) <= 10
      return
    endif
  endif

  " We need to find all possible URL on this line and their start, end index.
  " Then find where current cursor is, and decide if cursor is on one of the
  " URLs.
  let line_text = getline('.')
  let url_infos = []

  let [_url, _idx_start, _idx_end] = matchstrpos(line_text, url_pattern)
  while _url !=# ''
    let url_infos += [[_url, _idx_start+1, _idx_end]]
    let [_url, _idx_start, _idx_end] = matchstrpos(line_text, url_pattern, _idx_end)
  endwhile

  " echo url_infos
  " If no URL is found, do nothing.
  if len(url_infos) == 0
    return
  endif

  let [start_col, end_col] = [-1, -1]
  " If URL is found, find if cursor is on it.
  let [buf_num, cur_row, cur_col] = getcurpos()[0:2]
  for url_info in url_infos
    " echo url_info
    let [_url, _idx_start, _idx_end] = url_info
    if cur_col >= _idx_start && cur_col <= _idx_end
      let start_col = _idx_start
      let end_col = _idx_end
      break
    endif
  endfor

  " Cursor is not on a URL, do nothing.
  if start_col == -1
    return
  endif

  " Now set the '< and '> mark
  call setpos("'<", [buf_num, cur_row, start_col, 0])
  call setpos("'>", [buf_num, cur_row, end_col, 0])
  normal! gv
endfunction

function! text_obj#MdCodeBlock(type) abort
  " the parameter type specify whether it is inner text objects or around
  " text objects.

  " Move the cursor to the end of line in case that cursor is on the opening
  " of a code block. Actually, there are still issues if the cursor is on the
  " closing of a code block. In this case, the start row of code blocks would
  " be wrong. Unless we can match code blocks, it not easy to fix this.
  normal! $
  let start_row = searchpos('\s*```', 'bnW')[0]
  let end_row = searchpos('\s*```', 'nW')[0]

  let buf_num = bufnr()
  if a:type ==# 'i'
    let start_row += 1
    let end_row -= 1
  endif
  " echo a:type start_row end_row

  call setpos("'<", [buf_num, start_row, 1, 0])
  call setpos("'>", [buf_num, end_row, 1, 0])
  execute 'normal! `<V`>'
endfunction

function! text_obj#Buffer() abort
  let buf_num = bufnr()

  call setpos("'<", [buf_num, 1, 1, 0])
  call setpos("'>", [buf_num, line('$'), 1, 0])
  execute 'normal! `<V`>'
endfunction


File: autoload/buf_utils.vim
---
Content:
function! buf_utils#GoToBuffer(count, direction) abort
  if a:count == 0
    if a:direction ==# 'forward'
      bnext
    elseif a:direction ==# 'backward'
      bprevious
    else
      echoerr 'Bad argument ' a:direction
    endif
    return
  endif
  " Check the validity of buffer number.
  if index(s:GetBufNums(), a:count) == -1
    " Using `lua vim.notify('invalid bufnr: ' .. a:count)` won't work, because
    " we are essentially mixing Lua and vim script. We need to make sure that
    " args inside vim.notify() are valid vim values. The conversion from vim
    " value to lua value will be done by Nvim. See also https://github.com/neovim/neovim/pull/11338.
    call v:lua.vim.notify('Invalid bufnr: ' . a:count, 4, {'title': 'nvim-config'})
    return
  endif

  " Do not use {count} for gB (it is less useful)
  if a:direction ==# 'forward'
    silent execute('buffer' . a:count)
  endif
endfunction

function! s:GetBufNums() abort
  return map(copy(getbufinfo({'buflisted':1})), 'v:val.bufnr')
endfunction


File: autoload/utils.vim
---
Content:
" Create command alias safely, see https://stackoverflow.com/q/3878692/6064933
" The following two functions are taken from answer below on SO:
" https://stackoverflow.com/a/10708687/6064933
function! utils#Cabbrev(key, value) abort
  execute printf('cabbrev <expr> %s (getcmdtype() == ":" && getcmdpos() <= %d) ? %s : %s',
        \ a:key, 1+len(a:key), <SID>Single_quote(a:value), <SID>Single_quote(a:key))
endfunction

function! s:Single_quote(str) abort
  return "'" . substitute(copy(a:str), "'", "''", 'g') . "'"
endfunction

" Custom fold expr, adapted from https://vi.stackexchange.com/a/9094/15292
function! utils#VimFolds(lnum) abort
  " get content of current line and the line below
  let l:cur_line = getline(a:lnum)
  let l:next_line = getline(a:lnum+1)

  if l:cur_line =~# '^"{'
    return '>' . (matchend(l:cur_line, '"{*') - 1)
  endif

  if l:cur_line ==# '' && (matchend(l:next_line, '"{*') - 1) == 1
    return 0
  endif

  return '='
endfunction

" Custom fold text, adapted from https://vi.stackexchange.com/a/3818/15292
" and https://vi.stackexchange.com/a/6608/15292
function! utils#MyFoldText() abort
  let l:line = getline(v:foldstart)
  let l:fold_line_num = v:foldend - v:foldstart
  let l:fold_text = substitute(l:line, '^"{\+', '', 'g')
  let l:fill_char_num = &textwidth - len(l:fold_text) - len(l:fold_line_num) - 10
  return printf('+%s%s %s (%s L)', repeat('-', 4), l:fold_text, repeat('-', l:fill_char_num), l:fold_line_num)
endfunction

" Toggle cursor column
function! utils#ToggleCursorCol() abort
  if &cursorcolumn
    set nocursorcolumn
    echo 'cursorcolumn: OFF'
  else
    set cursorcolumn
    echo 'cursorcolumn: ON'
  endif
endfunction

function! utils#SwitchLine(src_line_idx, direction) abort
  if a:direction ==# 'up'
    if a:src_line_idx == 1
        return
    endif
    move-2
  elseif a:direction ==# 'down'
    if a:src_line_idx == line('$')
        return
    endif
    move+1
  endif
endfunction

function! utils#MoveSelection(direction) abort
  " only do this if previous mode is visual line mode. Once we press some keys in
  " visual line mode, we will leave this mode. So the output of `mode()` will be
  " `n` instead of `V`. We can use `visualmode()` instead to check the previous
  " mode, see also https://stackoverflow.com/a/61486601/6064933
  if visualmode() !=# 'V'
    return
  endif

  let l:start_line = line("'<")
  let l:end_line = line("'>")
  let l:num_line = l:end_line - l:start_line + 1

  if a:direction ==# 'up'
    if l:start_line == 1
      " we can also directly use `normal gv`, see https://stackoverflow.com/q/9724123/6064933
      normal! gv
      return
    endif
    silent execute printf('%s,%smove-2', l:start_line, l:end_line)
    normal! gv
  elseif a:direction ==# 'down'
    if l:end_line == line('$')
      normal! gv
      return
    endif
    silent execute printf('%s,%smove+%s', l:start_line, l:end_line, l:num_line)
    normal! gv
  endif
endfunction


function! utils#Get_titlestr() abort
  let l:title_str = ''
  if g:is_linux
      let l:title_str = hostname() . '  '
  endif

  let l:buf_path = expand('%:p:~')
  let l:title_str = l:title_str . l:buf_path . '  '
  if &buflisted && l:buf_path != ""
    let l:title_str = l:title_str . strftime('%Y-%m-%d %H:%M:%S%z', getftime(expand('%')))
  endif

  return l:title_str
endfunction

" Output current time or unix timestamp in human-readable format.
function! utils#iso_time(timestamp) abort
  " Get current datetime
  if !a:timestamp
    return strftime('%Y-%m-%d %H:%M:%S%z')
  endif

  " this timestamp in expressed in milliseconds
  if len(a:timestamp) == 13
    let l:timestamp = a:timestamp[:-4]
  " this timestamp in expressed in microseconds
  elseif len(a:timestamp) == 16
    let l:timestamp = a:timestamp[:-7]
  else
    let l:timestamp = a:timestamp
  endif
  return strftime('%Y-%m-%d %H:%M:%S%z', l:timestamp)

endfunction

" Check if we are inside a Git repo.
function! utils#Inside_git_repo() abort
  let res = system('git rev-parse --is-inside-work-tree')
  if match(res, 'true') == -1
    return v:false
  else
    " Manually trigger a special user autocmd InGitRepo (used lazyloading.
    doautocmd User InGitRepo
    return v:true
  endif
endfunction

function! utils#GetGitBranch()
  let l:res = systemlist('git rev-parse --abbrev-ref HEAD')[0]
  if match(l:res, 'fatal') != -1
    return ''
  else
    return l:res
  endif
endfunction

" Redirect command output to a register for later processing.
" Ref: https://stackoverflow.com/q/2573021/6064933 and https://unix.stackexchange.com/q/8101/221410 .
function! utils#CaptureCommandOutput(command) abort
  let l:tmp = @m
  redir @m
  silent! execute a:command
  redir END

  "create a scratch buffer for dumping the text, ref: https://vi.stackexchange.com/a/11311/15292.
  tabnew | setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile

  let l:lines = split(@m, '\n')
  call nvim_buf_set_lines(0, 0, 0, 0, l:lines)

  let @m = l:tmp
endfunction

" Edit all files matching the given patterns.
function! utils#MultiEdit(patterns) abort
  for p in a:patterns
    for f in glob(p, 0, 1)
      execute 'edit ' . f
    endfor
  endfor
endfunction


File: plugin/abbrev.vim
---
Content:
" some abbreviations
iabbrev reqire require
iabbrev serveral several


File: plugin/command.lua
---
Content:
-- Copy file path to clipboard
vim.api.nvim_create_user_command("CopyPath", function(context)
  local full_path = vim.fn.glob("%:p")

  local file_path = nil
  if context["args"] == "nameonly" then
    file_path = vim.fn.fnamemodify(full_path, ":t")
  end

  -- get the file path relative to project root
  if context["args"] == "relative" then
    local project_marker = { ".git", "pyproject.toml" }
    local project_root = vim.fs.root(0, project_marker)
    if project_root == nil then
      vim.print("can not find project root")
      return
    end

    file_path = vim.fn.substitute(full_path, project_root, "<project-root>", "g")
  end

  if context["args"] == "absolute" then
    file_path = full_path
  end

  vim.fn.setreg("+", file_path)
  vim.print("Filepath copied to clipboard!")
end, {
  bang = false,
  nargs = 1,
  force = true,
  desc = "Copy current file path to clipboard",
  complete = function()
    return { "nameonly", "relative", "absolute" }
  end,
})

-- JSON format part of or the whole file
vim.api.nvim_create_user_command("JSONFormat", function(context)
  local range = context["range"]
  local line1 = context["line1"]
  local line2 = context["line2"]

  if range == 0 then
    -- the command is invoked without range, then we assume whole buffer
    local cmd_str = string.format("%s,%s!python -m json.tool", line1, line2)
    vim.fn.execute(cmd_str)
  elseif range == 2 then
    -- the command is invoked with some range
    local cmd_str = string.format("%s,%s!python -m json.tool", line1, line2)
    vim.fn.execute(cmd_str)
  else
    local msg = string.format("unsupported range: %s", range)
    vim.api.nvim_echo({ { msg } }, true, { err = true })
  end
end, {
  desc = "Format JSON string",
  range = "%",
})


File: plugin/log-autocmds.vim
---
Content:
command! LogAutocmds call s:log_autocmds_toggle()

function! s:log_autocmds_toggle()
  augroup LogAutocmd
    autocmd!
  augroup END

  let l:date = strftime('%F', localtime())
  let s:activate = get(s:, 'activate', 0) ? 0 : 1
  if !s:activate
    call s:log('Stopped autocmd log (' . l:date . ')')
    return
  endif

  call s:log('Started autocmd log (' . l:date . ')')
  augroup LogAutocmd
    for l:au in s:aulist
      silent execute 'autocmd' l:au '* call s:log(''' . l:au . ''')'
    endfor
  augroup END
endfunction

function! s:log(message)
  silent execute '!echo "'
        \ . strftime('%T', localtime()) . ' - ' . a:message . '"'
        \ '>> /tmp/vim_log_autocommands'
endfunction

" These are deliberately left out due to side effects
" - SourceCmd
" - FileAppendCmd
" - FileWriteCmd
" - BufWriteCmd
" - FileReadCmd
" - BufReadCmd
" - FuncUndefined

let s:aulist = [
      \ 'BufNewFile',
      \ 'BufReadPre',
      \ 'BufRead',
      \ 'BufReadPost',
      \ 'FileReadPre',
      \ 'FileReadPost',
      \ 'FilterReadPre',
      \ 'FilterReadPost',
      \ 'StdinReadPre',
      \ 'StdinReadPost',
      \ 'BufWrite',
      \ 'BufWritePre',
      \ 'BufWritePost',
      \ 'FileWritePre',
      \ 'FileWritePost',
      \ 'FileAppendPre',
      \ 'FileAppendPost',
      \ 'FilterWritePre',
      \ 'FilterWritePost',
      \ 'BufAdd',
      \ 'BufCreate',
      \ 'BufDelete',
      \ 'BufWipeout',
      \ 'BufFilePre',
      \ 'BufFilePost',
      \ 'BufEnter',
      \ 'BufLeave',
      \ 'BufWinEnter',
      \ 'BufWinLeave',
      \ 'BufUnload',
      \ 'BufHidden',
      \ 'BufNew',
      \ 'SwapExists',
      \ 'FileType',
      \ 'Syntax',
      \ 'EncodingChanged',
      \ 'TermChanged',
      \ 'VimEnter',
      \ 'GUIEnter',
      \ 'GUIFailed',
      \ 'TermResponse',
      \ 'QuitPre',
      \ 'VimLeavePre',
      \ 'VimLeave',
      \ 'FileChangedShell',
      \ 'FileChangedShellPost',
      \ 'FileChangedRO',
      \ 'ShellCmdPost',
      \ 'ShellFilterPost',
      \ 'CmdUndefined',
      \ 'SpellFileMissing',
      \ 'SourcePre',
      \ 'VimResized',
      \ 'FocusGained',
      \ 'FocusLost',
      \ 'CursorHold',
      \ 'CursorHoldI',
      \ 'CursorMoved',
      \ 'CursorMovedI',
      \ 'WinEnter',
      \ 'WinLeave',
      \ 'TabEnter',
      \ 'TabLeave',
      \ 'CmdwinEnter',
      \ 'CmdwinLeave',
      \ 'InsertEnter',
      \ 'InsertChange',
      \ 'InsertLeave',
      \ 'InsertCharPre',
      \ 'TextChanged',
      \ 'TextChangedI',
      \ 'ColorScheme',
      \ 'RemoteReply',
      \ 'QuickFixCmdPre',
      \ 'QuickFixCmdPost',
      \ 'SessionLoadPost',
      \ 'MenuPopup',
      \ 'CompleteDone',
      \ 'User',
      \ ]



File: plugin/command.vim
---
Content:
" Capture output from a command to register @m, to paste, press "mp
command! -nargs=1 -complete=command Redir call utils#CaptureCommandOutput(<q-args>)

command! -bar -bang -nargs=+ -complete=file Edit call utils#MultiEdit([<f-args>])
call utils#Cabbrev('edit', 'Edit')

call utils#Cabbrev('man', 'Man')

" show current date and time in human readable format
command! -nargs=? Datetime echo utils#iso_time(<q-args>)

" Convert Markdown file to PDF
command! ToPDF call s:md_to_pdf()

function! s:md_to_pdf() abort
  " check if pandoc is installed
  if executable('pandoc') != 1
    echoerr "pandoc not found"
    return
  endif

  let l:md_path = expand("%:p")
  let l:pdf_path = fnamemodify(l:md_path, ":r") .. ".pdf"

  let l:header_path = stdpath('config') . '/resources/head.tex'

  let l:cmd = "pandoc --pdf-engine=xelatex --highlight-style=zenburn --table-of-content " .
        \ "--include-in-header=" . l:header_path . " -V fontsize=10pt -V colorlinks -V toccolor=NavyBlue " .
        \ "-V linkcolor=red -V urlcolor=teal -V filecolor=magenta -s " .
        \ l:md_path . " -o " . l:pdf_path

  if g:is_mac
    let l:cmd = l:cmd . '&& open ' . l:pdf_path
  endif

  if g:is_win
    let l:cmd = l:cmd . '&& start ' . l:pdf_path
  endif

  " echomsg l:cmd

  let l:id = jobstart(l:cmd)

  if l:id == 0 || l:id == -1
    echoerr "Error running command"
  endif
endfunction


File: my_snippets/all.snippets
---
Content:
snippet "(?<!\w)ltx" "LaTeX symbol" r
LaTeX
endsnippet

snippet arw "Right-pointed arrow"
--> $1
endsnippet


File: my_snippets/markdown.snippets
---
Content:
global !p
def gen_header(snip):
	placeholders_string = snip.buffer[snip.line].strip()
	level = int(placeholders_string[0])

	# erase current line
	snip.buffer[snip.line] = ""
	line_content = "#"*level + " ${1:Section Name}"
	line_content += '\n$0'

	snip.expand_anon(line_content)
endglobal

snippet "(k1|kbd)" "HTML kbd tag" rw
<kbd>${1:KEY}</kbd>$0
endsnippet

snippet k2 "Two key strokes shortcut"
<kbd>${1:KEY}</kbd> + <kbd>${2:KEY}</kbd>
endsnippet

snippet k3 "Three key strokes shortcut"
<kbd>${1:KEY}</kbd> + <kbd>${2:KEY}</kbd> + <kbd>${3:KEY}</kbd>
endsnippet

snippet meta "Markdown front matter (YAML format)" b
---
title: "$1"
date: `!p from datetime import datetime
if not snip.c:
	snip.rv=datetime.now().astimezone().strftime("%Y-%m-%d %H:%M:%S%z")`
tags: [$2]
categories: [$3]
---
$0
endsnippet

snippet more "HTML more tag"
<!--more-->
endsnippet

snippet img "Aligned image using HTML tag"
<p align="center">
<img src="${1:URL}" width="${2:800}">
</p>
$0
endsnippet

snippet font "HTML font tag"
<font color="${1:blue}">${2:TEXT}</font>
endsnippet

snippet link "Markdown links"
[$1]($2)$0
endsnippet

post_jump "gen_header(snip)"
snippet "h([1-6])" "Markdown header" br
`!p snip.rv = match.group(1)`
endsnippet

snippet detail "Clickable details" b
<details>
<summary><font size="2" color="red">${1:Click to show the code.}</font></summary>

$2
</details>
endsnippet

snippet yh "" w
$1
endsnippet

snippet info "info box"
<style type="text/css">
@import url('//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css');

.info-msg {
	color: #059;
	background-color: #BEF;
	margin: 5px 0;
	margin-bottom: 20px;
	padding: 10px;
	border-radius: 5px 5px 5px 5px;
	border: 2px solid transparent;
	border-color: transparent;
}
</style>

<div class="info-msg">
	<i class="fa fa-info-circle"> Info</i></br>
	${1:info text}
</div>
$0
endsnippet

snippet warn "warning box"
<style type="text/css">
@import url('//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css');

.warning-msg {
	color: #9F6000;
	background-color: #FEEFB3;
	margin: 5px 0;
	margin-bottom: 20px;
	padding: 10px;
	border-radius: 5px 5px 5px 5px;
	border: 2px solid transparent;
	border-color: transparent;
}
</style>

<div class="warning-msg">
	<i class="fa fa-warning"> Warning</i></br>
	${1:warning text}
</div>
$0
endsnippet

snippet error "error box"
<style type="text/css">
@import url('//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css');

.error-msg {
	color: #D8000C;
	background-color: #FFBABA;
	margin: 5px 0;
	margin-bottom: 20px;
	padding: 10px;
	border-radius: 5px 5px 5px 5px;
	border: 2px solid transparent;
	border-color: transparent;
}
</style>

<div class="error-msg">
	<i class="fa fa-times-circle"> Error</i></br>
	${1:error text}
</div>
$0
endsnippet

snippet success "success box"
<style type="text/css">
@import url('//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css');

.success-msg {
	color: #270;
	background-color: #DFF2BF;
	margin: 5px 0;
	margin-bottom: 20px;
	padding: 10px;
	border-radius: 5px 5px 5px 5px;
	border: 2px solid transparent;
	border-color: transparent;
}
</style>

<div class="success-msg">
	<i class="fa fa-check"></i>
	${1:success text}
</div>
$0
endsnippet

snippet td "too long do not read" bw
tl;dr: $1
endsnippet


File: my_snippets/snippets.snippets
---
Content:
# copied from https://github.com/honza/vim-snippets/blob/master/UltiSnips/snippets.snippets
snippet snip "Ultisnips snippet definition" b
`!p snip.rv = "snippet"` ${1:Tab_trigger} "${2:Description}" ${3:b}
${0:${VISUAL}}
`!p snip.rv = "endsnippet"`
endsnippet


File: my_snippets/cpp.snippets
---
Content:
snippet bare "barebone code template"
#include <iostream>
#include <vector>
#include <string>
#include <map>
#include <unordered_map>
#include <set>
#include <unordered_set>
#include <stack>
#include <queue>
#include <numeric>

using std::cout;
using std::endl;
using std::vector;
using std::string;
using std::map;
using std::unordered_map;
using std::set;
using std::unordered_set;
using std::stack;
using std::queue;
using std::pair;
using std::make_pair;



int main()
{

	return 0;
}
endsnippet

snippet icd "#include directive" b
#include <$1>
$0
endsnippet

snippet plist "print vector" w
template <class T>
void printList(const T& arr, const string& desc){
	std::cout << desc << ": [";

	for (auto it = arr.begin(); it != arr.end(); it++){
		std::cout << *it << ((std::next(it) != arr.end()) ? ", " : "");
	}
	std::cout << "]\n";
}
endsnippet

snippet pmat "print list of list" w
template <class T>
void printMat(const vector<vector<T>>& mat, const string& desc){
	cout << desc << ": " << endl;

	for (auto it1 = mat.begin(); it1 != mat.end(); it1++){
		auto cur_vec = *it1;
		cout << "[";
		for (auto it2 = cur_vec.begin(); it2 != cur_vec.end(); it2++){
			cout << *it2 << ((std::next(it2) != cur_vec.end()) ? ", " : "]\n");
		}
	}
}
endsnippet

snippet pqueue "print queue"
template <class T>
void printQueue(T q){
	while(!q.empty()){
		std::cout << q.top() << " ";
		q.pop();
	}
	std::cout << '\n';
}
endsnippet

snippet cout "print a variable" w
cout << "$1: " << $2 << endl;
endsnippet

snippet random "Generate a random list" b
// Generate a random sequence of length len, in range(low, high) (inclusive).
// need to #include<random>
vector<int> genRandom(int low, int high, int len){
	std::random_device rd;
	std::mt19937 gen(rd());
	std::uniform_int_distribution<int> distribution(low, high);

	vector<int> arr(len, 0);
	for (int i = 0; i != len; ++i){
		arr[i] = distribution(gen);
	}

	return arr;
}
endsnippet

snippet incset "Use set" b
#include <set>

using std::set;
endsnippet

snippet incmap "Use map" b
#include <map>

using std::map;
endsnippet

snippet incqueue "Use queue" b
#include <queue>

using std::queue;
endsnippet

snippet incstr "Use string" b
#include <string>

using std::string;
endsnippet

snippet incvec "Use vector" b
#include <vector>

using std::vector;
endsnippet

snippet incstack "Use stack" b
#include <stack>

using std::stack;
endsnippet

snippet vec "std::vector" w
vector<$1> ${2:vec}
endsnippet

snippet map "std::map" w
map<$1, $2> ${3:mymap}
endsnippet

snippet umap "std::unordered_map"
unordered_map<$1, $2> ${3:mymap}
endsnippet

snippet set "std::set" w
set<$1> ${2:myset}
endsnippet

snippet uset "std::unordered_set" w
unordered_set<$1> ${2:myset}
endsnippet

snippet queue "std::queue" w
queue<$1> ${2:q}
endsnippet

snippet stack "std::stack" w
stack<$1> ${2:mystack}
endsnippet

snippet sol "solution" w
auto solution = Solution();
$0
endsnippet

snippet for "for loop" w
for ($1; $2; $3){
	$4
}
endsnippet

snippet if "if condition" w
if ($1){
	$2
}
$0
endsnippet

snippet ifelse "if else condition"
if ($1){
	$2
}else{

}
endsnippet


File: my_snippets/python.snippets
---
Content:
snippet head "Python source file header" b
"""
Description: $1
Author: AlexONEX (libertarian_meme@hotmail.com)
Created: `!v strftime("%Y-%m-%d %H:%M:%S%z")`
"""
$0
endsnippet

snippet print "Print value of some variable"
print("$1".format($2))
$0
endsnippet

snippet impa "import FOO as BAR" b
import ${1:FOO} as ${2:BAR}
endsnippet

snippet main "Main function boilerplate" b
def main():
	$0

if __name__ == "__main__":
	main()
endsnippet

snippet sol "solution" b
solution = Solution()
endsnippet


File: my_snippets/tex.snippets
---
Content:
global !p
def math():
    try:
        result = vim.eval('vimtex#syntax#in_mathzone()')
        print(f"Math zone check result: {result}")

        # Probar diferentes entornos
        envs = ['math', 'displaymath', 'equation', 'align']
        for env in envs:
            [x,y] = vim.eval(f"vimtex#env#is_inside('{env}')")
            print(f"Environment {env}: [{x},{y}]")

        return result == '1'
    except Exception as e:
        print(f"Error in math(): {str(e)}")
        return False

def comment():
	return vim.eval('vimtex#syntax#in_comment()') == '1'

def env(name):
	[x,y] = vim.eval("vimtex#env#is_inside('" + name + "')")
	return x != '0' and y != '0'

endglobal

snippet today "Date"
`date +%F`
endsnippet

snippet template "Basic template" b
\documentclass[a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[dutch]{babel}
\usepackage{amsmath, amssymb}


% figure support
\usepackage{import}
\usepackage{xifthen}
\pdfminorversion=7
\usepackage{pdfpages}
\usepackage{transparent}
\newcommand{\incfig}[1]{%
	\def\svgwidth{\columnwidth}
	\import{./figures/}{#1.pdf_tex}
}

\pdfsuppresswarningpagegroup=1

\begin{document}
	$0
\end{document}
endsnippet

snippet beg "begin{} / end{}" bA
\\begin{$1}
	$0
\\end{$1}
endsnippet

priority 100
snippet ... "ldots" iA
\ldots
endsnippet

snippet table "Table environment" b
\begin{table}[${1:htpb}]
	\centering
	\caption{${2:caption}}
	\label{tab:${3:label}}
	\begin{tabular}{${5:c}}
	$0${5/((?<=.)c|l|r)|./(?1: & )/g}
	\end{tabular}
\end{table}
endsnippet

snippet fig "Figure environment" b
\begin{figure}[${1:htpb}]
	\centering
	${2:\includegraphics[width=0.8\textwidth]{$3}}
	\caption{${4:$3}}
	\label{fig:${5:${3/\W+/-/g}}}
\end{figure}
endsnippet

snippet enum "Enumerate" bA
\begin{enumerate}
	\item $0
\end{enumerate}
endsnippet

snippet item "Itemize" bA
\begin{itemize}
	\item $0
\end{itemize}
endsnippet

snippet desc "Description" b
\begin{description}
	\item[$1] $0
\end{description}
endsnippet

snippet pac "Package" b
\usepackage[${1:options}]{${2:package}}$0
endsnippet

snippet => "implies" Ai
\implies
endsnippet

snippet =< "implied by" Ai
\impliedby
endsnippet

context "math()"
snippet iff "iff" Ai
\iff
endsnippet

snippet mk "Math" wA
$${1}$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$2
endsnippet

snippet dm "Math" wA
\[
${1:${VISUAL}}
.\] $0
endsnippet

snippet ali "Align" bA
\begin{align*}
	${1:${VISUAL}}
.\end{align*}
endsnippet


context "math()"
snippet // "Fraction" iA
\\frac{$1}{$2}$0
endsnippet

snippet / "Fraction" i
\\frac{${VISUAL}}{$1}$0
endsnippet

context "math()"
snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)/' "symbol frac" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet

priority 1000
context "math()"
snippet '^.*\)/' "() frac" wrA
`!p
stripped = match.string[:-1]
depth = 0
i = len(stripped) - 1
while True:
	if stripped[i] == ')': depth += 1
	if stripped[i] == '(': depth -= 1
	if depth == 0: break;
	i-=1
snip.rv = stripped[0:i] + "\\frac{" + stripped[i+1:-1] + "}"
`{$1}$0
endsnippet

context "math()"
snippet '([A-Za-z])(\d)' "auto subscript" wrA
`!p snip.rv = match.group(1)`_`!p snip.rv = match.group(2)`
endsnippet

context "math()"
snippet '([A-Za-z])_(\d\d)' "auto subscript2" wrA
`!p snip.rv = match.group(1)`_{`!p snip.rv = match.group(2)`}
endsnippet


snippet sympy "sympyblock " w
sympy $1 sympy$0
endsnippet

priority 10000
snippet 'sympy(.*)sympy' "sympy" wr
`!p
from sympy import *
x, y, z, t = symbols('x y z t')
k, m, n = symbols('k m n', integer=True)
f, g, h = symbols('f g h', cls=Function)
init_printing()
snip.rv = eval('latex(' + match.group(1).replace('\\', '').replace('^', '**').replace('{', '(').replace('}', ')') + ')')
`
endsnippet

priority 1000
snippet math "mathematicablock" w
math $1 math$0
endsnippet

priority 10000
snippet 'math(.*)math' "math" wr
`!p
import subprocess
code = match.group(1)
code = 'ToString[' + code + ', TeXForm]'
snip.rv = subprocess.check_output(['wolframscript', '-code', code])
`
endsnippet

snippet == "equals" iA
&= $1 \\\\
endsnippet

snippet != "equals" iA
\neq
endsnippet

context "math()"
snippet ceil "ceil" iA
\left\lceil $1 \right\rceil $0
endsnippet

context "math()"
snippet floor "floor" iA
\left\lfloor $1 \right\rfloor$0
endsnippet

snippet pmat "pmat" iA
\begin{pmatrix} $1 \end{pmatrix} $0
endsnippet

snippet bmat "bmat" iA
\begin{bmatrix} $1 \end{bmatrix} $0
endsnippet

context "math()"
snippet () "left( right)" iA
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr( "left( right)" i
\left( ${1:${VISUAL}} \right) $0
endsnippet

snippet lr| "left| right|" i
\left| ${1:${VISUAL}} \right| $0
endsnippet

snippet lr{ "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lrb "left\{ right\}" i
\left\\{ ${1:${VISUAL}} \right\\} $0
endsnippet

snippet lr[ "left[ right]" i
\left[ ${1:${VISUAL}} \right] $0
endsnippet

snippet lra "leftangle rightangle" iA
\left<${1:${VISUAL}} \right>$0
endsnippet

context "math()"
snippet conj "conjugate" iA
\overline{$1}$0
endsnippet

snippet sum "sum" w
\sum_{n=${1:1}}^{${2:\infty}} ${3:a_n z^n}
endsnippet

snippet taylor "taylor" w
\sum_{${1:k}=${2:0}}^{${3:\infty}} ${4:c_$1} (x-a)^$1 $0
endsnippet

snippet lim "limit" w
\lim_{${1:n} \to ${2:\infty}}
endsnippet

snippet limsup "limsup" w
\limsup_{${1:n} \to ${2:\infty}}
endsnippet

snippet prod "product" w
\prod_{${1:n=${2:1}}}^{${3:\infty}} ${4:${VISUAL}} $0
endsnippet

snippet part "d/dx" w
\frac{\partial ${1:V}}{\partial ${2:x}} $0
endsnippet

context "math()"
snippet sq "\sqrt{}" iA
\sqrt{${1:${VISUAL}}} $0
endsnippet

context "math()"
snippet sr "^2" A
^2
endsnippet

context "math()"
snippet cb "^3" iA
^3
endsnippet

context "math()"
snippet td "to the ... power" iA
^{$1}$0
endsnippet

context "math()"
snippet rd "to the ... power" iA
^{($1)}$0
endsnippet

snippet __ "subscript" iA
_{$1}$0
endsnippet

snippet ooo "\infty" iA
\infty
endsnippet

snippet rij "mrij" i
(${1:x}_${2:n})_{${3:$2}\\in${4:\\N}}$0
endsnippet

snippet <= "leq" iA
\le
endsnippet

snippet >= "geq" iA
\ge
endsnippet

context "math()"
snippet EE "geq" iA
\exists
endsnippet

context "math()"
snippet AA "forall" iA
\forall
endsnippet

context "math()"
snippet xnn "xn" iA
x_{n}
endsnippet

context "math()"
snippet ynn "yn" iA
y_{n}
endsnippet


context "math()"
snippet xii "xi" iA
x_{i}
endsnippet

context "math()"
snippet yii "yi" iA
y_{i}
endsnippet

context "math()"
snippet xjj "xj" iA
x_{j}
endsnippet

context "math()"
snippet yjj "yj" iA
y_{j}
endsnippet

context "math()"
snippet xp1 "x" iA
x_{n+1}
endsnippet

context "math()"
snippet xmm "x" iA
x_{m}
endsnippet

snippet R0+ "R0+" iA
\\R_0^+
endsnippet

snippet plot "Plot" w
\begin{figure}[$1]
	\centering
	\begin{tikzpicture}
		\begin{axis}[
			xmin= ${2:-10}, xmax= ${3:10},
			ymin= ${4:-10}, ymax = ${5:10},
			axis lines = middle,
		]
			\addplot[domain=$2:$3, samples=${6:100}]{$7};
		\end{axis}
	\end{tikzpicture}
	\caption{$8}
	\label{${9:$8}}
\end{figure}
endsnippet

snippet nn "Tikz node" w
\node[$5] (${1/[^0-9a-zA-Z]//g}${2}) ${3:at (${4:0,0}) }{$${1}$};
$0
endsnippet

context "math()"
snippet mcal "mathcal" iA
\mathcal{$1}$0
endsnippet

snippet lll "l" iA
\ell
endsnippet

context "math()"
snippet nabl "nabla" iA
\nabla
endsnippet

context "math()"
snippet xx "cross" iA
\times
endsnippet

priority 100
snippet ** "cdot" iA
\cdot
endsnippet

context "math()"
snippet norm "norm" iA
\|$1\|$0
endsnippet

priority 100
context "math()"
snippet '(?<!\\)(sin|cos|arccot|cot|csc|ln|log|exp|star|perp)' "ln" rwA
\\`!p snip.rv = match.group(1)`
endsnippet

priority 300
context "math()"
snippet dint "integral" wA
\int_{${1:-\infty}}^{${2:\infty}} ${3:${VISUAL}} $0
endsnippet

priority 200
context "math()"
snippet '(?<!\\)(arcsin|arccos|arctan|arccot|arccsc|arcsec|pi|zeta|int)' "ln" rwA
\\`!p snip.rv = match.group(1)`
endsnippet


priority 100
context "math()"
snippet -> "to" iA
\to
endsnippet

priority 200
context "math()"
snippet <-> "leftrightarrow" iA
\leftrightarrow
endsnippet

context "math()"
snippet !> "mapsto" iA
\mapsto
endsnippet

context "math()"
snippet invs "inverse" iA
^{-1}
endsnippet

context "math()"
snippet compl "complement" iA
^{c}
endsnippet

context "math()"
snippet \\\ "setminus" iA
\setminus
endsnippet

snippet >> ">>" iA
\gg
endsnippet

snippet << "<<" iA
\ll
endsnippet


snippet ~~ "~" iA
\sim
endsnippet

context "math()"
snippet set "set" wA
\\{$1\\} $0
endsnippet

snippet || "mid" iA
 \mid
endsnippet


context "math()"
snippet cc "subset" Ai
\subset
endsnippet

snippet notin "not in " iA
\not\in
endsnippet

context "math()"
snippet inn "in " iA
\in
endsnippet

snippet NN "n" iA
\N
endsnippet

snippet Nn "cap" iA
\cap
endsnippet

snippet UU "cup" iA
\cup
endsnippet

snippet uuu "bigcup" iA
\bigcup_{${1:i \in ${2: I}}} $0
endsnippet

snippet nnn "bigcap" iA
\bigcap_{${1:i \in ${2: I}}} $0
endsnippet

snippet OO "emptyset" iA
\O
endsnippet

snippet RR "real" iA
\R
endsnippet

snippet QQ "Q" iA
\Q
endsnippet

snippet ZZ "Z" iA
\Z
endsnippet

snippet <! "normal" iA
\triangleleft
endsnippet

snippet <> "hokje" iA
\diamond
endsnippet


context "math()"
snippet '(?<!i)sts' "text subscript" irA
_\text{$1} $0
endsnippet

context "math()"
snippet tt "text" iA
\text{$1}$0
endsnippet

context "math()"
snippet case "cases" wA
\begin{cases}
	$1
\end{cases}
endsnippet

snippet SI "SI" iA
\SI{$1}{$2}
endsnippet

snippet bigfun "Big function" iA
\begin{align*}
	$1: $2 &\longrightarrow $3 \\\\
	$4 &\longmapsto $1($4) = $0
.\end{align*}
endsnippet

snippet cvec "column vector" iA
\begin{pmatrix} ${1:x}_${2:1}\\\\ \vdots\\\\ $1_${2:n} \end{pmatrix}
endsnippet

priority 10
context "math()"
snippet "bar" "bar" riA
\overline{$1}$0
endsnippet

priority 100
context "math()"
snippet "([a-zA-Z])bar" "bar" riA
\overline{`!p snip.rv=match.group(1)`}
endsnippet

priority 10
context "math()"
snippet "hat" "hat" riA
\hat{$1}$0
endsnippet

priority 100
context "math()"
snippet "([a-zA-Z])hat" "hat" riA
\hat{`!p snip.rv=match.group(1)`}
endsnippet

snippet letw "let omega" iA
Let $\Omega \subset \C$ be open.
endsnippet


snippet HH "H" iA
\mathbb{H}
endsnippet

snippet DD "D" iA
\mathbb{D}
endsnippet

# vim:ft=snippets

snippet preamble "Prembulo LaTeX completo" b


\documentclass[a4paper,twoside]{article}

%----------------------------------------------------------------------------------------
%	BASIC PACKAGES
%----------------------------------------------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{float}
\usepackage{booktabs}
\usepackage{enumitem}
\usepackage{parskip}      % No indent paragraphs
\usepackage{emptypage}    % Hide page numbers on empty pages
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{xcolor}
\usepackage{url}

%----------------------------------------------------------------------------------------
%	MATH PACKAGES AND SETTINGS
%----------------------------------------------------------------------------------------
\usepackage{amsmath, amsfonts, mathtools, amsthm, amssymb}
\usepackage{mathrsfs}    % Fancy script capitals
\usepackage{cancel}      % Cancel terms
\usepackage{bm}         % Bold math
\usepackage{stmaryrd}   % For \lightning symbol

% Math shortcuts
\newcommand{\N}{\ensuremath{\mathbb{N}}}
\newcommand{\R}{\ensuremath{\mathbb{R}}}
\newcommand{\Z}{\ensuremath{\mathbb{Z}}}
\newcommand{\Q}{\ensuremath{\mathbb{Q}}}
\newcommand{\C}{\ensuremath{\mathbb{C}}}
\renewcommand{\O}{\ensuremath{\emptyset}}

% Math notation
\let\implies\Rightarrow
\let\impliedby\Leftarrow
\let\iff\Leftrightarrow
\let\epsilon\varepsilon
\let\svlim\lim\def\lim{\svlim\limits}  % Put x \to \infty below \lim

% Contradiction symbol
\newcommand{\contra}{\scalebox{1.5}{$\lightning$}}

%----------------------------------------------------------------------------------------
%	CUSTOM ENVIRONMENTS
%----------------------------------------------------------------------------------------
\usepackage{mdframed}
\mdfsetup{skipabove=1em,skipbelow=0em}

% Theorem environments
\theoremstyle{definition}
\newmdtheoremenv[nobreak=true]{definition}{Definition}
\newmdtheoremenv[nobreak=true]{theorem}{Theorem}
\newmdtheoremenv[nobreak=true]{proposition}{Proposition}
\newmdtheoremenv[nobreak=true]{corollary}{Corollary}

% Other math environments
\newtheorem*{example}{Example}
\newtheorem*{remark}{Remark}
\newtheorem*{notation}{Notation}
\newtheorem*{observe}{Observation}
\newtheorem*{problem}{Problem}
\newtheorem*{intuition}{Intuition}

%----------------------------------------------------------------------------------------
%	EXERCISE ENVIRONMENT
%----------------------------------------------------------------------------------------
\newcounter{exercise}
\newcommand{\exercise}[1]{%
    \stepcounter{exercise}%
    \subsection*{Exercise \theexercise: #1}
}

\newcounter{subexercise}[exercise]
\newcommand{\subexercise}{%
    \stepcounter{subexercise}%
    \subsubsection*{Exercise \theexercise.\thesubexercise}
}

%----------------------------------------------------------------------------------------
%	LECTURE ENVIRONMENT
%----------------------------------------------------------------------------------------
\usepackage{xifthen}

\newcommand{\lecture}[3]{%
    \subsection*{Lecture #1: #3}
    \marginpar{\small\textsf{#2}}
}

%----------------------------------------------------------------------------------------
%	HEADER AND FOOTER
%----------------------------------------------------------------------------------------
\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyhead{}  % Clear all headers
\fancyfoot{}  % Clear all footers

\fancyhead[RO]{\rightmark}            % Right odd
\fancyhead[LE]{\leftmark}             % Left even
\fancyfoot[RO,LE]{\thepage}           % Page numbers

%----------------------------------------------------------------------------------------
%	BOXES AND NOTES
%----------------------------------------------------------------------------------------
\usepackage{tcolorbox}
\tcbuselibrary{breakable}

% Note box
\newenvironment{notebox}[1]{%
    \begin{tcolorbox}[
        breakable,
        arc=0mm,
        colback=white,
        colframe=black!40,
        title=#1,
        fonttitle=\sffamily
    ]
}{%
    \end{tcolorbox}
}

% Important box
\newenvironment{important}[1]{%
    \begin{tcolorbox}[
        breakable,
        arc=0mm,
        colback=white,
        colframe=red!60!black,
        title=#1,
        fonttitle=\sffamily
    ]
}{%
    \end{tcolorbox}
}

%----------------------------------------------------------------------------------------
%	CORRECTION COMMANDS
%----------------------------------------------------------------------------------------
\definecolor{correct}{HTML}{009900}
\newcommand{\correction}[2]{%
    \ensuremath{\:}{\color{red}{#1}}\ensuremath{\to}{\color{correct}{#2}}\ensuremath{\:}%
}
\newcommand{\green}[1]{{\color{correct}{#1}}}

%----------------------------------------------------------------------------------------
%	FIGURE SUPPORT
%----------------------------------------------------------------------------------------
\usepackage{import}
\usepackage{transparent}

\newcommand{\incfig}[1]{%
    \def\svgwidth{\columnwidth}
    \import{./figures/}{#1.pdf_tex}
}

%----------------------------------------------------------------------------------------
%	DOCUMENT INFORMATION
%----------------------------------------------------------------------------------------
\author{Alejandro Ezequiel Schwartzmann}

% Suppress PDf warning
\pdfsuppresswarningpagegroup=1

\begin{document}

\end{document}
endsnippet

context "math()"
snippet tt "test math only" A
MATH_ZONE_TEST
endsnippet

snippet use "usepackage" b
\usepackage{${1:package}}
endsnippet

snippet eqa "equation environment" b
\begin{equation}\label{$1}
	$2
\end{equation}
endsnippet


File: my_snippets/lua.snippets
---
Content:
snippet if "if statement" w
if ${1:condition} then
    ${2:-- body}
end
$0
endsnippet

snippet ife "if-else statement" w
if ${1:condition} then
    ${2:-- then body}
else
    ${3:-- else body}
end
$0
endsnippet

snippet ifei "if-elseif-else statement" w
if ${1:condition1} then
    ${2:-- body1}
elseif ${3:condition2} then
    ${4:-- body2}
else
    ${5:-- else body}
end
$0
endsnippet

snippet ei "elseif statement" w
elseif ${1:condition} then
    ${2:-- body}
endsnippet

snippet fn "Function" b
function ${1:FunctionName}(${2:params})
    ${3:-- body}
end
$0
endsnippet

snippet lfn "Local function" b
local function ${1:FunctionName}(${2:params})
    ${3:-- body}
end
$0
endsnippet

snippet req "Require a module" b
local ${1:module} = require("${2:$1}")$0
endsnippet

snippet for "For loop" w
for ${1:i} = ${2:1}, ${3:10} do
    ${4}
end
$0
endsnippet

snippet forp "For pairs (tables)" w
for k, v in pairs(${1:table}) do
    ${2}
end
$0
endsnippet

snippet fori "For ipairs (arrays)" w
for i, v in ipairs(${1:array}) do
    ${2}
end
$0
endsnippet


File: my_snippets/vim.snippets
---
Content:
snippet fun "vim function"
function! ${1:MyFunc}(${2}) abort
	$3
endfunction
$0
endsnippet

snippet aug "vim augroup" b
augroup ${1:GROUP_NAME}
	autocmd!
	autocmd ${2:EVENT} ${3:PATTERN} $4
augroup END
$0
endsnippet


File: lua/diagnostic-conf.lua
---
Content:
local diagnostic = vim.diagnostic
local api = vim.api

-- global config for diagnostic
diagnostic.config({
	underline = false,
	virtual_text = false,
	virtual_lines = false,
	signs = {
		text = {
			[diagnostic.severity.ERROR] = "",
			[diagnostic.severity.WARN] = "",
			[diagnostic.severity.INFO] = "",
			[diagnostic.severity.HINT] = "",
		},
	},
	severity_sort = true,
	float = {
		source = true,
		header = "Diagnostics:",
		prefix = " ",
		border = "single",
	},
})

-- set quickfix list from diagnostics in a certain buffer, not the whole workspace
local set_qflist = function(buf_num, severity)
	local diagnostics = nil
	diagnostics = diagnostic.get(buf_num, { severity = severity })

	local qf_items = diagnostic.toqflist(diagnostics)
	vim.fn.setqflist({}, " ", { title = "Diagnostics", items = qf_items })

	-- open quickfix by default
	vim.cmd([[copen]])
end

-- this puts diagnostics from opened files to quickfix
vim.keymap.set("n", "<space>qw", diagnostic.setqflist, { desc = "put window diagnostics to qf" })

-- this puts diagnostics from current buffer to quickfix
vim.keymap.set("n", "<space>qb", function()
	set_qflist(0)
end, { desc = "put buffer diagnostics to qf" })

-- automatically show diagnostic in float win for current line
api.nvim_create_autocmd("CursorHold", {
	pattern = "*",
	callback = function()
		if #vim.diagnostic.get(0) == 0 then
			return
		end

		if not vim.b.diagnostics_pos then
			vim.b.diagnostics_pos = { nil, nil }
		end

		local cursor_pos = api.nvim_win_get_cursor(0)

		if not vim.deep_equal(cursor_pos, vim.b.diagnostics_pos) then
			diagnostic.open_float({ width = 100 })
		end

		vim.b.diagnostics_pos = cursor_pos
	end,
})


File: lua/globals.lua
---
Content:
local fn = vim.fn
local api = vim.api
local utils = require("utils")

------------------------------------------------------------------------
--                          custom variables                          --
------------------------------------------------------------------------
vim.g.is_win = (utils.has("win32") or utils.has("win64")) and true or false
vim.g.is_linux = (utils.has("unix") and (not utils.has("macunix"))) and true or false
vim.g.is_mac = utils.has("macunix") and true or false

vim.g.logging_level = vim.log.levels.INFO
------------------------------------------------------------------------
--                         builtin variables                          --
------------------------------------------------------------------------
vim.g.loaded_perl_provider = 0 -- Disable perl provider
vim.g.loaded_ruby_provider = 0 -- Disable ruby provider
vim.g.loaded_node_provider = 0 -- Disable node provider
vim.g.did_install_default_menus = 1 -- do not load menu

if utils.executable("python3") then
	if vim.g.is_win then
		vim.g.python3_host_prog = fn.substitute(fn.exepath("python3"), ".exe$", "", "g")
	else
		vim.g.python3_host_prog = fn.exepath("python3")
	end
else
	local msg = "Python3 executable not found! You must install Python3 and set its PATH correctly!"
	api.nvim_echo({ { msg } }, true, { err = true })
	return
end

-- Custom mapping <leader> (see `:h mapleader` for more info)
vim.g.mapleader = ","

-- Enable highlighting for lua HERE doc inside vim script
vim.g.vimsyn_embed = "l"

-- Use English as main language
vim.cmd([[language en_US.UTF-8]])

-- Disable loading certain plugins

-- Whether to load netrw by default, see https://github.com/bling/dotvim/issues/4
vim.g.loaded_netrw = 1
vim.g.loaded_netrwPlugin = 1
vim.g.netrw_liststyle = 3
if vim.g.is_win then
	vim.g.netrw_http_cmd = "curl --ssl-no-revoke -Lo"
end

-- Do not load tohtml.vim
vim.g.loaded_2html_plugin = 1

-- Do not load zipPlugin.vim, gzip.vim and tarPlugin.vim (all these plugins are
-- related to checking files inside compressed files)
vim.g.loaded_zipPlugin = 1
vim.g.loaded_gzip = 1
vim.g.loaded_tarPlugin = 1

-- Do not load the tutor plugin
vim.g.loaded_tutor_mode_plugin = 1

-- Do not use builtin matchit.vim and matchparen.vim since we use vim-matchup
vim.g.loaded_matchit = 1
vim.g.loaded_matchparen = 1

-- Disable sql omni completion, it is broken.
vim.g.loaded_sql_completion = 1

-- control how to show health check window
vim.g.health = { style = nil }


File: lua/config/gitsigns.lua
---
Content:
local gs = require("gitsigns")

gs.setup({
	signs = {
		add = { text = "+" },
		change = { text = "~" },
		delete = { text = "_" },
		topdelete = { text = "" },
		changedelete = { text = "" },
	},
	word_diff = false,
	on_attach = function(bufnr)
		local function map(mode, l, r, opts)
			opts = opts or {}
			opts.buffer = bufnr
			vim.keymap.set(mode, l, r, opts)
		end

		-- Navigation
		map("n", "]c", function()
			if vim.wo.diff then
				return "]c"
			end
			vim.schedule(function()
				gs.next_hunk()
			end)
			return "<Ignore>"
		end, { expr = true, desc = "next hunk" })

		map("n", "[c", function()
			if vim.wo.diff then
				return "[c"
			end
			vim.schedule(function()
				gs.prev_hunk()
			end)
			return "<Ignore>"
		end, { expr = true, desc = "previous hunk" })

		-- Actions
		map("n", "<leader>hp", gs.preview_hunk, { desc = "preview hunk" })
		map("n", "<leader>hb", function()
			gs.blame_line({ full = true })
		end, { desc = "blame hunk" })
	end,
})

vim.api.nvim_create_autocmd("ColorScheme", {
	pattern = "*",
	callback = function()
		vim.cmd([[
      hi GitSignsChangeInline gui=reverse
      hi GitSignsAddInline gui=reverse
      hi GitSignsDeleteInline gui=reverse
    ]])
	end,
})


File: lua/config/git-linker.lua
---
Content:
local keymap = vim.keymap
local gitlinker = require("gitlinker")

gitlinker.setup({
	callbacks = {
		["dev.azure.com"] = function(url_data)
			vim.print(url_data)
			local url = require("gitlinker.hosts").get_base_https_url(url_data)

			if url_data.lstart then
				if url_data.lend == nil then
					url_data.lend = url_data.lstart
				end
				url = url
					.. "?path=/"
					.. url_data.file
					.. "&version=GC"
					.. url_data.rev
					.. "&line="
					.. url_data.lstart
					.. "&lineEnd="
					.. url_data.lend
					.. "&lineStartColumn=1"
					.. "&lineEndColumn=120"
			end
			return url
		end,
	},
	mappings = nil,
})

keymap.set({ "n", "v" }, "<leader>gl", function()
	local mode = string.lower(vim.fn.mode())
	gitlinker.get_buf_range_url(mode)
end, {
	silent = true,
	desc = "Git: get permlink",
})

keymap.set("n", "<leader>gbr", function()
	gitlinker.get_repo_url({
		action_callback = gitlinker.actions.open_in_browser,
	})
end, {
	silent = true,
	desc = "Git: browse repo in browser",
})


File: lua/config/nvim-statuscol.lua
---
Content:
local builtin = require("statuscol.builtin")
local ffi = require("statuscol.ffidef")
local C = ffi.C

-- only show fold level up to this level
local fold_level_limit = 3
local function foldfunc(args)
	local foldinfo = C.fold_info(args.wp, args.lnum)
	if foldinfo.level > fold_level_limit then
		return " "
	end

	return builtin.foldfunc(args)
end

require("statuscol").setup({
	relculright = false,
	segments = {
		{ text = { "%s" }, click = "v:lua.ScSa" },
		{ text = { builtin.lnumfunc, " " }, click = "v:lua.ScLa" },
		{ text = { foldfunc, " " }, condition = { true, builtin.not_empty }, click = "v:lua.ScFa" },
	},
})


File: lua/config/lsp.lua
---
Content:
local utils = require("utils")
local lsp_utils = require("lsp_utils")

vim.lsp.config("*", {
  capabilities = lsp_utils.get_default_capabilities(),
  flags = {
    debounce_text_changes = 500,
    allow_incremental_sync = true,
  },
  root_markers = { ".git" },
})

local enabled_lsp_servers = {
  bashls = "bash-language-server",
  clangd = "clangd",
  hls = "haskell-language-server-wrapper",
  ltex = "ltex-ls",
  lua_ls = "lua-language-server",
  pyright = "pyright-langserver",
  ruff = "ruff",
  rust_analyzer = "rust-analyzer",
  texlab = "texlab",
  vimls = "vim-language-server",
  yamlls = "yaml-language-server",
}

for server_name, lsp_executable in pairs(enabled_lsp_servers) do
  if utils.executable(lsp_executable) then
    vim.lsp.enable(server_name)
  else
    local msg = string.format(
      "Executable '%s' for server '%s' not found! Server will not be enabled",
      lsp_executable,
      server_name
    )
    vim.notify(msg, vim.log.levels.WARN, { title = "Nvim-config" })
  end
end

vim.api.nvim_create_autocmd("LspAttach", {
  group = vim.api.nvim_create_augroup("lsp_buf_conf", { clear = true }),
  callback = function(event_context)
    local client = vim.lsp.get_client_by_id(event_context.data.client_id)
    if not client then
      return
    end

    local bufnr = event_context.buf

    local map = function(mode, l, r, opts)
      opts = opts or {}
      opts.silent = true
      opts.buffer = bufnr
      vim.keymap.set(mode, l, r, opts)
    end

    map("n", "gd", function()
      vim.lsp.buf.definition {
        on_list = function(options)
          local unique_defs = {}
          local def_loc_hash = {}

          for _, def_location in pairs(options.items) do
            local hash_key = def_location.filename .. def_location.lnum
            if not def_loc_hash[hash_key] then
              def_loc_hash[hash_key] = true
              table.insert(unique_defs, def_location)
            end
          end

          options.items = unique_defs
          vim.fn.setloclist(0, {}, " ", options)

          if #options.items > 1 then
            vim.cmd.lopen()
          else
            vim.cmd([[silent! lfirst]])
          end
        end,
      }
    end, { desc = "LSP: Go to definition" })

    map("n", "<C-]>", vim.lsp.buf.definition, { desc = "LSP: Go to definition (quick)" })

    map("n", "K", function()
      vim.lsp.buf.hover {
        border = "single",
        max_height = 25,
        max_width = 120,
      }
    end, { desc = "LSP: Show hover information" })

    map("n", "<space>K", function()
      local params = vim.lsp.util.make_position_params()
      vim.lsp.buf_request(0, "textDocument/hover", params, function(err, result, ctx, config)
        if err or not result or not result.contents then
          vim.notify("No hover information available", vim.log.levels.INFO)
          return
        end

        local buf = vim.api.nvim_create_buf(false, true)
        local contents = vim.lsp.util.convert_input_to_markdown_lines(result.contents)

        vim.api.nvim_buf_set_lines(buf, 0, -1, false, contents)
        vim.api.nvim_buf_set_option(buf, "filetype", "markdown")
        vim.api.nvim_buf_set_option(buf, "modifiable", false)
        vim.api.nvim_buf_set_option(buf, "buftype", "nofile")

        vim.cmd("vsplit")
        vim.api.nvim_win_set_buf(0, buf)

        vim.api.nvim_win_set_option(0, "wrap", true)
        vim.api.nvim_win_set_option(0, "linebreak", true)

        vim.keymap.set("n", "q", "<cmd>close<cr>", { buffer = buf, silent = true })
      end)
    end, { desc = "LSP: Open hover in new buffer" })

    map("n", "<C-k>", vim.lsp.buf.signature_help, { desc = "LSP: Signature help" })
    map("n", "gD", vim.lsp.buf.declaration, { desc = "LSP: Go to declaration" })
    map("n", "gi", vim.lsp.buf.implementation, { desc = "LSP: Go to implementation" })
    map("n", "gt", vim.lsp.buf.type_definition, { desc = "LSP: Go to type definition" })
    map("n", "gr", vim.lsp.buf.references, { desc = "LSP: Show references" })

    map("n", "<space>rn", vim.lsp.buf.rename, { desc = "LSP: Rename symbol" })
    map({ "n", "v" }, "<space>ca", vim.lsp.buf.code_action, { desc = "LSP: Code actions" })

    map("n", "<space>wa", vim.lsp.buf.add_workspace_folder, { desc = "LSP: Add workspace folder" })
    map("n", "<space>wr", vim.lsp.buf.remove_workspace_folder, { desc = "LSP: Remove workspace folder" })
    map("n", "<space>wl", function()
      vim.print(vim.lsp.buf.list_workspace_folders())
    end, { desc = "LSP: List workspace folders" })

    map("n", "<space>ds", vim.lsp.buf.document_symbol, { desc = "LSP: Document symbols" })
    map("n", "<space>ws", vim.lsp.buf.workspace_symbol, { desc = "LSP: Workspace symbols" })

    if
      client.server_capabilities.documentFormattingProvider
      and client.name ~= "lua_ls"
      and client.name ~= "pyright"
      and client.name ~= "ruff"
      and client.name ~= "rust_analyzer"
    then
      map({ "n", "x" }, "<space>f", function()
        vim.lsp.buf.format {
          async = false,
          filter = function(c)
            return c.id == client.id
          end,
        }
      end, { desc = "LSP: Format code" })
    end

    if client.name == "ruff" then
      client.server_capabilities.hoverProvider = false
    end

    if client.server_capabilities.documentHighlightProvider then
      local gid = vim.api.nvim_create_augroup("lsp_document_highlight_" .. bufnr, { clear = true })
      vim.api.nvim_create_autocmd("CursorHold", {
        group = gid,
        buffer = bufnr,
        callback = function()
          vim.lsp.buf.document_highlight()
        end,
      })
      vim.api.nvim_create_autocmd("CursorMoved", {
        group = gid,
        buffer = bufnr,
        callback = function()
          vim.lsp.buf.clear_references()
        end,
      })
    end

    -- if client.server_capabilities.inlayHintProvider then
    --     vim.lsp.inlay_hint.enable(true, { bufnr = bufnr })
    -- end

    if client.server_capabilities.completionProvider then
      vim.lsp.completion.enable(true, client.id, bufnr, { autotrigger = false })
    end
  end,
  nested = true,
  desc = "Configure buffer keymap and behavior based on LSP",
})

vim.diagnostic.config {
  underline = false,
  virtual_text = false,
  virtual_lines = false,
  signs = {
    text = {
      [vim.diagnostic.severity.ERROR] = "",
      [vim.diagnostic.severity.WARN] = "",
      [vim.diagnostic.severity.INFO] = "",
      [vim.diagnostic.severity.HINT] = "",
    },
  },
  severity_sort = true,
  float = {
    source = true,
    header = "Diagnostics:",
    prefix = " ",
    border = "single",
    focusable = false,
  },
}

vim.api.nvim_create_autocmd("CursorHold", {
  pattern = "*",
  callback = function()
    if #vim.diagnostic.get(0) == 0 then
      return
    end

    if not vim.b.diagnostics_pos then
      vim.b.diagnostics_pos = { nil, nil }
    end

    local cursor_pos = vim.api.nvim_win_get_cursor(0)
    if cursor_pos[1] ~= vim.b.diagnostics_pos[1] or cursor_pos[2] ~= vim.b.diagnostics_pos[2] then
      vim.diagnostic.open_float()
    end

    vim.b.diagnostics_pos = cursor_pos
  end,
})

vim.keymap.set("n", "[d", vim.diagnostic.goto_prev, { desc = "Previous diagnostic" })
vim.keymap.set("n", "]d", vim.diagnostic.goto_next, { desc = "Next diagnostic" })
vim.keymap.set("n", "<space>dl", vim.diagnostic.setloclist, { desc = "Diagnostics to location list" })
vim.keymap.set("n", "<space>dq", vim.diagnostic.setqflist, { desc = "Diagnostics to quickfix" })


File: lua/config/ultisnips.lua
---
Content:
local M = {}

function M.setup()
	-- Set viewer method
	vim.g.vimtex_view_method = "zathura"
	-- Configure compiler method
	vim.g.vimtex_compiler_method = "latexmk"

	-- Compiler configuration
	vim.g.vimtex_compiler_latexmk = {
		build_dir = "",
		callback = 1,
		continuous = 1,
		executable = "latexmk",
		hooks = {},
		options = {
			"-verbose",
			"-file-line-error",
			"-synctex=1",
			"-interaction=nonstopmode",
		},
	}

	-- General settings
	vim.g.UltiSnipsExpandTrigger = "<tab>"
	vim.g.UltiSnipsJumpForwardTrigger = "<tab>"
	vim.g.UltiSnipsJumpBackwardTrigger = "<s-tab>"
	vim.g.vimtex_quickfix_mode = 0
	vim.g.vimtex_quickfix_enabled = 1
	vim.g.vimtex_syntax_enabled = 1
	vim.g.tex_flavor = "latex"
	vim.g.tex_conceal = "abdmg"
	vim.opt.conceallevel = 2

	-- Disable default mappings
	vim.g.vimtex_mappings_enabled = 1
	vim.g.vimtex_mappings_disable = { ["n"] = { "K" } }

	-- Enable imaps (inline math)
	vim.g.vimtex_imaps_enabled = 1

	-- PDF viewer settings for forward search
	vim.g.vimtex_view_general_viewer = "zathura"
	vim.g.vimtex_view_general_options = [[--unique file:@pdf\#src:@line@tex]]
end

return M


File: lua/config/glance.lua
---
Content:
local glance = require("glance")

glance.setup({
	height = 25,
	border = {
		enable = true,
	},
})

vim.keymap.set("n", "<space>gd", "<cmd>Glance definitions<cr>")
vim.keymap.set("n", "<space>gr", "<cmd>Glance references<cr>")
vim.keymap.set("n", "<space>gi", "<cmd>Glance implementations<cr>")


File: lua/config/vimtex.lua
---
Content:
local M = {}

local function setup_keymaps()
  local keymaps = {
    { "n", "<F9>", "<plug>(vimtex-compile)", { buffer = true } },
    { "n", "<leader>ll", "<cmd>VimtexCompile<CR>", { buffer = true } },
    -- Visualization
    { "n", "<leader>lv", "<cmd>VimtexView<CR>", { buffer = true } },
    { "n", "<leader>le", "<cmd>VimtexErrors<CR>", { buffer = true } },
    -- TOC
    { "n", "<leader>lt", "<cmd>VimtexTocToggle<CR>", { buffer = true } },
    -- Clean
    { "n", "<leader>lc", "<cmd>VimtexClean<CR>", { buffer = true } },
    -- Other
    { "n", "<leader>li", "<cmd>VimtexInfo<CR>", { buffer = true } },
    { "n", "<leader>lk", "<cmd>VimtexStop<CR>", { buffer = true } },
    { "n", "<leader>lK", "<cmd>VimtexStopAll<CR>", { buffer = true } },
    { "n", "<leader>lg", "<cmd>VimtexLog<CR>", { buffer = true } },
  }
  for _, map in ipairs(keymaps) do
    vim.keymap.set(unpack(map))
  end
end

local function setup_autocommands()
  vim.api.nvim_create_autocmd("FileType", {
    pattern = "tex",
    callback = function()
      vim.defer_fn(function()
        if vim.fn.exists("*vimtex#init") == 1 then
          vim.notify("VimTeX loaded successfully", vim.log.levels.INFO)
        else
          vim.notify("VimTeX not loaded!", vim.log.levels.ERROR)
        end
      end, 100)
    end,
  })
end

local function setup_ultisnips()
  vim.g.UltiSnipsExpandTrigger = "<tab>"
  vim.g.UltiSnipsEnableSnipMate = 0
  vim.g.UltiSnipsJumpForwardTrigger = "<tab>"
  vim.g.UltiSnipsJumpBackwardTrigger = "<s-tab>"
  vim.g.UltiSnipsSnippetDirectories = { "UltiSnips", "my_snippets" }
end

function M.setup()
  -- Basic config
  vim.g.tex_flavor = "latex"
  vim.g.vimtex_view_method = "zathura"
  vim.g.vimtex_view_general_options = "--unique file:@pdf\\#src:@line@tex"

  -- Concealment
  vim.g.tex_conceal = "abdmgs"
  vim.g.vimtex_syntax_conceal = {
    accents = 1,
    ligatures = 1,
    cites = 1,
    fancy = 1,
    spacing = 1,
    greek = 1,
    math_bounds = 1,
    math_delimiters = 1,
    math_fracs = 1,
    math_super_sub = 1,
    math_symbols = 1,
    sections = 0,
    styles = 1,
  }

  -- Compiler
  vim.g.vimtex_compiler_method = "latexmk"
  vim.g.vimtex_compiler_latexmk = {
    build_dir = "build",
    callback = 1,
    continuous = 1,
    executable = "latexmk",
    hooks = {},
    options = {
      "-verbose",
      "-file-line-error",
      "-synctex=1",
      "-interaction=nonstopmode",
      "-pdf",
    },
  }
  vim.g.vimtex_compiler_progname = "nvr"
  vim.g.vimtex_compiler_enabled = 1
  vim.g.vimtex_compiler_silent = 0

  -- Visualizacin
  vim.g.vimtex_view_enabled = 1
  vim.g.vimtex_log_verbose = 1

  -- TOC
  vim.g.vimtex_toc_config = {
    name = "TOC",
    layers = { "content", "todo", "include" },
    resize = 1,
    split_width = 30,
    todo_sorted = 0,
    show_help = 1,
    show_numbers = 1,
    mode = 2,
  }

  -- Other config
  vim.g.vimtex_compiler_latexmk.root_patterns = { ".latexmkrc", "main.tex", ".git", "." }
  vim.g.vimtex_quickfix_mode = 0
  vim.g.vimtex_quickfix_enabled = 1
  vim.g.vimtex_quickfix_ignore_filters = {
    "Underfull",
    "Overfull",
    "specifier changed to",
    "Package caption Warning",
    "Package typearea Warning",
  }

  -- Sintax
  vim.g.vimtex_syntax_enabled = 1
  vim.g.vimtex_fold_enabled = 0
  vim.g.vimtex_format_enabled = 1
  vim.g.vimtex_complete_enabled = 1
  vim.g.vimtex_enabled = 1
  vim.g.vimtex_mappings_disable = { ["n"] = { "K" } }
  vim.g.vimtex_importer_enabled = 1

  setup_ultisnips()
  setup_autocommands()
  setup_keymaps()
end

M.setup_keymaps = setup_keymaps
M.setup_ultisnips = setup_ultisnips

return M


File: lua/config/lualine.lua
---
Content:
local fn = vim.fn

local git_status_cache = {}

local on_exit_fetch = function(result)
	if result.code == 0 then
		git_status_cache.fetch_success = true
	end
end

local function handle_numeric_result(cache_key)
	return function(result)
		if result.code == 0 then
			git_status_cache[cache_key] = tonumber(result.stdout:match("(%d+)")) or 0
		end
	end
end

local async_cmd = function(cmd_str, on_exit)
	local cmd = vim.tbl_filter(function(element)
		return element ~= ""
	end, vim.split(cmd_str, " "))

	vim.system(cmd, { text = true }, on_exit)
end

local async_git_status_update = function()
	-- Fetch the latest changes from the remote repository (replace 'origin' if needed)
	async_cmd("git fetch origin", on_exit_fetch)
	if not git_status_cache.fetch_success then
		return
	end

	-- Get the number of commits behind
	-- the @{upstream} notation is inspired by post: https://www.reddit.com/r/neovim/comments/t48x5i/git_branch_aheadbehind_info_status_line_component/
	-- note that here we should use double dots instead of triple dots
	local behind_cmd_str = "git rev-list --count HEAD..@{upstream}"
	async_cmd(behind_cmd_str, handle_numeric_result("behind_count"))

	-- Get the number of commits ahead
	local ahead_cmd_str = "git rev-list --count @{upstream}..HEAD"
	async_cmd(ahead_cmd_str, handle_numeric_result("ahead_count"))
end

local function get_git_ahead_behind_info()
	async_git_status_update()

	local status = git_status_cache
	if not status then
		return ""
	end

	local msg = ""

	if type(status.ahead_count) == "number" and status.ahead_count > 0 then
		local ahead_str = string.format("[%d] ", status.ahead_count)
		msg = msg .. ahead_str
	end

	if type(status.behind_count) == "number" and status.behind_count > 0 then
		local behind_str = string.format("[%d] ", status.behind_count)
		msg = msg .. behind_str
	end

	return msg
end

local function spell()
	if vim.o.spell then
		return string.format("[SPELL]")
	end

	return ""
end

--- show indicator for Chinese IME
local function ime_state()
	if vim.g.is_mac then
		-- ref: https://github.com/vim-airline/vim-airline/blob/master/autoload/airline/extensions/xkblayout.vim#L11
		local layout = fn.libcall(vim.g.XkbSwitchLib, "Xkb_Switch_getXkbLayout", "")

		-- We can use `xkbswitch -g` on the command line to get current mode.
		-- mode for macOS builtin pinyin IME: com.apple.inputmethod.SCIM.ITABC
		-- mode for Rime: im.rime.inputmethod.Squirrel.Rime
		local res = fn.match(layout, [[\v(Squirrel\.Rime|SCIM.ITABC)]])
		if res ~= -1 then
			return "[CN]"
		end
	end

	return ""
end

local function trailing_space()
	if not vim.o.modifiable then
		return ""
	end

	local line_num = nil

	for i = 1, fn.line("$") do
		local linetext = fn.getline(i)
		-- To prevent invalid escape error, we wrap the regex string with `[[]]`.
		local idx = fn.match(linetext, [[\v\s+$]])

		if idx ~= -1 then
			line_num = i
			break
		end
	end

	local msg = ""
	if line_num ~= nil then
		msg = string.format("[%d]trailing", line_num)
	end

	return msg
end

local function mixed_indent()
	if not vim.o.modifiable then
		return ""
	end

	local space_pat = [[\v^ +]]
	local tab_pat = [[\v^\t+]]
	local space_indent = fn.search(space_pat, "nwc")
	local tab_indent = fn.search(tab_pat, "nwc")
	local mixed = (space_indent > 0 and tab_indent > 0)
	local mixed_same_line
	if not mixed then
		mixed_same_line = fn.search([[\v^(\t+ | +\t)]], "nwc")
		mixed = mixed_same_line > 0
	end
	if not mixed then
		return ""
	end
	if mixed_same_line ~= nil and mixed_same_line > 0 then
		return "MI:" .. mixed_same_line
	end
	local space_indent_cnt = fn.searchcount({ pattern = space_pat, max_count = 1e3 }).total
	local tab_indent_cnt = fn.searchcount({ pattern = tab_pat, max_count = 1e3 }).total
	if space_indent_cnt > tab_indent_cnt then
		return "MI:" .. tab_indent
	else
		return "MI:" .. space_indent
	end
end

local diff = function()
	local git_status = vim.b.gitsigns_status_dict
	if git_status == nil then
		return
	end

	local modify_num = git_status.changed
	local remove_num = git_status.removed
	local add_num = git_status.added

	local info = { added = add_num, modified = modify_num, removed = remove_num }
	-- vim.print(info)
	return info
end

local virtual_env = function()
	-- only show virtual env for Python
	if vim.bo.filetype ~= "python" then
		return ""
	end

	local conda_env = os.getenv("CONDA_DEFAULT_ENV")
	local venv_path = os.getenv("VIRTUAL_ENV")

	if venv_path == nil then
		if conda_env == nil then
			return ""
		else
			return string.format("  %s (conda)", conda_env)
		end
	else
		local venv_name = vim.fn.fnamemodify(venv_path, ":t")
		return string.format("  %s (venv)", venv_name)
	end
end

local get_active_lsp = function()
	local msg = ""
	local buf_ft = vim.api.nvim_get_option_value("filetype", {})
	local clients = vim.lsp.get_clients({ bufnr = 0 })
	if next(clients) == nil then
		return msg
	end

	for _, client in ipairs(clients) do
		---@diagnostic disable-next-line: undefined-field
		local filetypes = client.config.filetypes
		if filetypes and vim.fn.index(filetypes, buf_ft) ~= -1 then
			return client.name
		end
	end
	return msg
end

require("lualine").setup({
	options = {
		icons_enabled = true,
		theme = "auto",
		component_separators = { left = "", right = "" },
		section_separators = "",
		disabled_filetypes = {},
		always_divide_middle = true,
		refresh = {
			statusline = 500,
		},
	},
	sections = {
		lualine_a = {
			{
				"filename",
				symbols = {
					readonly = "[]",
				},
			},
		},
		lualine_b = {
			{
				"branch",
				fmt = function(name, _)
					-- truncate branch name in case the name is too long
					return string.sub(name, 1, 20)
				end,
				color = { gui = "italic,bold" },
			},
			{
				get_git_ahead_behind_info,
				color = { fg = "#E0C479" },
			},
			{
				"diff",
				source = diff,
			},
			{
				virtual_env,
				color = { fg = "black", bg = "#F1CA81" },
			},
		},
		lualine_c = {
			{
				"%S",
				color = { gui = "bold", fg = "cyan" },
			},
			{
				spell,
				color = { fg = "black", bg = "#a7c080" },
			},
		},
		lualine_x = {
			{
				get_active_lsp,
				icon = "",
			},
			{
				"diagnostics",
				sources = { "nvim_diagnostic" },
				symbols = { error = " ", warn = " ", info = " ", hint = " " },
			},
			{
				trailing_space,
				color = "WarningMsg",
			},
			{
				mixed_indent,
				color = "WarningMsg",
			},
		},
		lualine_y = {
			{
				"encoding",
				fmt = string.upper,
			},
			{
				"fileformat",
				symbols = {
					unix = "unix",
					dos = "win",
					mac = "mac",
				},
			},
			"filetype",
			{
				ime_state,
				color = { fg = "black", bg = "#f46868" },
			},
		},
		lualine_z = {
			"location",
			"progress",
		},
	},
	inactive_sections = {
		lualine_a = {},
		lualine_b = {},
		lualine_c = { "filename" },
		lualine_x = { "location" },
		lualine_y = {},
		lualine_z = {},
	},
	tabline = {},
	extensions = { "quickfix", "fugitive", "nvim-tree" },
})


File: lua/config/iron.lua
---
Content:
local iron = require("iron")
iron.core.set_config({
	preferred = {
		python = "ipython",
	},
	repl_open_cmd = "vertical 120 split",
})


File: lua/config/obsidian-nvim.lua
---
Content:
local opts = {
  dir = "~/wiki",

  new_notes_location = "current_dir",

  note_id_func = function(title)
    if title and title ~= "" then
      return title:gsub("%s+", "-"):gsub("[^A-Za-z0-9-]", ""):lower()
    else
      return os.date("%Y%m%d%H%M%S")
    end
  end,

  daily_notes = {
    folder = "journal",
    date_format = "%Y-%m-%d",
    template = "daily.md",
  },

  completion = {
    nvim_cmp = true,
    min_chars = 2,
  },

  ui = {
    enable = true,
  },
}

require("obsidian").setup(opts)

vim.api.nvim_create_autocmd("FileType", {
  pattern = "markdown",
  callback = function()
    vim.opt.conceallevel = 2
  end,
  desc = "Set conceal level for markdown files",
})

local function CreateParaNote(para_type)
  local vault_path = vim.fn.expand(opts.dir)

  local title = vim.fn.input(para_type .. " Title: ")
  if title == "" or title == nil then
    vim.notify("Creacin de nota cancelada.", vim.log.levels.WARN)
    return
  end

  local additional_tags = vim.fn.input("Tags adicionales (ej: Programming:JavaScript): ")

  local tags = ":" .. para_type .. ":"
  if additional_tags ~= "" then
    tags = tags .. additional_tags .. ":"
  end

  local filename = title:gsub("%s+", "-"):gsub("[^A-Za-z0-9-]", ""):lower()
  local full_path = vault_path .. "/" .. filename .. ".md"

  if vim.fn.filereadable(full_path) == 1 then
    vim.notify("Error: Ya existe una nota con este nombre.", vim.log.levels.ERROR)
    return
  end

  local today = os.date("%Y-%m-%d")
  local lines = {
    "---",
    "title: " .. title,
    "date: " .. today,
    "---",
    "",
    tags,
    "",
    "# " .. title,
    "",
  }

  if vim.fn.writefile(lines, full_path) == 0 then
    vim.cmd("edit " .. vim.fn.fnameescape(full_path))
    vim.cmd("normal! G")
    vim.notify(para_type .. " nota creada con tags: " .. tags, vim.log.levels.INFO)
  else
    vim.notify("Error: Fallo al crear el archivo de la nota.", vim.log.levels.ERROR)
  end
end

local function import_yesterday_completed_tasks()
  vim.defer_fn(function()
    local line_count = vim.fn.line("$")
    if line_count > 11 then
      return
    end

    local journal_root = vim.fn.expand(opts.dir .. "/" .. opts.daily_notes.folder)
    local yesterday_time = os.time() - 86400
    local yesterday_date = os.date(opts.daily_notes.date_format, yesterday_time)
    local yesterday_file = journal_root .. "/" .. yesterday_date .. ".md"

    if vim.fn.filereadable(yesterday_file) == 0 then
      return
    end
    local yesterday_content = vim.fn.readfile(yesterday_file)
    local completed_tasks = {}
    local in_done_section = false
    for _, line in ipairs(yesterday_content) do
      if line:match("^## Done") then
        in_done_section = true
      elseif in_done_section and line:match("^##") then
        break
      elseif in_done_section and line:match("^%- %[x%]") then
        table.insert(completed_tasks, line)
      end
    end
    if #completed_tasks == 0 then
      return
    end
    local current_buf_lines = vim.api.nvim_buf_get_lines(0, 0, -1, false)
    local done_section_line_num = -1
    for i, line in ipairs(current_buf_lines) do
      if line:match("^## Done") then
        done_section_line_num = i
        break
      end
    end
    if done_section_line_num ~= -1 then
      table.insert(completed_tasks, 1, "### From " .. yesterday_date)
      table.insert(completed_tasks, 1, "")
      vim.api.nvim_buf_set_lines(0, done_section_line_num, done_section_line_num, false, completed_tasks)
    end
  end, 150)
end

local function CreateMarkdownLink()
  local display_text = vim.fn.input("Title of the link: ")
  if display_text == "" or display_text == nil then
    vim.notify("Creation canceled", vim.log.levels.WARN)
    return
  end

  local link_target = vim.fn.input("Target (URL or Archivo): ")
  if link_target == "" or link_target == nil then
    vim.notify("Creation canceled.", vim.log.levels.WARN)
    return
  end

  -- Construye el string del enlace en formato Markdown.
  local markdown_link = string.format("[%s](%s)", display_text, link_target)

  -- Inserta el enlace en la posicin actual del cursor.
  vim.api.nvim_put({ markdown_link }, "c", false, true)
end

vim.api.nvim_create_user_command("ObsidianSmartToday", function()
  vim.cmd("ObsidianToday")
  import_yesterday_completed_tasks()
end, {})

local map = vim.keymap.set
local leader = "<leader>"

map("n", leader .. "np", function()
  CreateParaNote("Project")
end, { desc = "Obsidian: Nueva Nota de Proyecto" })
map("n", leader .. "na", function()
  CreateParaNote("Area")
end, { desc = "Obsidian: Nueva Nota de rea" })
map("n", leader .. "nr", function()
  CreateParaNote("Resource")
end, { desc = "Obsidian: Nueva Nota de Recurso" })
map("n", leader .. "nc", function()
  CreateParaNote("Archive")
end, { desc = "Obsidian: Nueva Nota de Archivo" })

map("n", leader .. "nL", CreateMarkdownLink, { desc = "Obsidian: Nuevo Enlace Genrico (URL/Archivo)" })
map("n", leader .. "nj", "<cmd>ObsidianSmartToday<cr>", { desc = "Obsidian: Abrir Nota de Hoy (Inteligente)" })
map("v", leader .. "nl", "<cmd>ObsidianLinkNew<cr>", { desc = "Obsidian: Nuevo Enlace a Nota" })
map("n", leader .. "x", "<cmd>ObsidianToggleCheckbox<cr>", { desc = "Obsidian: Alternar Checkbox" })
map("n", leader .. "wo", "<cmd>ObsidianOpen<cr>", { desc = "Obsidian: Abrir Bveda en Explorador de Archivos" })
map("n", leader .. "wf", "<cmd>ObsidianSearch<cr>", { desc = "Obsidian: Buscar Notas" })
map("n", leader .. "wb", "<cmd>ObsidianBacklinks<cr>", { desc = "Obsidian: Mostrar Backlinks" })
map("n", leader .. "nte", "<cmd>ObsidianTemplate<cr>", { desc = "Obsidian: Insertar Plantilla" })
map("n", leader .. "gl", "<cmd>ObsidianFollowLink<cr>", { desc = "Obsidian: Seguir enlace bajo el cursor" })


File: lua/config/nvim-notify.lua
---
Content:
local nvim_notify = require("notify")
nvim_notify.setup({
	-- Animation style
	stages = "fade_in_slide_out",
	-- Default timeout for notifications
	timeout = 1500,
	background_colour = "#2E3440",
})

vim.notify = nvim_notify


File: lua/config/nvim-surround.lua
---
Content:
local M = {}

---@type user_options
M.default_opts = {
	keymaps = {
		insert = "<C-g>s",
		insert_line = "<C-g>S",
		normal = "ys",
		normal_cur = "yss",
		normal_line = "yS",
		normal_cur_line = "ySS",
		visual = "S",
		visual_line = "gS",
		delete = "ds",
		change = "cs",
		change_line = "cS",
	},
	surrounds = {
		["("] = {
			add = { "( ", " )" },
			find = function()
				return M.get_selection({ motion = "a(" })
			end,
			delete = "^(. ?)().-( ?.)()$",
		},
		[")"] = {
			add = { "(", ")" },
			find = function()
				return M.get_selection({ motion = "a)" })
			end,
			delete = "^(.)().-(.)()$",
		},
		["{"] = {
			add = { "{ ", " }" },
			find = function()
				return M.get_selection({ motion = "a{" })
			end,
			delete = "^(. ?)().-( ?.)()$",
		},
		["}"] = {
			add = { "{", "}" },
			find = function()
				return M.get_selection({ motion = "a}" })
			end,
			delete = "^(.)().-(.)()$",
		},
		["<"] = {
			add = { "< ", " >" },
			find = function()
				return M.get_selection({ motion = "a<" })
			end,
			delete = "^(. ?)().-( ?.)()$",
		},
		[">"] = {
			add = { "<", ">" },
			find = function()
				return M.get_selection({ motion = "a>" })
			end,
			delete = "^(.)().-(.)()$",
		},
		["["] = {
			add = { "[ ", " ]" },
			find = function()
				return M.get_selection({ motion = "a[" })
			end,
			delete = "^(. ?)().-( ?.)()$",
		},
		["]"] = {
			add = { "[", "]" },
			find = function()
				return M.get_selection({ motion = "a]" })
			end,
			delete = "^(.)().-(.)()$",
		},
		["'"] = {
			add = { "'", "'" },
			find = function()
				return M.get_selection({ motion = "a'" })
			end,
			delete = "^(.)().-(.)()$",
		},
		['"'] = {
			add = { '"', '"' },
			find = function()
				return M.get_selection({ motion = 'a"' })
			end,
			delete = "^(.)().-(.)()$",
		},
		["`"] = {
			add = { "`", "`" },
			find = function()
				return M.get_selection({ motion = "a`" })
			end,
			delete = "^(.)().-(.)()$",
		},
		["i"] = { -- TODO: Add find/delete/change functions
			add = function()
				local left_delimiter = M.get_input("Enter the left delimiter: ")
				local right_delimiter = left_delimiter and M.get_input("Enter the right delimiter: ")
				if right_delimiter then
					return { { left_delimiter }, { right_delimiter } }
				end
			end,
			find = function() end,
			delete = function() end,
		},
		["t"] = {
			add = function()
				local user_input = M.get_input("Enter the HTML tag: ")
				if user_input then
					local element = user_input:match("^<?([^%s>]*)")
					local attributes = user_input:match("^<?[^%s>]*%s+(.-)>?$")

					local open = attributes and element .. " " .. attributes or element
					local close = element

					return { { "<" .. open .. ">" }, { "</" .. close .. ">" } }
				end
			end,
			find = function()
				return M.get_selection({ motion = "at" })
			end,
			delete = "^(%b<>)().-(%b<>)()$",
			change = {
				target = "^<([^%s<>]*)().-([^/]*)()>$",
				replacement = function()
					local user_input = M.get_input("Enter the HTML tag: ")
					if user_input then
						local element = user_input:match("^<?([^%s>]*)")
						local attributes = user_input:match("^<?[^%s>]*%s+(.-)>?$")

						local open = attributes and element .. " " .. attributes or element
						local close = element

						return { { open }, { close } }
					end
				end,
			},
		},
		["T"] = {
			add = function()
				local user_input = M.get_input("Enter the HTML tag: ")
				if user_input then
					local element = user_input:match("^<?([^%s>]*)")
					local attributes = user_input:match("^<?[^%s>]*%s+(.-)>?$")

					local open = attributes and element .. " " .. attributes or element
					local close = element

					return { { "<" .. open .. ">" }, { "</" .. close .. ">" } }
				end
			end,
			find = function()
				return M.get_selection({ motion = "at" })
			end,
			delete = "^(%b<>)().-(%b<>)()$",
			change = {
				target = "^<([^>]*)().-([^/]*)()>$",
				replacement = function()
					local user_input = M.get_input("Enter the HTML tag: ")
					if user_input then
						local element = user_input:match("^<?([^%s>]*)")
						local attributes = user_input:match("^<?[^%s>]*%s+(.-)>?$")

						local open = attributes and element .. " " .. attributes or element
						local close = element

						return { { open }, { close } }
					end
				end,
			},
		},
		["f"] = {
			add = function()
				local result = M.get_input("Enter the function name: ")
				if result then
					return { { result .. "(" }, { ")" } }
				end
			end,
			find = function()
				if vim.g.loaded_nvim_treesitter then
					local selection = M.get_selection({
						query = {
							capture = "@call.outer",
							type = "textobjects",
						},
					})
					if selection then
						return selection
					end
				end
				return M.get_selection({ pattern = "[^=%s%(%){}]+%b()" })
			end,
			delete = "^(.-%()().-(%))()$",
			change = {
				target = "^.-([%w_]+)()%(.-%)()()$",
				replacement = function()
					local result = M.get_input("Enter the function name: ")
					if result then
						return { { result }, { "" } }
					end
				end,
			},
		},
		invalid_key_behavior = {
			-- By default, we ignore control characters for adding/finding because they are more likely typos than
			-- intentional. We choose NOT to for deletion, as users could have redefined the find key to something like
			-- .-. In this case we should still trim a character from each side, instead of early returning nil.
			add = function(char)
				if not char or char:find("%c") then
					return nil
				end
				return { { char }, { char } }
			end,
			find = function(char)
				if not char or char:find("%c") then
					return nil
				end
				return M.get_selection({
					pattern = vim.pesc(char) .. ".-" .. vim.pesc(char),
				})
			end,
			delete = function(char)
				if not char then
					return nil
				end
				return M.get_selections({
					char = char,
					pattern = "^(.)().-(.)()$",
				})
			end,
		},
	},
	aliases = {
		["a"] = ">",
		["b"] = ")",
		["B"] = "}",
		["r"] = "]",
		["q"] = { '"', "'", "`" },
		["s"] = { "}", "]", ")", ">", '"', "'", "`" },
	},
	highlight = {
		duration = 0,
	},
	move_cursor = "begin",
	indent_lines = function(start, stop)
		local b = vim.bo
		-- Only re-indent the selection if a formatter is set up already
		if start < stop and (b.equalprg ~= "" or b.indentexpr ~= "" or b.cindent or b.smartindent or b.lisp) then
			vim.cmd(string.format("silent normal! %dG=%dG", start, stop))
			require("nvim-surround.cache").set_callback("")
		end
	end,
}

--[====================================================================================================================[
                                             Configuration Helper Functions
--]====================================================================================================================]

-- Gets input from the user.
---@param prompt string The input prompt.
---@return string|nil @The user input.
---@nodiscard
M.get_input = function(prompt)
	local input = require("nvim-surround.input")
	return input.get_input(prompt)
end

-- Gets a selection from the buffer based on some heuristic.
---@param args { char: string|nil, motion: string|nil, pattern: string|nil, node: string|nil, query: { capture: string, type: string }|nil }
---@return selection|nil @The retrieved selection.
---@nodiscard
M.get_selection = function(args)
	if args.char then
		return M.get_find(args.char)(args.char)
	elseif args.motion then
		return require("nvim-surround.motions").get_selection(args.motion)
	elseif args.node then
		return require("nvim-surround.treesitter").get_selection(args.node)
	elseif args.pattern then
		return require("nvim-surround.patterns").get_selection(args.pattern)
	elseif args.query then
		return require("nvim-surround.queries").get_selection(args.query.capture, args.query.type)
	else
		vim.notify("Invalid key provided for `:h nvim-surround.config.get_selection()`.", vim.log.levels.ERROR)
	end
end

-- Gets a pair of selections from the buffer based on some heuristic.
---@param args { char: string, pattern: string|nil, exclude: function|nil }
---@nodiscard
M.get_selections = function(args)
	local selection = M.get_selection({ char = args.char })
	if not selection then
		return nil
	end
	if args.pattern then
		return require("nvim-surround.patterns").get_selections(selection, args.pattern)
	elseif args.exclude then
		local outer_selection = M.get_opts().surrounds[args.char].find()
		if not outer_selection then
			return nil
		end
		vim.fn.cursor(outer_selection.first_pos)
		local inner_selection = args.exclude()
		if not inner_selection then
			return nil
		end
		-- Properly exclude the inner selection from the outer selection
		local selections = {
			left = {
				first_pos = outer_selection.first_pos,
				last_pos = { inner_selection.first_pos[1], inner_selection.first_pos[2] - 1 },
			},
			right = {
				first_pos = { inner_selection.last_pos[1], inner_selection.last_pos[2] + 1 },
				last_pos = outer_selection.last_pos,
			},
		}
		return selections
	else
		vim.notify("Invalid key provided for `:h nvim-surround.config.get_selections()`.", vim.log.levels.ERROR)
	end
end

--[====================================================================================================================[
                                                End of Helper Functions
--]====================================================================================================================]

-- Stores the global user-set options for the plugin.
M.user_opts = nil

-- Returns the buffer-local options for the plugin, or global options if buffer-local does not exist.
---@return options @The buffer-local options.
---@nodiscard
M.get_opts = function()
	return vim.b[0].nvim_surround_buffer_opts or M.user_opts or {}
end

-- Returns the value that the input is aliased to, or the character if no alias exists.
---@param char string|nil The input character.
---@return string|nil @The aliased character if it exists, or the original if none exists.
---@nodiscard
M.get_alias = function(char)
	local aliases = M.get_opts().aliases
	if type(aliases[char]) == "string" then
		return aliases[char]
	end
	return char
end

-- Gets a delimiter pair for a user-inputted character.
---@param char string|nil The user-given character.
---@param line_mode boolean Whether or not the delimiters should be put on new lines.
---@return delimiter_pair|nil @A pair of delimiters for the given input, or nil if not applicable.
---@nodiscard
M.get_delimiters = function(char, line_mode)
	char = M.get_alias(char)
	-- Get the delimiters, using invalid_key_behavior if the add function is undefined for the character
	local delimiters = M.get_add(char)(char)
	if delimiters == nil then
		return nil
	end
	local lhs = type(delimiters[1]) == "string" and { delimiters[1] } or delimiters[1]
	local rhs = type(delimiters[2]) == "string" and { delimiters[2] } or delimiters[2]
	-- These casts are needed because LuaLS doesn't narrow types in ternaries properly
	-- https://github.com/LuaLS/lua-language-server/issues/2233
	---@cast lhs string[]
	---@cast rhs string[]

	-- Add new lines if the addition is done line-wise
	if line_mode then
		-- Trim whitespace after the leading delimiter and before the trailing delimiter
		lhs[#lhs] = lhs[#lhs]:gsub("%s+$", "")
		rhs[1] = rhs[1]:gsub("^%s+", "")

		table.insert(rhs, 1, "")
		table.insert(lhs, "")
	end

	return { lhs, rhs }
end

-- Returns the add key for the surround associated with a given character, if one exists.
---@param char string|nil The input character.
---@return add_func @The function to get the delimiters to be added.
---@nodiscard
M.get_add = function(char)
	char = M.get_alias(char)
	if M.get_opts().surrounds[char] and M.get_opts().surrounds[char].add then
		return M.get_opts().surrounds[char].add
	end
	return M.get_opts().surrounds.invalid_key_behavior.add
end

-- Returns the find key for the surround associated with a given character, if one exists.
---@param char string|nil The input character.
---@return find_func @The function to get the selection.
---@nodiscard
M.get_find = function(char)
	char = M.get_alias(char)
	if M.get_opts().surrounds[char] and M.get_opts().surrounds[char].find then
		return M.get_opts().surrounds[char].find
	end
	return M.get_opts().surrounds.invalid_key_behavior.find
end

-- Returns the delete key for the surround associated with a given character, if one exists.
---@param char string|nil The input character.
---@return delete_func @The function to get the selections to be deleted.
---@nodiscard
M.get_delete = function(char)
	char = M.get_alias(char)
	if M.get_opts().surrounds[char] and M.get_opts().surrounds[char].delete then
		return M.get_opts().surrounds[char].delete
	end
	return M.get_opts().surrounds.invalid_key_behavior.delete
end

-- Returns the change key for the surround associated with a given character, if one exists.
---@param char string|nil The input character.
---@return change_table @A table holding the target/replacement functions.
---@nodiscard
M.get_change = function(char)
	char = M.get_alias(char)
	if M.get_opts().surrounds[char] then
		if M.get_opts().surrounds[char].change then
			return M.get_opts().surrounds[char].change
		else
			return {
				target = M.get_delete(char),
			}
		end
	end
	return M.get_change("invalid_key_behavior")
end

-- Translates the user-provided surround.add into the internal form.
---@param user_add user_add The user-provided add key.
---@return false|add_func|nil @The translated add key.
M.translate_add = function(user_add)
	if type(user_add) ~= "table" then
		return user_add
	end

	return function()
		return user_add
	end
end

-- Translates the user-provided surround.find into the internal form.
---@param user_find user_find The user-provided find key.
---@return false|find_func|nil @The translated find key.
M.translate_find = function(user_find)
	if type(user_find) ~= "string" then
		return user_find
	end
	-- Treat the string as a Lua pattern, and find the selection
	return function()
		return M.get_selection({ pattern = user_find })
	end
end

-- Translates the user-provided surround.delete into the internal form.
---@param char string The character used to activate the surround.
---@param user_delete user_delete The user-provided delete key.
---@return false|delete_func|nil @The translated delete key.
M.translate_delete = function(char, user_delete)
	if type(user_delete) ~= "string" then
		return user_delete
	end
	-- Treat the string as a Lua pattern, and find the selection
	return function()
		return M.get_selections({ char = char, pattern = user_delete })
	end
end

-- Translates the user-provided surround.change into the internal form.
---@param char string The character used to activate the surround.
---@param user_change user_change|nil The user-provided change key.
---@return false|change_table|nil @The translated change key.
M.translate_change = function(char, user_change)
	if type(user_change) ~= "table" then
		return user_change
	end
	return {
		target = M.translate_delete(char, user_change.target),
		replacement = M.translate_add(user_change.replacement),
	}
end

-- Translates the user-provided surround into the internal form.
---@param char string The character used to activate the surround.
---@param user_surround false|user_surround The user-provided surround.
---@return false|surround @The translated surround.
M.translate_surround = function(char, user_surround)
	if not user_surround then
		return false
	end
	return {
		add = M.translate_add(user_surround.add),
		find = M.translate_find(user_surround.find),
		delete = M.translate_delete(char, user_surround.delete),
		change = M.translate_change(char, user_surround.change),
	}
end

-- Translates `invalid_key_behavior` into the internal form.
---@param invalid_surround false|user_surround The user-provided `invalid_key_behavior`.
---@return surround @The translated `invalid_key_behavior`.
M.translate_invalid_key_behavior = function(invalid_surround)
	local noop_surround = {
		add = function() end,
		find = function() end,
		delete = function() end,
		change = {
			target = function() end,
		},
	}
	local invalid = M.translate_surround("invalid_key_behavior", invalid_surround)
	if invalid == false then
		return noop_surround
	end
	if invalid.add == false then
		invalid.add = noop_surround.add
	end
	if invalid.find == false then
		invalid.find = noop_surround.find
	end
	if invalid.delete == false then
		invalid.delete = noop_surround.delete
	end
	if invalid.change == false then
		invalid.change = noop_surround.change
	elseif invalid.change ~= nil then
		if invalid.change.target == false then
			invalid.change.target = noop_surround.change.target
		end
	end
	return invalid
end

-- Translates `alias` into the internal form.
---@param user_alias false|string|string[] The user-provided `alias`.
---@return string|string[]|nil @The translated `alias`.
M.translate_alias = function(user_alias)
	if not user_alias then
		return nil
	end
	return user_alias
end

-- Translates the user-provided configuration into the internal form.
---@param user_opts user_options The user-provided options.
---@return options @The translated options.
M.translate_opts = function(user_opts)
	local input = require("nvim-surround.input")
	local opts = {}
	for key, value in pairs(user_opts) do
		if key == "surrounds" or key == "aliases" then
		elseif key == "indent_lines" then
			opts[key] = value or function() end
		else
			opts[key] = value
		end
	end
	if user_opts.surrounds then
		opts.surrounds = {}
		for char, user_surround in pairs(user_opts.surrounds) do
			char = input.replace_termcodes(char)
			-- Special case translation for `invalid_key_behavior`
			if type(user_surround) ~= "nil" then
				if char == "invalid_key_behavior" then
					opts.surrounds[char] = M.translate_invalid_key_behavior(user_surround)
				else
					opts.surrounds[char] = M.translate_surround(char, user_surround)
				end
			end
		end
	end
	if user_opts.aliases then
		opts.aliases = {}
		for char, user_alias in pairs(user_opts.aliases) do
			char = input.replace_termcodes(char)
			opts.aliases[char] = M.translate_alias(user_alias)
		end
	end
	return opts
end

-- Updates the buffer-local options for the plugin based on the input.
---@param base_opts options The base options that will be used for configuration.
---@param new_opts user_options|nil The new options to potentially override the base options.
---@return options The merged options.
M.merge_opts = function(base_opts, new_opts)
	new_opts = new_opts or {}
	local opts = vim.tbl_deep_extend("force", base_opts, M.translate_opts(new_opts))
	return opts
end

-- Check if a keymap should be added before setting it.
---@param args table The arguments to set the keymap.
M.set_keymap = function(args)
	-- If the keymap is disabled
	if not args.lhs then
		-- If the mapping is disabled globally, do nothing
		if not M.user_opts.keymaps[args.name] then
			return
		end
		-- Otherwise disable the global keymap
		args.lhs = M.user_opts.keymaps[args.name]
		args.rhs = "<NOP>"
	end
	vim.keymap.set(args.mode, args.lhs, args.rhs, args.opts)
end

-- Set up user-configured keymaps, globally or for the buffer.
---@param args { buffer: boolean } Whether the keymaps should be set for the buffer or not.
M.set_keymaps = function(args)
	-- Set up <Plug> keymaps
	M.set_keymap({
		mode = "i",
		lhs = "<Plug>(nvim-surround-insert)",
		rhs = function()
			require("nvim-surround").insert_surround({ line_mode = false })
		end,
		opts = {
			buffer = args.buffer,
			desc = "Add a surrounding pair around the cursor (insert mode)",
			silent = true,
		},
	})
	M.set_keymap({
		mode = "i",
		lhs = "<Plug>(nvim-surround-insert-line)",
		rhs = function()
			require("nvim-surround").insert_surround({ line_mode = true })
		end,
		opts = {
			buffer = args.buffer,
			desc = "Add a surrounding pair around the cursor, on new lines (insert mode)",
			silent = true,
		},
	})
	M.set_keymap({
		mode = "n",
		lhs = "<Plug>(nvim-surround-normal)",
		rhs = function()
			return require("nvim-surround").normal_surround({ line_mode = false })
		end,
		opts = {
			buffer = args.buffer,
			desc = "Add a surrounding pair around a motion (normal mode)",
			expr = true,
			silent = true,
		},
	})
	M.set_keymap({
		mode = "n",
		lhs = "<Plug>(nvim-surround-normal-cur)",
		rhs = function()
			return "<Plug>(nvim-surround-normal)Vg_"
		end,
		opts = {
			buffer = args.buffer,
			desc = "Add a surrounding pair around the current line (normal mode)",
			expr = true,
			silent = true,
		},
	})
	M.set_keymap({
		mode = "n",
		lhs = "<Plug>(nvim-surround-normal-line)",
		rhs = function()
			return require("nvim-surround").normal_surround({ line_mode = true })
		end,
		opts = {
			buffer = args.buffer,
			desc = "Add a surrounding pair around a motion, on new lines (normal mode)",
			expr = true,
			silent = true,
		},
	})
	M.set_keymap({
		mode = "n",
		lhs = "<Plug>(nvim-surround-normal-cur-line)",
		rhs = function()
			return "^" .. tostring(vim.v.count1) .. "<Plug>(nvim-surround-normal-line)g_"
		end,
		opts = {
			buffer = args.buffer,
			desc = "Add a surrounding pair around the current line, on new lines (normal mode)",
			expr = true,
			silent = true,
		},
	})
	M.set_keymap({
		mode = "x",
		lhs = "<Plug>(nvim-surround-visual)",
		rhs = function()
			local curpos = require("nvim-surround.buffer").get_curpos()
			return string.format(
				":lua require'nvim-surround'.visual_surround({ line_mode = false, curpos = { %d, %d }, curswant = %d })<CR>",
				curpos[1],
				curpos[2],
				vim.fn.winsaveview().curswant
			)
		end,
		opts = {
			buffer = args.buffer,
			desc = "Add a surrounding pair around a visual selection",
			silent = true,
			expr = true,
		},
	})
	M.set_keymap({
		mode = "x",
		lhs = "<Plug>(nvim-surround-visual-line)",
		rhs = function()
			local curpos = require("nvim-surround.buffer").get_curpos()
			return string.format(
				":lua require'nvim-surround'.visual_surround({ line_mode = true, curpos = { %d, %d }, curswant = 0 })<CR>",
				curpos[1],
				curpos[2]
			)
		end,
		opts = {
			buffer = args.buffer,
			desc = "Add a surrounding pair around a visual selection, on new lines",
			silent = true,
			expr = true,
		},
	})
	M.set_keymap({
		mode = "n",
		lhs = "<Plug>(nvim-surround-delete)",
		rhs = require("nvim-surround").delete_surround,
		opts = {
			buffer = args.buffer,
			desc = "Delete a surrounding pair",
			expr = true,
			silent = true,
		},
	})
	M.set_keymap({
		mode = "n",
		lhs = "<Plug>(nvim-surround-change)",
		rhs = function()
			return require("nvim-surround").change_surround({ line_mode = false })
		end,
		opts = {
			buffer = args.buffer,
			desc = "Change a surrounding pair",
			expr = true,
			silent = true,
		},
	})
	M.set_keymap({
		mode = "n",
		lhs = "<Plug>(nvim-surround-change-line)",
		rhs = function()
			return require("nvim-surround").change_surround({ line_mode = true })
		end,
		opts = {
			buffer = args.buffer,
			desc = "Change a surrounding pair, putting replacements on new lines",
			expr = true,
			silent = true,
		},
	})

	-- Set up user-defined keymaps
	M.set_keymap({
		name = "insert",
		mode = "i",
		lhs = M.get_opts().keymaps.insert,
		rhs = "<Plug>(nvim-surround-insert)",
		opts = {
			desc = "Add a surrounding pair around the cursor (insert mode)",
		},
	})
	M.set_keymap({
		name = "insert_line",
		mode = "i",
		lhs = M.get_opts().keymaps.insert_line,
		rhs = "<Plug>(nvim-surround-insert-line)",
		opts = {
			desc = "Add a surrounding pair around the cursor, on new lines (insert mode)",
		},
	})
	M.set_keymap({
		name = "normal",
		mode = "n",
		lhs = M.get_opts().keymaps.normal,
		rhs = "<Plug>(nvim-surround-normal)",
		opts = {
			desc = "Add a surrounding pair around a motion (normal mode)",
		},
	})
	M.set_keymap({
		name = "normal_cur",
		mode = "n",
		lhs = M.get_opts().keymaps.normal_cur,
		rhs = "<Plug>(nvim-surround-normal-cur)",
		opts = {
			desc = "Add a surrounding pair around the current line (normal mode)",
		},
	})
	M.set_keymap({
		name = "normal_line",
		mode = "n",
		lhs = M.get_opts().keymaps.normal_line,
		rhs = "<Plug>(nvim-surround-normal-line)",
		opts = {
			desc = "Add a surrounding pair around a motion, on new lines (normal mode)",
		},
	})
	M.set_keymap({
		name = "normal_cur_line",
		mode = "n",
		lhs = M.get_opts().keymaps.normal_cur_line,
		rhs = "<Plug>(nvim-surround-normal-cur-line)",
		opts = {
			desc = "Add a surrounding pair around the current line, on new lines (normal mode)",
		},
	})
	M.set_keymap({
		name = "visual",
		mode = "x",
		lhs = M.get_opts().keymaps.visual,
		rhs = "<Plug>(nvim-surround-visual)",
		opts = {
			desc = "Add a surrounding pair around a visual selection",
		},
	})
	M.set_keymap({
		name = "visual_line",
		mode = "x",
		lhs = M.get_opts().keymaps.visual_line,
		rhs = "<Plug>(nvim-surround-visual-line)",
		opts = {
			desc = "Add a surrounding pair around a visual selection, on new lines",
		},
	})
	M.set_keymap({
		name = "delete",
		mode = "n",
		lhs = M.get_opts().keymaps.delete,
		rhs = "<Plug>(nvim-surround-delete)",
		opts = {
			desc = "Delete a surrounding pair",
		},
	})
	M.set_keymap({
		name = "change",
		mode = "n",
		lhs = M.get_opts().keymaps.change,
		rhs = "<Plug>(nvim-surround-change)",
		opts = {
			desc = "Change a surrounding pair",
		},
	})
	M.set_keymap({
		name = "change_line",
		mode = "n",
		lhs = M.get_opts().keymaps.change_line,
		rhs = "<Plug>(nvim-surround-change-line)",
		opts = {
			desc = "Change a surrounding pair, putting replacements on new lines",
		},
	})
end

-- Setup the global user options for all files.
---@param user_opts user_options|nil The user-defined options to be merged with default_opts.
M.setup = function(user_opts)
	-- Overwrite default options with user-defined options, if they exist
	M.user_opts = M.merge_opts(M.translate_opts(M.default_opts), user_opts)
	M.set_keymaps({ buffer = false })
	-- Configure highlight group, if necessary
	if M.user_opts.highlight.duration then
		vim.cmd.highlight("default link NvimSurroundHighlight Visual")
	end
	-- Intercept dot repeat action, remembering cursor position
	local buffer = require("nvim-surround.buffer")
	local nvim_surround = require("nvim-surround")
	vim.on_key(function(key)
		if key == "." and not nvim_surround.pending_surround then
			nvim_surround.normal_curpos = buffer.get_curpos()
		end
	end)
end

-- Setup the user options for the current buffer.
---@param buffer_opts user_options|nil The buffer-local options to be merged with the global user_opts.
M.buffer_setup = function(buffer_opts)
	-- Merge the given table into the existing buffer-local options, or global options otherwise
	vim.b[0].nvim_surround_buffer_opts = M.merge_opts(M.get_opts(), buffer_opts)
	M.set_keymaps({ buffer = true })
end

return M


File: lua/config/nvim-tree.lua
---
Content:
local keymap = vim.keymap
local nvim_tree = require("nvim-tree")

nvim_tree.setup({
	auto_reload_on_write = true,
	disable_netrw = false,
	hijack_netrw = true,
	hijack_cursor = false,
	hijack_unnamed_buffer_when_opening = false,
	open_on_tab = false,
	sort_by = "name",
	update_cwd = false,
	view = {
		width = 30,
		side = "left",
		preserve_window_proportions = false,
		number = false,
		relativenumber = false,
		signcolumn = "yes",
	},
	renderer = {
		indent_markers = {
			enable = false,
			icons = {
				corner = " ",
				edge = " ",
				none = "  ",
			},
		},
		icons = {
			webdev_colors = true,
		},
	},
	hijack_directories = {
		enable = true,
		auto_open = true,
	},
	update_focused_file = {
		enable = false,
		update_cwd = false,
		ignore_list = {},
	},
	system_open = {
		cmd = "",
		args = {},
	},
	diagnostics = {
		enable = false,
		show_on_dirs = false,
		icons = {
			hint = "",
			info = "",
			warning = "",
			error = "",
		},
	},
	filters = {
		dotfiles = false,
		custom = {},
		exclude = {},
	},
	git = {
		enable = true,
		ignore = true,
		timeout = 400,
	},
	actions = {
		use_system_clipboard = true,
		change_dir = {
			enable = true,
			global = false,
			restrict_above_cwd = false,
		},
		open_file = {
			quit_on_open = false,
			resize_window = false,
			window_picker = {
				enable = true,
				chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890",
				exclude = {
					filetype = { "notify", "qf", "diff", "fugitive", "fugitiveblame" },
					buftype = { "nofile", "terminal", "help" },
				},
			},
		},
	},
	trash = {
		cmd = "trash",
		require_confirm = true,
	},
	log = {
		enable = false,
		truncate = false,
		types = {
			all = false,
			config = false,
			copy_paste = false,
			diagnostics = false,
			git = false,
			profile = false,
		},
	},
})


File: lua/config/nvim_hop.lua
---
Content:
local keymap = vim.keymap
local hop = require("hop")
hop.setup({
	case_insensitive = true,
	char2_fallback_key = "",
	quit_key = "",
	match_mappings = { "zh_sc" },
})

keymap.set({ "n", "v", "o" }, "<C-l>", "", {
	silent = true,
	noremap = true,
	callback = function()
		hop.hint_lines()
	end,
	desc = "nvim-hop char",
})

keymap.set({ "n", "v", "o" }, "<C-d>", "", {
	silent = true,
	noremap = true,
	callback = function()
		hop.hint_words()
	end,
	desc = "nvim-hop words",
})

vim.api.nvim_create_autocmd("ColorScheme", {
	pattern = "*",
	callback = function()
		vim.cmd([[
      hi HopNextKey cterm=bold ctermfg=176 gui=bold guibg=#ff00ff guifg=#ffffff
      hi HopNextKey1 cterm=bold ctermfg=176 gui=bold guibg=#ff00ff guifg=#ffffff
      hi HopNextKey2 cterm=bold ctermfg=176 gui=bold guibg=#ff00ff guifg=#ffffff
    ]])
	end,
})


File: lua/config/dashboard-nvim.lua
---
Content:
local api = vim.api
local keymap = vim.keymap
local dashboard = require("dashboard")

local conf = {}
conf.header = {
	"                                                       ",
	"                                                       ",
	"                                                       ",
	"                ",
	"           ",
	"              ",
	"           ",
	"          ",
	"                  ",
	"                                                       ",
	"                                                       ",
	"                                                       ",
	"                                                       ",
}

conf.center = {
	{
		icon = "  ",
		desc = "Find  File                              ",
		action = "FzfLua files",
		key = "<Leader> f f",
	},
	{
		icon = "  ",
		desc = "Recently opened files                   ",
		action = "FzfLua oldfiles",
		key = "<Leader> f o",
	},
	{
		icon = "  ",
		desc = "Grep Files",
		action = "FzfLua live_grep",
		key = "<Leader> f g",
	},
	{
		icon = "  ",
		desc = "Open Nvim config                        ",
		action = "tabnew $MYVIMRC | tcd %:p:h",
		key = "<Leader> e v",
	},
	{
		icon = "  ",
		desc = "New file                                ",
		action = "enew",
		key = "e",
	},
	{
		icon = "  ",
		desc = "Quit Nvim                               ",
		-- desc = "Quit Nvim                               ",
		action = "qa",
		key = "q",
	},
}

dashboard.setup({
	theme = "doom",
	shortcut_type = "number",
	config = conf,
})

api.nvim_create_autocmd("FileType", {
	pattern = "dashboard",
	group = api.nvim_create_augroup("dashboard_enter", { clear = true }),
	callback = function()
		keymap.set("n", "q", ":qa<CR>", { buffer = true, silent = true })
		keymap.set("n", "e", ":enew<CR>", { buffer = true, silent = true })
	end,
})


File: lua/config/nvim-cmp.lua
---
Content:
local cmp = require("cmp")
require("cmp_nvim_lsp")
require("cmp_path")
require("cmp_buffer")
require("cmp_omni")
require("cmp_nvim_ultisnips")

-- Add this: safely require mini.icons
local has_mini_icons, MiniIcons = pcall(require, "mini.icons")
if not has_mini_icons then
  vim.notify(
    "mini.icons not found! Please install it or adjust nvim-cmp configuration.",
    vim.log.levels.WARN,
    { title = "Nvim-config" }
  )
end

cmp.setup {
  snippet = {
    expand = function(args)
      -- For `ultisnips` user.
      vim.fn["UltiSnips#Anon"](args.body)
    end,
  },
  mapping = cmp.mapping.preset.insert {
    ["<Tab>"] = function(fallback)
      if cmp.visible() then
        cmp.select_next_item()
      else
        fallback()
      end
    end,
    ["<S-Tab>"] = function(fallback)
      if cmp.visible() then
        cmp.select_prev_item()
      else
        fallback()
      end
    end,
    ["<CR>"] = cmp.mapping.confirm { select = true },
    ["<C-e>"] = cmp.mapping.abort(),
    ["<Esc>"] = cmp.mapping.close(),
    ["<C-d>"] = cmp.mapping.scroll_docs(-4),
    ["<C-f>"] = cmp.mapping.scroll_docs(4),
  },
  sources = {
    { name = "nvim_lsp" }, -- For nvim-lsp
    { name = "ultisnips" }, -- For ultisnips user.
    { name = "path" }, -- for path completion
    { name = "buffer", keyword_length = 2 }, -- for buffer word completion
  },
  completion = {
    keyword_length = 1,
    completeopt = "menu,noselect",
  },
  view = {
    entries = "custom",
  },
  -- Modified formatting with null check for MiniIcons
  formatting = {
    format = function(_, vim_item)
      if has_mini_icons then
        local icon, hl = MiniIcons.get("lsp", vim_item.kind)
        vim_item.kind = icon .. " " .. vim_item.kind
        vim_item.kind_hl_group = hl
      end
      return vim_item
    end,
  },
}
cmp.setup.filetype("tex", {
  sources = {
    { name = "omni" },
    { name = "ultisnips" }, -- For ultisnips user.
    { name = "buffer", keyword_length = 2 }, -- for buffer word completion
    { name = "path" }, -- for path completion
  },
})
--  see https://github.com/hrsh7th/nvim-cmp/wiki/Menu-Appearance#how-to-add-visual-studio-code-dark-theme-colors-to-the-menu
vim.cmd([[
  highlight! link CmpItemMenu Comment
  " gray
  highlight! CmpItemAbbrDeprecated guibg=NONE gui=strikethrough guifg=#808080
  " blue
  highlight! CmpItemAbbrMatch guibg=NONE guifg=#569CD6
  highlight! CmpItemAbbrMatchFuzzy guibg=NONE guifg=#569CD6
  " light blue
  highlight! CmpItemKindVariable guibg=NONE guifg=#9CDCFE
  highlight! CmpItemKindInterface guibg=NONE guifg=#9CDCFE
  highlight! CmpItemKindText guibg=NONE guifg=#9CDCFE
  " pink
  highlight! CmpItemKindFunction guibg=NONE guifg=#C586C0
  highlight! CmpItemKindMethod guibg=NONE guifg=#C586C0
  " front
  highlight! CmpItemKindKeyword guibg=NONE guifg=#D4D4D4
  highlight! CmpItemKindProperty guibg=NONE guifg=#D4D4D4
  highlight! CmpItemKindUnit guibg=NONE guifg=#D4D4D4
]])


File: lua/config/copilot.lua
---
Content:
require("copilot").setup {
  panel = {
    enabled = true,
    auto_refresh = false,
    keymap = {
      jump_prev = "[[",
      jump_next = "]]",
      accept = "<CR>",
      refresh = "gr",
      --open = "<M-CR>"
    },
    layout = {
      position = "bottom",
      ratio = 0.4,
    },
  },
  suggestion = {
    enabled = true,
    auto_trigger = true,
    debounce = 75,
    keymap = {
      accept = "<M-;>",
      accept_word = "<M-w>",
      accept_line = "<M-L>",
      next = "<M-]>",
      prev = "<M-[>",
      dismiss = "<C-]>",
    },
  },
  filetypes = {
    yaml = false,
    markdown = false,
    help = false,
    gitcommit = false,
    gitrebase = false,
    hgcommit = false,
    svn = false,
    cvs = false,
    ["."] = false,
  },
  copilot_node_command = "node",
  server_opts_overrides = {},
}


File: lua/config/which-key.lua
---
Content:
require("which-key").setup({
	preset = "modern",
	icons = {
		mappings = false,
	},
})


File: lua/config/nvim-lint.lua
---
Content:
local lint = require("lint")
local utils = require("utils")

lint.linters_by_ft = {
  cpp = { "clangtidy", "cpplint" },
  haskell = { "hlint" },
  lua = { "luacheck" },
  markdown = { "markdownlint", "vale" },
  python = { "ruff", "mypy" },
  rust = { "clippy" },
  sh = { "shellcheck" },
  sql = { "sqlfluff" },
  tex = { "chktex", "lacheck" },
  text = { "proselint", "write_good" },
  toml = {}, -- No built-in TOML linters in nvim-lint
  vim = { "vint" },
  yaml = { "yamllint" },
  gitcommit = { "gitlint" },
  gitignore = {},
  log = {},
  rsync = {},
}

-- Python-specific
lint.linters.ruff = {
  cmd = function()
    local venv = os.getenv("VIRTUAL_ENV")
    if venv then
      if vim.fn.has("win32") == 1 then
        return venv .. "\\Scripts\\ruff.exe"
      else
        return venv .. "/bin/ruff"
      end
    end
    return "ruff"
  end,
  stdin = true,
  args = function()
    local python_info = utils.get_python_info()
    return {
      "--select=E,F,W,I,N,B,RUF",
      "--format=text",
      "--target-version=" .. python_info.version,
    }
  end,
  parser = require("lint.parser").from_pattern(
    "^.*:(%d+):(%d+): (%a%d+) (.+)$",
    { "lnum", "col", "code", "message" },
    {
      ["E"] = vim.diagnostic.severity.ERROR,
      ["F"] = vim.diagnostic.severity.ERROR,
      ["W"] = vim.diagnostic.severity.WARN,
      ["I"] = vim.diagnostic.severity.INFO,
      ["N"] = vim.diagnostic.severity.HINT,
      ["B"] = vim.diagnostic.severity.WARN,
      ["RUF"] = vim.diagnostic.severity.INFO,
    },
    { source = "ruff" }
  ),
}

-- mypy configuration
lint.linters.mypy = {
  cmd = function()
    local venv = os.getenv("VIRTUAL_ENV")
    if venv then
      if vim.fn.has("win32") == 1 then
        return venv .. "\\Scripts\\mypy.exe"
      else
        return venv .. "/bin/mypy"
      end
    end
    return "mypy"
  end,
  stdin = false,
  args = {
    "--show-column-numbers",
    "--no-error-summary",
    "--no-pretty",
    "--disallow-untyped-defs",
  },
  parser = lint.linters.mypy.parser,
}

-- Lua linter configuration
lint.linters.luacheck.args = {
  "--no-color",
  "--codes",
  "--no-unused",
  "--no-redefined",
  "--globals",
  "vim",
  "--std",
  "luajit+nvim",
}

-- C/C++ linter configuration
if utils.executable("clang-tidy") then
  lint.linters.clangtidy.args = {
    "--checks=*",
    "--warnings-as-errors=*",
  }
end

-- Rust linter configuration
if utils.executable("clippy") then
  lint.linters.clippy.args = {
    "--message-format=json",
    "--",
    "--warn",
    "clippy::all",
  }
end

-- Shell linter configuration
if utils.executable("shellcheck") then
  lint.linters.shellcheck.args = {
    "--format=json",
    "--severity=style",
    "--shell=bash",
    "-",
  }
end

-- LaTeX linter configuration
if utils.executable("chktex") then
  lint.linters.chktex.args = {
    "-q",
    "-v0",
  }
end

-- Set up an autocmd to trigger linting
vim.api.nvim_create_autocmd({ "BufWritePost", "BufEnter" }, {
  callback = function()
    -- Get filetype
    local ft = vim.bo.filetype
    -- Only lint if we have linters defined for this filetype
    if lint.linters_by_ft[ft] and #lint.linters_by_ft[ft] > 0 then
      require("lint").try_lint()
    end
  end,
})

-- Keymaps for manual linting
vim.keymap.set("n", "<leader>ll", function()
  require("lint").try_lint()
end, { desc = "Lint current file" })

-- Keymaps to disable/enable linting temporarily
vim.keymap.set("n", "<leader>ld", function()
  -- Store current linters
  vim.g.linters_backup = vim.deepcopy(lint.linters_by_ft)
  lint.linters_by_ft = {}
  print("Linting disabled")
end, { desc = "Disable linting" })

vim.keymap.set("n", "<leader>le", function()
  -- Restore linters
  if vim.g.linters_backup then
    lint.linters_by_ft = vim.deepcopy(vim.g.linters_backup)
    print("Linting enabled")
  end
end, { desc = "Enable linting" })

-- Agregar keymap para mostrar diagnsticos flotantes manualmente
vim.keymap.set("n", "<leader>lf", function()
  vim.diagnostic.open_float { scope = "line" }
end, { desc = "Show diagnostics in float window" })


File: lua/config/fugitive.lua
---
Content:
local keymap = vim.keymap

keymap.set("n", "<leader>gs", "<cmd>Git<cr>", { desc = "Git: show status" })
keymap.set("n", "<leader>gw", "<cmd>Gwrite<cr>", { desc = "Git: add file" })
keymap.set("n", "<leader>gc", "<cmd>Git commit<cr>", { desc = "Git: commit changes" })
keymap.set("n", "<leader>gpl", "<cmd>Git pull<cr>", { desc = "Git: pull changes" })
keymap.set("n", "<leader>gpu", "<cmd>15 split|term git push<cr>", { desc = "Git: push changes" })
keymap.set("v", "<leader>gb", ":Git blame<cr>", { desc = "Git: blame selected line" })

-- convert git to Git in command line mode
vim.fn["utils#Cabbrev"]("git", "Git")

keymap.set("n", "<leader>gbn", function()
	vim.ui.input({ prompt = "Enter a new branch name" }, function(user_input)
		if user_input == nil or user_input == "" then
			return
		end

		local cmd_str = string.format("G checkout -b %s", user_input)
		vim.cmd(cmd_str)
	end)
end, {
	desc = "Git: create new branch",
})

keymap.set("n", "<leader>gf", ":Git fetch ", { desc = "Git: prune branches" })
keymap.set("n", "<leader>gbd", ":Git branch -D ", { desc = "Git: delete branch" })


File: lua/config/nvim_ufo.lua
---
Content:
local handler = function(virtText, lnum, endLnum, width, truncate)
	local newVirtText = {}
	local foldedLines = endLnum - lnum
	local suffix = ("   %d"):format(foldedLines)
	local sufWidth = vim.fn.strdisplaywidth(suffix)
	local targetWidth = width - sufWidth
	local curWidth = 0

	for _, chunk in ipairs(virtText) do
		local chunkText = chunk[1]
		local chunkWidth = vim.fn.strdisplaywidth(chunkText)
		if targetWidth > curWidth + chunkWidth then
			table.insert(newVirtText, chunk)
		else
			chunkText = truncate(chunkText, targetWidth - curWidth)
			local hlGroup = chunk[2]
			table.insert(newVirtText, { chunkText, hlGroup })
			chunkWidth = vim.fn.strdisplaywidth(chunkText)
			-- str width returned from truncate() may less than 2nd argument, need padding
			if curWidth + chunkWidth < targetWidth then
				suffix = suffix .. (" "):rep(targetWidth - curWidth - chunkWidth)
			end
			break
		end
		curWidth = curWidth + chunkWidth
	end
	local rAlignAppndx = math.max(math.min(vim.opt.textwidth["_value"], width - 1) - curWidth - sufWidth, 0)
	suffix = (" "):rep(rAlignAppndx) .. suffix
	table.insert(newVirtText, { suffix, "MoreMsg" })
	return newVirtText
end

require("ufo").setup({
	fold_virt_text_handler = handler,
})

vim.keymap.set("n", "zR", require("ufo").openAllFolds)
vim.keymap.set("n", "zM", require("ufo").closeAllFolds)
vim.keymap.set("n", "zr", require("ufo").openFoldsExceptKinds)
vim.keymap.set("n", "<leader>K", function()
	local _ = require("ufo").peekFoldedLinesUnderCursor()
end, {
	desc = "Preview folded maps",
})


File: lua/config/fidget-nvim.lua
---
Content:
require("fidget").setup({})


File: lua/config/fzf-lua.lua
---
Content:
require("fzf-lua").setup {
  defaults = {
    file_icons = "mini",
  },
  winopts = {
    row = 0.5,
    height = 0.7,
  },
  files = {
    previewer = false,
  },
}

vim.keymap.set("n", "<leader>ff", "<cmd>FzfLua files<cr>", { desc = "Fuzzy find files" })
vim.keymap.set("n", "<leader>fg", "<cmd>FzfLua live_grep<cr>", { desc = "Fuzzy grep files" })
vim.keymap.set("n", "<leader>fh", "<cmd>FzfLua helptags<cr>", { desc = "Fuzzy grep tags in help files" })
vim.keymap.set("n", "<leader>ft", "<cmd>FzfLua btags<cr>", { desc = "Fuzzy search buffer tags" })
vim.keymap.set("n", "<leader>fb", "<cmd>FzfLua buffers<cr>", { desc = "Fuzzy search opened buffers" })
vim.keymap.set("n", "<leader>fo", "<cmd>FzfLua oldfiles<cr>", { desc = "Fuzzy search old files" })


File: lua/config/treesitter.lua
---
Content:
require("nvim-treesitter.configs").setup({
	ensure_installed = {
		"python",
		"cpp",
		"lua",
		"vim",
		"json",
		"toml",
		"latex",
		"sql",
		"bibtex",
		"markdown",
		"markdown_inline",
		"haskell",
	},
	ignore_install = {}, -- List of parsers to ignore installing
	sync_install = false,
	auto_install = true,
	highlight = {
		enable = true,
		additional_vim_regex_highlighting = false,
	},
})


File: lua/config/lightbulb.lua
---
Content:
---@diagnostic disable: missing-fields
require("nvim-lightbulb").setup({
	autocmd = {
		enabled = true,
		updatetime = -1,
	},
	---@diagnostic disable-next-line: unused-local
	filter = function(client_name, result)
		-- Ruff always sends these two actions even if there are no action to take,
		-- so it is better to just ignore this to avoid noise. See also discussion below:
		-- https://github.com/astral-sh/ruff-lsp/issues/91
		local ignored_kinds = { "source.fixAll.ruff", "source.organizeImports.ruff" }

		if vim.tbl_contains(ignored_kinds, result.kind) then
			return false
		end

		return true
	end,
})


File: lua/config/blink-cmp.lua
---
Content:
require("blink.cmp").setup {
  -- 'default' (recommended) for mappings similar to built-in completions (C-y to accept)
  -- 'super-tab' for mappings similar to vscode (tab to accept)
  -- 'enter' for enter to accept
  -- 'none' for no mappings
  --
  keymap = {
    preset = "default",
    ["<Tab>"] = { "select_next", "fallback" },
    ["<S-Tab>"] = { "select_prev", "fallback" },
    ["<Enter>"] = { "select_and_accept", "fallback" },
    ["<C-U>"] = { "scroll_documentation_up", "fallback" },
    ["<C-D>"] = { "scroll_documentation_down", "fallback" },
  },

  appearance = {
    nerd_font_variant = "mono",
  },

  -- (Default) Only show the documentation popup when manually triggered
  completion = {
    documentation = {
      auto_show = true,
    },
  },

  -- Default list of enabled providers defined so that you can extend it
  -- elsewhere in your config, without redefining it, due to `opts_extend`
  sources = {
    default = { "lsp", "path", "buffer" },
  },

  -- (Default) Rust fuzzy matcher for typo resistance and significantly better performance
  -- You may use a lua implementation instead by using `implementation = "lua"` or fallback to the lua implementation,
  -- when the Rust fuzzy matcher is not available, by using `implementation = "prefer_rust"`
  --
  -- See the fuzzy documentation for more information
  fuzzy = { implementation = "prefer_rust_with_warning" },
  cmdline = {
    completion = {
      menu = {
        auto_show = true,
      },
    },
    keymap = {
      ["<Enter>"] = { "select_and_accept", "fallback" },
    },
  },
}


File: lua/config/treesitter-textobjects.lua
---
Content:
require("nvim-treesitter.configs").setup({
	textobjects = {
		select = {
			enable = true,

			-- Automatically jump forward to textobj, similar to targets.vim
			lookahead = true,

			keymaps = {
				-- You can use the capture groups defined in textobjects.scm
				["af"] = "@function.outer",
				["if"] = "@function.inner",
				["ac"] = "@class.outer",
				-- You can optionally set descriptions to the mappings (used in the desc parameter of
				-- nvim_buf_set_keymap) which plugins like which-key display
				["ic"] = { query = "@class.inner", desc = "Select inner part of a class region" },
			},
			-- You can choose the select mode (default is charwise 'v')
			--
			-- Can also be a function which gets passed a table with the keys
			-- * query_string: eg '@function.inner'
			-- * method: eg 'v' or 'o'
			-- and should return the mode ('v', 'V', or '<c-v>') or a table
			-- mapping query_strings to modes.
			selection_modes = {
				["@function.inner"] = "V", -- linewise
				["@function.outer"] = "V", -- linewise
				["@class.outer"] = "V", -- linewise
				["@class.inner"] = "V", -- linewise
				["@parameter.outer"] = "v", -- charwise
			},
			-- If you set this to `true` (default is `false`) then any textobject is
			-- extended to include preceding or succeeding whitespace. Succeeding
			-- whitespace has priority in order to act similarly to eg the built-in
			-- `ap`.
			--
			-- Can also be a function which gets passed a table with the keys
			-- * query_string: eg '@function.inner'
			-- * selection_mode: eg 'v'
			-- and should return true or false
			include_surrounding_whitespace = false,
		},
	},
})


File: lua/config/neorg.lua
---
Content:
local api = vim.api
local keymap = vim.keymap
local utils = require("utils")

-- This module configures Neorg for LaTeX notes and presentations
local M = {}

function M.setup()
	-- Check if neorg is available
	local has_neorg, neorg = pcall(require, "neorg")
	if not has_neorg then
		vim.notify("neorg not found!", vim.log.levels.WARN, { title = "Nvim-config" })
		return
	end

	-- Path configuration for workspaces
	local neorg_dir = vim.fn.expand("~/Documents/notes")
	local work_dir = vim.fn.expand("~/Documents/notes/work")
	local personal_dir = vim.fn.expand("~/Documents/notes/personal")
	local presentations_dir = vim.fn.expand("~/Documents/notes/presentations")

	-- Create the directories if they don't exist
	for _, dir in ipairs({ neorg_dir, work_dir, personal_dir, presentations_dir }) do
		if vim.fn.isdirectory(dir) == 0 then
			vim.fn.mkdir(dir, "p")
		end
	end

	-- Set up Neorg with minimal configuration first to ensure it works
	neorg.setup({
		load = {
			["core.defaults"] = {}, -- Loads default modules
			["core.dirman"] = {
				config = {
					workspaces = {
						main = neorg_dir,
						work = work_dir,
						personal = personal_dir,
						presentations = presentations_dir,
					},
					default_workspace = "main",
				},
			},
		},
	})

	-- Define basic keybindings manually (avoiding core.keybinds module for now)
	api.nvim_create_autocmd("FileType", {
		pattern = "norg",
		callback = function()
			-- Set buffer-local keymaps
			local map = function(mode, lhs, rhs, desc)
				keymap.set(mode, lhs, rhs, { buffer = true, silent = true, desc = desc })
			end

			-- Basic navigation commands
			map("n", "<Leader>nn", ":Neorg workspace main<CR>", "Switch to main workspace")
			map("n", "<Leader>nw", ":Neorg workspace work<CR>", "Switch to work workspace")
			map("n", "<Leader>np", ":Neorg workspace presentations<CR>", "Switch to presentations workspace")

			-- Export commands (if available)
			map("n", "<Leader>nm", ":Neorg export to-file %:p.md markdown<CR>", "Export to Markdown")

			-- Only add these if the commands are registered
			if vim.fn.exists(":Neorg presenter start") == 2 then
				map("n", "<Leader>ns", ":Neorg presenter start<CR>", "Start presenter mode")
			end
		end,
		desc = "Configure basic Neorg keymaps",
	})

	-- Add custom commands for creating new notes
	api.nvim_create_user_command("NeorgNote", function()
		local filename = vim.fn.input("Enter note filename (without extension): ")
		if filename == "" then
			return
		end

		local filepath = neorg_dir .. "/" .. filename .. ".norg"
		vim.cmd("edit " .. filepath)

		-- Add template for new files
		if vim.fn.filereadable(filepath) == 0 then
			local template = {
				"* " .. filename,
				"",
				"** Introduction",
				"",
				"Your notes here",
				"",
			}

			api.nvim_buf_set_lines(0, 0, 0, false, template)
			vim.cmd("write")
		end
	end, {})

	-- Set up template for presentation slides
	api.nvim_create_user_command("NeorgSlide", function()
		-- Create a new presentation slide
		local filename = vim.fn.input("Enter slide filename (without extension): ")
		if filename == "" then
			return
		end

		local filepath = presentations_dir .. "/" .. filename .. ".norg"
		vim.cmd("edit " .. filepath)

		-- If file is new, add slide template
		if vim.fn.filereadable(filepath) == 0 then
			local template = {
				"@document.meta",
				"title: " .. filename,
				"description: Presentation created with Neorg",
				"authors: [Your Name]",
				"date: " .. os.date("%Y-%m-%d"),
				"categories: [presentation, slides]",
				"version: 1.0.0",
				"@end",
				"",
				"* " .. filename,
				"",
				"** Slide 1: Introduction",
				"",
				"Your content here",
				"",
				"---",
				"",
				"** Slide 2: Main Content",
				"",
				"More content here",
				"",
				"---",
				"",
				"** Slide 3: Conclusion",
				"",
				"Conclusion here",
			}

			api.nvim_buf_set_lines(0, 0, 0, false, template)
			vim.cmd("write")
		end
	end, {})

	-- Set up template for LaTeX notes
	api.nvim_create_user_command("NeorgLatexNote", function()
		-- Create a new LaTeX-oriented note
		local filename = vim.fn.input("Enter note filename (without extension): ")
		if filename == "" then
			return
		end

		local filepath = work_dir .. "/" .. filename .. ".norg"
		vim.cmd("edit " .. filepath)

		-- If file is new, add LaTeX note template
		if vim.fn.filereadable(filepath) == 0 then
			local template = {
				"@document.meta",
				"title: " .. filename,
				"description: LaTeX-oriented note",
				"authors: [Your Name]",
				"date: " .. os.date("%Y-%m-%d"),
				"categories: [notes, latex]",
				"version: 1.0.0",
				"@end",
				"",
				"* " .. filename,
				"",
				"** Introduction",
				"",
				"Your introduction here",
				"",
				"** Mathematical Content",
				"",
				"@math",
				"f(x) = \\int_{-\\infty}^{\\infty} \\hat{f}(\\xi)\\,e^{2 \\pi i \\xi x} \\,d\\xi",
				"@end",
				"",
				"** Conclusion",
				"",
				"Your conclusion here",
			}

			api.nvim_buf_set_lines(0, 0, 0, false, template)
			vim.cmd("write")
		end
	end, {})

	-- Command to compile to PDF via Markdown and Pandoc
	api.nvim_create_user_command("NeorgCompilePDF", function()
		-- Get current file path
		local current_file = vim.fn.expand("%:p")

		-- Check if this is a Neorg file
		if vim.fn.fnamemodify(current_file, ":e") ~= "norg" then
			vim.notify("Current file is not a Neorg file!", vim.log.levels.ERROR, { title = "Neorg Compiler" })
			return
		end

		-- Export to Markdown
		vim.cmd("Neorg export to-file " .. current_file .. ".md markdown")

		-- Get the Markdown file path
		local md_file = current_file .. ".md"

		-- Check if the Markdown file exists
		if vim.fn.filereadable(md_file) == 0 then
			vim.notify(
				"Export failed or file not found: " .. md_file,
				vim.log.levels.ERROR,
				{ title = "Neorg Compiler" }
			)
			return
		end

		-- Check if pandoc is installed
		if not utils.executable("pandoc") then
			vim.notify(
				"Pandoc not found! Please install pandoc to compile to PDF.",
				vim.log.levels.ERROR,
				{ title = "Neorg Compiler" }
			)
			return
		end

		-- Compile Markdown to PDF using pandoc
		local pdf_file = vim.fn.fnamemodify(md_file, ":r") .. ".pdf"
		local compile_cmd = "pandoc -f markdown -t pdf "
			.. vim.fn.shellescape(md_file)
			.. " -o "
			.. vim.fn.shellescape(pdf_file)
			.. " --pdf-engine=xelatex -V mainfont='DejaVu Sans' -V monofont='DejaVu Sans Mono' -V 'geometry:margin=1in' -V colorlinks=true"

		vim.notify("Compiling to PDF...", vim.log.levels.INFO, { title = "Neorg Compiler" })

		vim.fn.jobstart(compile_cmd, {
			on_exit = function(_, exit_code)
				if exit_code == 0 then
					vim.notify(
						"Successfully compiled to PDF: " .. pdf_file,
						vim.log.levels.INFO,
						{ title = "Neorg Compiler" }
					)

					-- Ask if user wants to open the PDF
					vim.ui.select({ "Yes", "No" }, {
						prompt = "Open the PDF?",
					}, function(choice)
						if choice == "Yes" then
							local open_cmd
							if vim.fn.has("mac") == 1 then
								open_cmd = "open "
							elseif vim.fn.has("unix") == 1 then
								open_cmd = "xdg-open "
							elseif vim.fn.has("win32") == 1 then
								open_cmd = "start "
							end

							if open_cmd then
								vim.fn.jobstart(open_cmd .. vim.fn.shellescape(pdf_file))
							end
						end
					end)
				else
					vim.notify(
						"Failed to compile PDF. Exit code: " .. exit_code,
						vim.log.levels.ERROR,
						{ title = "Neorg Compiler" }
					)
				end
			end,
		})
	end, {})

	-- Configure custom highlights for Neorg
	api.nvim_create_autocmd("ColorScheme", {
		callback = function()
			-- Custom highlights for better math representation
			vim.cmd([[
                hi! link NeorgMath ModeMsg
                hi! link NeorgHeading1 Title
                hi! link NeorgHeading2 Function
                hi! link NeorgHeading3 Identifier
                hi! link NeorgHeading4 String
                hi! link NeorgTodo Todo
                hi! link NeorgTodoItem1Done DiagnosticOk
                hi! link NeorgTodoItem1Pending DiagnosticWarn
                hi! link NeorgTodoItem1Undone DiagnosticError
            ]])
		end,
		nested = true,
		desc = "Configure Neorg-specific highlights",
	})
end

return M


File: lua/config/yanky.lua
---
Content:
require("yanky").setup({
	preserve_cursor_position = {
		enabled = false,
	},
	highlight = {
		on_put = true,
		on_yank = false,
		timer = 300,
	},
})

vim.keymap.set({ "n", "x" }, "p", "<Plug>(YankyPutAfter)")
vim.keymap.set({ "n", "x" }, "P", "<Plug>(YankyPutBefore)")

-- cycle through the yank history, only work after paste
vim.keymap.set("n", "[y", "<Plug>(YankyPreviousEntry)")
vim.keymap.set("n", "]y", "<Plug>(YankyNextEntry)")


File: lua/config/oil.lua
---
Content:
require("oil").setup({
	-- Oil will take over directory buffers (e.g. `vim .` or `:e src/`)
	-- Set to false if you want some other plugin (e.g. netrw) to open when you edit directories.
	default_file_explorer = true,
	-- Id is automatically added at the beginning, and name at the end
	-- See :help oil-columns
	columns = {
		"icon",
		-- "permissions",
		-- "size",
		-- "mtime",
	},
	-- Buffer-local options to use for oil buffers
	buf_options = {
		buflisted = false,
		bufhidden = "hide",
	},
	-- Window-local options to use for oil buffers
	win_options = {
		wrap = false,
		signcolumn = "no",
		cursorcolumn = false,
		foldcolumn = "0",
		spell = false,
		list = false,
		conceallevel = 3,
		concealcursor = "nvic",
	},
	-- Send deleted files to the trash instead of permanently deleting them (:help oil-trash)
	delete_to_trash = false,
	-- Skip the confirmation popup for simple operations (:help oil.skip_confirm_for_simple_edits)
	skip_confirm_for_simple_edits = false,
	-- Selecting a new/moved/renamed file or directory will prompt you to save changes first
	-- (:help prompt_save_on_select_new_entry)
	prompt_save_on_select_new_entry = true,
	-- Oil will automatically delete hidden buffers after this delay
	-- You can set the delay to false to disable cleanup entirely
	-- Note that the cleanup process only starts when none of the oil buffers are currently displayed
	cleanup_delay_ms = 2000,
	lsp_file_methods = {
		-- Enable or disable LSP file operations
		enabled = true,
		-- Time to wait for LSP file operations to complete before skipping
		timeout_ms = 1000,
		-- Set to true to autosave buffers that are updated with LSP willRenameFiles
		-- Set to "unmodified" to only save unmodified buffers
		autosave_changes = false,
	},
	-- Constrain the cursor to the editable parts of the oil buffer
	-- Set to `false` to disable, or "name" to keep it on the file names
	constrain_cursor = "editable",
	-- Set to true to watch the filesystem for changes and reload oil
	watch_for_changes = false,
	-- Keymaps in oil buffer. Can be any value that `vim.keymap.set` accepts OR a table of keymap
	-- options with a `callback` (e.g. { callback = function() ... end, desc = "", mode = "n" })
	-- Additionally, if it is a string that matches "actions.<name>",
	-- it will use the mapping at require("oil.actions").<name>
	-- Set to `false` to remove a keymap
	-- See :help oil-actions for a list of all available actions
	keymaps = {
		["g?"] = { "actions.show_help", mode = "n" },
		["<CR>"] = "actions.select",
		["<C-s>"] = { "actions.select", opts = { vertical = true } },
		["<C-h>"] = { "actions.select", opts = { horizontal = true } },
		["<C-t>"] = { "actions.select", opts = { tab = true } },
		["<C-p>"] = "actions.preview",
		["<C-c>"] = { "actions.close", mode = "n" },
		["<C-l>"] = "actions.refresh",
		["-"] = { "actions.parent", mode = "n" },
		["_"] = { "actions.open_cwd", mode = "n" },
		["`"] = { "actions.cd", mode = "n" },
		["~"] = { "actions.cd", opts = { scope = "tab" }, mode = "n" },
		["gs"] = { "actions.change_sort", mode = "n" },
		["gx"] = "actions.open_external",
		["g."] = { "actions.toggle_hidden", mode = "n" },
		["g\\"] = { "actions.toggle_trash", mode = "n" },
	},
	-- Set to false to disable all of the above keymaps
	use_default_keymaps = true,
	view_options = {
		-- Show files and directories that start with "."
		show_hidden = false,
		-- This function defines what is considered a "hidden" file
		is_hidden_file = function(name, bufnr)
			local m = name:match("^%.")
			return m ~= nil
		end,
		-- This function defines what will never be shown, even when `show_hidden` is set
		is_always_hidden = function(name, bufnr)
			return false
		end,
		-- Sort file names with numbers in a more intuitive order for humans.
		-- Can be "fast", true, or false. "fast" will turn it off for large directories.
		natural_order = "fast",
		-- Sort file and directory names case insensitive
		case_insensitive = false,
		sort = {
			-- sort order can be "asc" or "desc"
			-- see :help oil-columns to see which columns are sortable
			{ "type", "asc" },
			{ "name", "asc" },
		},
		-- Customize the highlight group for the file name
		highlight_filename = function(entry, is_hidden, is_link_target, is_link_orphan)
			return nil
		end,
	},
	-- Extra arguments to pass to SCP when moving/copying files over SSH
	extra_scp_args = {},
	-- EXPERIMENTAL support for performing file operations with git
	git = {
		-- Return true to automatically git add/mv/rm files
		add = function(path)
			return false
		end,
		mv = function(src_path, dest_path)
			return false
		end,
		rm = function(path)
			return false
		end,
	},
	-- Configuration for the floating window in oil.open_float
	float = {
		-- Padding around the floating window
		padding = 2,
		-- max_width and max_height can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
		max_width = 0,
		max_height = 0,
		border = "rounded",
		win_options = {
			winblend = 0,
		},
		-- optionally override the oil buffers window title with custom function: fun(winid: integer): string
		get_win_title = nil,
		-- preview_split: Split direction: "auto", "left", "right", "above", "below".
		preview_split = "auto",
		-- This is the config that will be passed to nvim_open_win.
		-- Change values here to customize the layout
		override = function(conf)
			return conf
		end,
	},
	-- Configuration for the file preview window
	preview_win = {
		-- Whether the preview window is automatically updated when the cursor is moved
		update_on_cursor_moved = true,
		-- How to open the preview window "load"|"scratch"|"fast_scratch"
		preview_method = "fast_scratch",
		-- A function that returns true to disable preview on a file e.g. to avoid lag
		disable_preview = function(filename)
			return false
		end,
		-- Window-local options to use for preview window buffers
		win_options = {},
	},
	-- Configuration for the floating action confirmation window
	confirmation = {
		-- Width dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
		-- min_width and max_width can be a single value or a list of mixed integer/float types.
		-- max_width = {100, 0.8} means "the lesser of 100 columns or 80% of total"
		max_width = 0.9,
		-- min_width = {40, 0.4} means "the greater of 40 columns or 40% of total"
		min_width = { 40, 0.4 },
		-- optionally define an integer/float for the exact width of the preview window
		width = nil,
		-- Height dimensions can be integers or a float between 0 and 1 (e.g. 0.4 for 40%)
		-- min_height and max_height can be a single value or a list of mixed integer/float types.
		-- max_height = {80, 0.9} means "the lesser of 80 columns or 90% of total"
		max_height = 0.9,
		-- min_height = {5, 0.1} means "the greater of 5 columns or 10% of total"
		min_height = { 5, 0.1 },
		-- optionally define an integer/float for the exact height of the preview window
		height = nil,
		border = "rounded",
		win_options = {
			winblend = 0,
		},
	},
	-- Configuration for the floating progress window
	progress = {
		max_width = 0.9,
		min_width = { 40, 0.4 },
		width = nil,
		max_height = { 10, 0.9 },
		min_height = { 5, 0.1 },
		height = nil,
		border = "rounded",
		minimized_border = "none",
		win_options = {
			winblend = 0,
		},
	},
	-- Configuration for the floating SSH window
	ssh = {
		border = "rounded",
	},
	-- Configuration for the floating keymaps help window
	keymaps_help = {
		border = "rounded",
	},
})

vim.keymap.set("n", "<space>e", function()
	require("oil").open_float()
end, {
	desc = "Open Oil in a floating window",
})


File: lua/config/bufferline.lua
---
Content:
require("bufferline").setup({
	options = {
		numbers = "none",
		close_command = "bdelete! %d",
		right_mouse_command = nil,
		left_mouse_command = "buffer %d",
		middle_mouse_command = nil,
		indicator = {
			icon = "", -- this should be omitted if indicator style is not 'icon'
			style = "icon",
		},
		buffer_close_icon = "",
		modified_icon = "",
		close_icon = "",
		left_trunc_marker = "",
		right_trunc_marker = "",
		max_name_length = 18,
		max_prefix_length = 15,
		tab_size = 10,
		diagnostics = false,
		custom_filter = function(bufnr)
			-- if the result is false, this buffer will be shown, otherwise, this
			-- buffer will be hidden.

			-- filter out filetypes you don't want to see
			local exclude_ft = { "qf", "fugitive", "git" }
			local cur_ft = vim.bo[bufnr].filetype
			local should_filter = vim.tbl_contains(exclude_ft, cur_ft)

			if should_filter then
				return false
			end

			return true
		end,
		show_buffer_icons = false,
		show_buffer_close_icons = true,
		show_close_icon = true,
		show_tab_indicators = true,
		persist_buffer_sort = true, -- whether or not custom sorted buffers should persist
		separator_style = "bar",
		enforce_regular_tabs = false,
		always_show_bufferline = true,
		sort_by = "id",
	},
})

vim.keymap.set("n", "<space>bp", "<cmd>BufferLinePick<CR>", {
	desc = "pick a buffer",
})


File: lua/config/indent-blankline.lua
---
Content:
local api = vim.api

local exclude_ft = { "help", "git", "markdown", "snippets", "text", "gitconfig", "alpha", "dashboard" }

require("ibl").setup({
	indent = {
		-- -- U+2502 may also be a good choice, it will be on the middle of cursor.
		-- -- U+250A is also a good choice
		char = "",
	},
	scope = {
		show_start = false,
		show_end = false,
	},
	exclude = {
		filetypes = exclude_ft,
		buftypes = { "terminal" },
	},
})

local gid = api.nvim_create_augroup("indent_blankline", { clear = true })
api.nvim_create_autocmd("InsertEnter", {
	pattern = "*",
	group = gid,
	command = "IBLDisable",
})

api.nvim_create_autocmd("InsertLeave", {
	pattern = "*",
	group = gid,
	callback = function()
		if not vim.tbl_contains(exclude_ft, vim.bo.filetype) then
			vim.cmd([[IBLEnable]])
		end
	end,
})


File: lua/config/telescope.lua
---
Content:
local telescope = require("telescope")
local actions = require("telescope.actions")
local keymap = vim.keymap

telescope.setup({
	defaults = {
		mappings = {
			i = {
				["<C-j>"] = actions.move_selection_next,
				["<C-k>"] = actions.move_selection_previous,
			},
		},
	},
})

keymap.set("n", "<leader>ef", "<cmd>Telescope find_files<cr>", { desc = "Find files in current directory" })
keymap.set("n", "<leader>eg", "<cmd>Telescope live_grep<cr>", { desc = "Find text in current directory" })
keymap.set("n", "<leader>eb", "<cmd>Telescope buffers<cr>", { desc = "Find buffers" })
keymap.set("n", "<leader>eh", "<cmd>Telescope help_tags<cr>", { desc = "Find help tags" })
keymap.set("n", "<leader>ec", "<cmd>Telescope current_buffer_fuzzy_find<cr>", { desc = "Find text in current file" })
keymap.set("n", "<leader>er", "<cmd>Telescope oldfiles<cr>", { desc = "Find recent files" })
keymap.set("n", "<leader>em", "<cmd>Telescope marks<cr>", { desc = "Find marks" })
keymap.set("n", "<leader>ek", "<cmd>Telescope keymaps<cr>", { desc = "Find keymaps" })

keymap.set("n", "<leader>tg", "<cmd>Telescope git_files<cr>", { desc = "Find files in git project" })
keymap.set("n", "<leader>ts", "<cmd>Telescope grep_string<cr>", { desc = "Find string under cursor" })
keymap.set("n", "<leader>tc", "<cmd>Telescope commands<cr>", { desc = "Find and execute commands" })
keymap.set("n", "<leader>tr", "<cmd>Telescope registers<cr>", { desc = "Find registers" })
keymap.set("n", "<leader>tt", "<cmd>Telescope treesitter<cr>", { desc = "Find treesitter symbols" })
keymap.set("n", "<leader>tq", "<cmd>Telescope quickfix<cr>", { desc = "Find quickfix entries" })
keymap.set("n", "<leader>tl", "<cmd>Telescope loclist<cr>", { desc = "Find loclist entries" })
keymap.set("n", "<leader>td", "<cmd>Telescope diagnostics<cr>", { desc = "Find diagnostics" })


File: lua/config/git-conflict.lua
---
Content:
require("git-conflict").setup({})

vim.api.nvim_create_autocmd("User", {
    pattern = "GitConflictResolved",
    callback = function()
        vim.schedule(function()
            vim.fn.setqflist({}, "r")
            vim.cmd([[GitConflictListQf]])
        end)
    end,
})


File: lua/config/bqf.lua
---
Content:
require("bqf").setup({
	auto_resize_height = false,
	preview = {
		auto_preview = false,
	},
})


File: lua/config/hlslens.lua
---
Content:
local api = vim.api
local keymap = vim.keymap

local hlslens = require("hlslens")

hlslens.setup({
	calm_down = true,
	nearest_only = true,
})

local activate_hlslens = function(direction)
	local cmd = string.format("normal! %s%szzzv", vim.v.count1, direction)
	local status, msg = pcall(vim.cmd, cmd)

	-- Deal with the case that there is no such pattern in current buffer.
	if not status then
		local start_idx, _ = string.find(msg, "E486", 1, true)
		local msg_part = string.sub(msg, start_idx)
		api.nvim_err_writeln(msg_part)
		return
	end

	hlslens.start()
end

keymap.set("n", "n", "", {
	callback = function()
		activate_hlslens("n")
	end,
})

keymap.set("n", "N", "", {
	callback = function()
		activate_hlslens("N")
	end,
})

local check_cursor_word = function()
	local cursor_word = vim.fn.expand("<cword>")
	local result = cursor_word == ""
	if result then
		local msg = "E348: No string under cursor"
		api.nvim_err_writeln(msg)
	end

	return result, cursor_word
end

keymap.set("n", "*", "", {
	callback = function()
		local cursor_word_empty, cursor_word = check_cursor_word()
		if cursor_word_empty then
			return
		end

		local cmd = string.format([[normal! /\v<%s>]], cursor_word)

		-- In order to say that we are pressing Enter key, instead of typing literally the character,
		-- we need to replace special notation with their internal representation.
		local escaped_enter = vim.api.nvim_replace_termcodes("<CR>", true, false, true)

		-- character `N` is used to keep the cursor when pressing `*`
		local full_cmd = cmd .. escaped_enter .. "N"
		vim.fn.execute(full_cmd)
		hlslens.start()
	end,
})
keymap.set("n", "#", "", {
	callback = function()
		local cursor_word_empty, cursor_word = check_cursor_word()
		if cursor_word_empty then
			return
		end
		local cmd = string.format([[normal! ?\v<%s>]], cursor_word)
		local escaped_enter = vim.api.nvim_replace_termcodes("<CR>", true, false, true)
		local full_cmd = cmd .. escaped_enter .. "N"
		vim.fn.execute(full_cmd)
		hlslens.start()
	end,
})


File: lua/config/live-command.lua
---
Content:
require("live-command").setup {
  enable_highlighting = true,
  inline_highlighting = true,
  commands = {
    Norm = { cmd = "norm" },
  },
}

vim.cmd("cnoreabbrev norm Norm")


File: lua/improvements.lua
---
Content:
local M = {}
local search_count_extmark_id

local function show_search_index()
	-- Only proceed if there's an active search
	local searchCount = vim.fn.searchcount({ recompute = 1, maxcount = 0 })
	if searchCount.current == 0 or searchCount.total == 0 then
		return
	end

	local namespaceId = vim.api.nvim_create_namespace("search")
	vim.api.nvim_buf_clear_namespace(0, namespaceId, 0, -1)

	search_count_extmark_id = vim.api.nvim_buf_set_extmark(0, namespaceId, vim.api.nvim_win_get_cursor(0)[1] - 1, 0, {
		virt_text = { { "[" .. searchCount.current .. "/" .. searchCount.total .. "]", "StatusLine" } },
		virt_text_pos = "eol",
	})

	-- Use pcall to handle potential errors with redraw
	pcall(function()
		vim.cmd("redraw")
	end)
end

local function clear_search_index()
	local namespaceId = vim.api.nvim_get_namespaces()["search"]
	if namespaceId and search_count_extmark_id then
		pcall(function()
			vim.api.nvim_buf_del_extmark(0, namespaceId, search_count_extmark_id)
		end)
	end
end

local function clear_search_highlight_and_index()
	clear_search_index()
	pcall(function()
		vim.cmd("nohlsearch")
	end)
end

local keys = { "n", "N", "*", "#", "g*", "g#" }
for _, key in ipairs(keys) do
	vim.keymap.set("n", key, function()
		-- Use pcall to safely execute the normal command
		pcall(function()
			vim.cmd("normal! " .. key)
		end)
		-- Only show the index if the command succeeded
		pcall(show_search_index)
	end, { noremap = true })
end

vim.keymap.set("n", "<Esc>", function()
	clear_search_highlight_and_index()
end, { noremap = true })

local group = vim.api.nvim_create_augroup("SearchIndex", { clear = true })
vim.api.nvim_create_autocmd("CmdlineLeave", {
	group = group,
	callback = function(event)
		if event.match == "/" or event.match == "?" then
			-- Delay slightly to let the search execute
			vim.defer_fn(function()
				pcall(show_search_index)
			end, 10)
		end
	end,
})

M.show_search_index = show_search_index
M.clear_search_index = clear_search_index
M.clear_search_highlight_and_index = clear_search_highlight_and_index

return M


File: lua/colorschemes.lua
---
Content:
--- This module will load a random colorscheme on nvim startup process.
local utils = require("utils")
local M = {}

-- Colorscheme to its directory name mapping, because colorscheme repo name is not necessarily
-- the same as the colorscheme name itself.
M.colorscheme_conf = {
  onedark = function()
    -- Lua
    require("onedark").setup {
      style = "darker",
    }
    require("onedark").load()
  end,
  edge = function()
    vim.g.edge_style = "default"
    vim.g.edge_enable_italic = 1
    vim.g.edge_better_performance = 1
    vim.cmd([[colorscheme edge]])
  end,
  sonokai = function()
    vim.g.sonokai_enable_italic = 1
    vim.g.sonokai_better_performance = 1
    vim.cmd([[colorscheme sonokai]])
  end,
  gruvbox_material = function()
    -- foreground option can be material, mix, or original
    vim.g.gruvbox_material_foreground = "original"
    --background option can be hard, medium, soft
    vim.g.gruvbox_material_background = "hard"
    vim.g.gruvbox_material_enable_italic = 1
    vim.g.gruvbox_material_better_performance = 1
    vim.cmd([[colorscheme gruvbox-material]])
  end,
  everforest = function()
    vim.g.everforest_background = "hard"
    vim.g.everforest_enable_italic = 1
    vim.g.everforest_better_performance = 1
    vim.cmd([[colorscheme everforest]])
  end,
  nightfox = function()
    vim.cmd([[colorscheme nordfox]])
  end,
  catppuccin = function()
    -- available option: latte, frappe, macchiato, mocha
    vim.g.catppuccin_flavour = "frappe"
    require("catppuccin").setup()
    vim.cmd([[colorscheme catppuccin]])
  end,
  onedarkpro = function()
    -- set colorscheme after options
    -- onedark_vivid does not enough contrast
    vim.cmd("colorscheme onedark_dark")
  end,
  material = function()
    vim.g.material_style = "darker"
    vim.cmd("colorscheme material")
  end,
  arctic = function()
    vim.cmd("colorscheme arctic")
  end,
  kanagawa = function()
    vim.cmd("colorscheme kanagawa-wave")
  end,
  nord = function()
    vim.cmd("colorscheme nord")
  end,
  modus = function()
    vim.cmd([[colorscheme modus]])
  end,
  jellybeans = function()
    vim.cmd([[colorscheme jellybeans]])
  end,
  github = function()
    vim.cmd([[colorscheme github_dark_default]])
  end,
  e_ink = function()
    require("e-ink").setup()
    vim.cmd.colorscheme("e-ink")
  end,
  ashen = function()
    vim.cmd([[colorscheme ashen]])
  end,
  melange = function()
    vim.cmd([[colorscheme melange]])
  end,
  makurai = function()
    vim.cmd.colorscheme("makurai_warrior")
  end,
  vague = function()
    vim.cmd([[colorscheme vague]])
  end,
  kanso = function()
    vim.cmd([[colorscheme kanso]])
  end,
}

--- Use a random colorscheme from the pre-defined list of colorschemes.
M.rand_colorscheme = function()
  local colorscheme = utils.rand_element(vim.tbl_keys(M.colorscheme_conf))

  if not vim.tbl_contains(vim.tbl_keys(M.colorscheme_conf), colorscheme) then
    local msg = "Invalid colorscheme: " .. colorscheme
    vim.notify(msg, vim.log.levels.ERROR, { title = "nvim-config" })
    return
  end

  -- Load the colorscheme and its settings
  M.colorscheme_conf[colorscheme]()
end

M.load_colorscheme = function(colorscheme)
  if not vim.tbl_contains(vim.tbl_keys(M.colorscheme_conf), colorscheme) then
    local msg = "Invalid colorscheme: " .. colorscheme
    vim.notify(msg, vim.log.levels.ERROR, { title = "nvim-config" })
    return
  end

  -- Load the colorscheme and its settings
  M.colorscheme_conf[colorscheme]()

  if vim.g.logging_level == "debug" then
    local msg = "Colorscheme: " .. colorscheme
    vim.notify(msg, vim.log.levels.DEBUG, { title = "nvim-config" })
  end
end

return M


File: lua/utils.lua
---
Content:
local fn = vim.fn
local version = vim.version
local M = {}

function M.executable(name)
	if fn.executable(name) > 0 then
		return true
	end
	return false
end

--- check whether a feature exists in Nvim
--- @param feat string the feature name, like `nvim-0.7` or `unix`.
--- @return boolean
function M.has(feat)
	if fn.has(feat) == 1 then
		return true
	end
	return false
end

--- Create a dir if it does not exist
function M.may_create_dir(dir)
	local res = fn.isdirectory(dir)
	if res == 0 then
		fn.mkdir(dir, "p")
	end
end

--- Generate random integers in the range [Low, High], inclusive,
--- adapted from https://stackoverflow.com/a/12739441/6064933
--- @param low integer the lower value for this range
--- @param high integer the higher value for this range
--- @return integer
function M.rand_int(low, high)
	-- Use lua to generate random int, see also: https://stackoverflow.com/a/20157671/6064933
	math.randomseed(os.time())
	return math.random(low, high)
end

--- Select a random element from a sequence/list.
--- @param seq any[] the sequence to choose an element
function M.rand_element(seq)
	local idx = M.rand_int(1, #seq)
	return seq[idx]
end

--- check if the current nvim version is compatible with the allowed version
--- @param expected_version string
--- @return boolean
function M.is_compatible_version(expected_version)
	-- check if we have the latest stable version of nvim
	local expect_ver = version.parse(expected_version)
	local actual_ver = vim.version()
	if expect_ver == nil then
		local msg = string.format("Unsupported version string: %s", expected_version)
		vim.api.nvim_echo({ { msg } }, true, { err = true })
		return false
	end
	local result = version.cmp(expect_ver, actual_ver)
	if result ~= 0 then
		local ver = string.format("%s.%s.%s", actual_ver.major, actual_ver.minor, actual_ver.patch)
		local msg = string.format(
			"Expect nvim version %s, but your current nvim version is %s. Use at your own risk!",
			expected_version,
			ver
		)
		vim.api.nvim_echo({ { msg } }, true, { err = true })
	end
	return true
end

-- Treesitter utils
local has_treesitter, ts = pcall(require, "vim.treesitter")
local _, query = pcall(require, "vim.treesitter.query")

local MATH_NODES = {
	displayed_equation = true,
	inline_formula = true,
	math_environment = true,
}

local function get_node_at_cursor()
	local cursor = vim.api.nvim_win_get_cursor(0)
	local cursor_range = { cursor[1] - 1, cursor[2] }
	local buf = vim.api.nvim_get_current_buf()
	local ok, parser = pcall(ts.get_parser, buf, "latex")
	if not ok or not parser then
		return
	end
	local root_tree = parser:parse()[1]
	local root = root_tree and root_tree:root()
	if not root then
		return
	end
	return root:named_descendant_for_range(cursor_range[1], cursor_range[2], cursor_range[1], cursor_range[2])
end

function M.in_comment()
	if has_treesitter then
		local node = get_node_at_cursor()
		while node do
			if node:type() == "comment" then
				return true
			end
			node = node:parent()
		end
		return false
	end
end

function M.in_mathzone()
	if has_treesitter then
		local node = get_node_at_cursor()
		while node do
			-- Debug: imprime el tipo de nodo
			print("Node type:", node:type())
			if MATH_NODES[node:type()] then
				return true
			end
			node = node:parent()
		end
		return false
	end
	return false
end

--- check if we are inside a git repo
--- @return boolean
function M.inside_git_repo()
	local result = vim.system({ "git", "rev-parse", "--is-inside-work-tree" }, { text = true }):wait()
	if result.code ~= 0 then
		return false
	end

	-- Manually trigger a special user autocmd InGitRepo (used lazyloading.
	vim.cmd([[doautocmd User InGitRepo]])

	return true
end

function M.get_python_info()
	local venv = os.getenv("VIRTUAL_ENV")
	local python_exe = "python"

	if venv then
		if vim.fn.has("win32") == 1 then
			python_exe = venv .. "\\Scripts\\python.exe"
		else
			python_exe = venv .. "/bin/python"
		end
	end

	-- Detect Python version
	local version_cmd = python_exe .. " --version"
	local handle = io.popen(version_cmd .. " 2>&1")
	local result = handle:read("*a")
	handle:close()

	-- Parse the Python version (format: "Python 3.x.y")
	local major, minor = result:match("Python (%d+)%.(%d+)")
	local py_version = major and minor and ("py" .. major .. minor) or "py310" -- Default to 3.10 if detection fails

	return {
		exe = python_exe,
		version = py_version,
		venv = venv,
	}
end

-- Function to get command from venv if available
function M.get_cmd_from_venv(cmd)
	return function()
		local venv = os.getenv("VIRTUAL_ENV")
		if venv then
			if vim.fn.has("win32") == 1 then
				return venv .. "\\Scripts\\" .. cmd .. ".exe"
			else
				return venv .. "/bin/" .. cmd
			end
		end
		return cmd
	end
end

function M.open_url_under_cursor()
	local line = vim.api.nvim_get_current_line()

	-- Imprimir la lnea actual para depurar
	print("Current line:", line)

	-- Buscar enlaces Markdown
	local markdown_pattern = "%[(.-)%]%((.-)%)"
	for text, url in line:gmatch(markdown_pattern) do
		print("Found Markdown link:", text, "with URL:", url)

		-- Verificar que la URL es vlida
		if url and url:match("^https?://") then
			local cmd
			if vim.fn.has("unix") == 1 then
				if vim.fn.executable("firefox") == 1 then
					cmd = string.format("firefox '%s' &", url)
					print("Command to execute:", cmd)
				elseif vim.fn.executable("xdg-open") == 1 then
					cmd = string.format("xdg-open '%s' &", url)
					print("Command to execute:", cmd)
				end
			elseif vim.fn.has("mac") == 1 then
				cmd = string.format("open -a Firefox '%s'", url)
			elseif vim.fn.has("win32") == 1 or vim.fn.has("win64") == 1 then
				cmd = string.format('start firefox "%s"', url)
			end

			if cmd then
				print("Executing command:", cmd)
				local result = vim.fn.system(cmd)
				print("Command result:", result)
				vim.notify("Opening: " .. url, vim.log.levels.INFO)
				return true
			else
				vim.notify("No browser found to open URL", vim.log.levels.ERROR)
				return false
			end
		end
	end

	-- Buscar URLs simples si no se encontr un enlace Markdown
	local url_pattern = "https?://[%w%-%._~:/%?#%[%]@!%$&'%(%)%*%+,;=%%]+"
	for url in line:gmatch(url_pattern) do
		print("Found URL:", url)

		local cmd
		if vim.fn.has("unix") == 1 then
			if vim.fn.executable("firefox") == 1 then
				cmd = string.format("firefox '%s' &", url)
				print("Command to execute:", cmd)
			elseif vim.fn.executable("xdg-open") == 1 then
				cmd = string.format("xdg-open '%s' &", url)
				print("Command to execute:", cmd)
			end
		elseif vim.fn.has("mac") == 1 then
			cmd = string.format("open -a Firefox '%s'", url)
		elseif vim.fn.has("win32") == 1 or vim.fn.has("win64") == 1 then
			cmd = string.format('start firefox "%s"', url)
		end

		if cmd then
			print("Executing command:", cmd)
			local result = vim.fn.system(cmd)
			print("Command result:", result)
			vim.notify("Opening: " .. url, vim.log.levels.INFO)
			return true
		else
			vim.notify("No browser found to open URL", vim.log.levels.ERROR)
			return false
		end
	end

	-- Si llegamos aqu, no se encontr ningn enlace
	vim.notify("No URL found in the current line", vim.log.levels.WARN)
	return false
end

return M


File: lua/custom-autocmd.lua
---
Content:
local fn = vim.fn
local api = vim.api

local utils = require("utils")

-- Display a message when the current file is not in utf-8 format.
-- Note that we need to use `unsilent` command here because of this issue:
-- https://github.com/vim/vim/issues/4379
api.nvim_create_autocmd({ "BufRead" }, {
  pattern = "*",
  group = api.nvim_create_augroup("non_utf8_file", { clear = true }),
  callback = function()
    if vim.bo.fileencoding ~= "utf-8" then
      vim.notify("File not in UTF-8 format!", vim.log.levels.WARN, { title = "nvim-config" })
    end
  end,
})

api.nvim_create_autocmd("Filetype", {
  pattern = "markdown",
  callback = function()
    vim.opt.conceallevel = 2
  end,
})

-- highlight yanked region, see `:h lua-highlight`
local yank_group = api.nvim_create_augroup("highlight_yank", { clear = true })
api.nvim_create_autocmd({ "TextYankPost" }, {
  pattern = "*",
  group = yank_group,
  callback = function()
    vim.hl.on_yank { higroup = "YankColor", timeout = 300 }
  end,
})

api.nvim_create_autocmd({ "CursorMoved" }, {
  pattern = "*",
  group = yank_group,
  callback = function()
    vim.g.current_cursor_pos = vim.fn.getcurpos()
  end,
})

api.nvim_create_autocmd("TextYankPost", {
  pattern = "*",
  group = yank_group,
  callback = function(ev)
    if vim.v.event.operator == "y" then
      vim.fn.setpos(".", vim.g.current_cursor_pos)
    end
  end,
})

-- Auto-create dir when saving a file, in case some intermediate directory does not exist
api.nvim_create_autocmd({ "BufWritePre" }, {
  pattern = "*",
  group = api.nvim_create_augroup("auto_create_dir", { clear = true }),
  callback = function(ctx)
    local dir = fn.fnamemodify(ctx.file, ":p:h")
    utils.may_create_dir(dir)
  end,
})

-- Automatically reload the file if it is changed outside of Nvim, see https://unix.stackexchange.com/a/383044/221410.
-- It seems that `checktime` does not work in command line. We need to check if we are in command
-- line before executing this command, see also https://vi.stackexchange.com/a/20397/15292 .
api.nvim_create_augroup("auto_read", { clear = true })

api.nvim_create_autocmd({ "FileChangedShellPost" }, {
  pattern = "*",
  group = "auto_read",
  callback = function()
    vim.notify("File changed on disk. Buffer reloaded!", vim.log.levels.WARN, { title = "nvim-config" })
  end,
})

api.nvim_create_autocmd({ "FocusGained", "CursorHold" }, {
  pattern = "*",
  group = "auto_read",
  callback = function()
    if fn.getcmdwintype() == "" then
      vim.cmd("checktime")
    end
  end,
})

-- Resize all windows when we resize the terminal
api.nvim_create_autocmd("VimResized", {
  group = api.nvim_create_augroup("win_autoresize", { clear = true }),
  desc = "autoresize windows on resizing operation",
  command = "wincmd =",
})

-- Do not use smart case in command line mode, extracted from https://vi.stackexchange.com/a/16511/15292.
api.nvim_create_augroup("dynamic_smartcase", { clear = true })
api.nvim_create_autocmd("CmdLineEnter", {
  group = "dynamic_smartcase",
  pattern = ":",
  callback = function()
    vim.o.smartcase = false
  end,
})

api.nvim_create_autocmd("CmdLineLeave", {
  group = "dynamic_smartcase",
  pattern = ":",
  callback = function()
    vim.o.smartcase = true
  end,
})

api.nvim_create_autocmd("TermOpen", {
  group = api.nvim_create_augroup("term_start", { clear = true }),
  pattern = "*",
  callback = function()
    -- Do not use number and relative number for terminal inside nvim
    vim.wo.relativenumber = false
    vim.wo.number = false

    -- Go to insert mode by default to start typing command
    vim.cmd("startinsert")
  end,
})

local number_toggle_group = api.nvim_create_augroup("numbertoggle", { clear = true })
api.nvim_create_autocmd({ "BufEnter", "FocusGained", "InsertLeave", "WinEnter" }, {
  pattern = "*",
  group = number_toggle_group,
  desc = "togger line number",
  callback = function()
    if vim.wo.number then
      vim.wo.relativenumber = true
    end
  end,
})

api.nvim_create_autocmd({ "BufLeave", "FocusLost", "InsertEnter", "WinLeave" }, {
  group = number_toggle_group,
  desc = "togger line number",
  callback = function()
    if vim.wo.number then
      vim.wo.relativenumber = false
    end
  end,
})

api.nvim_create_autocmd("ColorScheme", {
  group = api.nvim_create_augroup("custom_highlight", { clear = true }),
  pattern = "*",
  desc = "Define or overrride some highlight groups",
  callback = function()
    -- For yank highlight
    vim.api.nvim_set_hl(0, "YankColor", { fg = "#34495E", bg = "#2ECC71", ctermfg = 59, ctermbg = 41 })

    -- For cursor colors
    vim.api.nvim_set_hl(0, "Cursor", { fg = "black", bg = "#00c918", bold = true })
    vim.api.nvim_set_hl(0, "Cursor2", { fg = "red", bg = "red" })

    -- For floating windows border highlight
    vim.api.nvim_set_hl(0, "YankColor", { fg = "#34495E", bg = "#2ECC71", ctermfg = 59, ctermbg = 41 })

    -- highlight for matching parentheses
    vim.api.nvim_set_hl(0, "MatchParen", { bold = true, underline = true })
  end,
})

api.nvim_create_autocmd("BufEnter", {
  pattern = "*",
  group = api.nvim_create_augroup("auto_close_win", { clear = true }),
  desc = "Quit Nvim if we have only one window, and its filetype match our pattern",
  callback = function(ev)
    local quit_filetypes = { "qf", "vista", "NvimTree" }

    local should_quit = true
    local tabwins = api.nvim_tabpage_list_wins(0)

    for _, win in pairs(tabwins) do
      local buf = api.nvim_win_get_buf(win)
      local bf = fn.getbufvar(buf, "&filetype")

      if fn.index(quit_filetypes, bf) == -1 then
        should_quit = false
      end
    end

    if should_quit then
      vim.cmd("qall")
    end
  end,
})

api.nvim_create_autocmd({ "VimEnter", "DirChanged" }, {
  group = api.nvim_create_augroup("git_repo_check", { clear = true }),
  pattern = "*",
  desc = "check if we are inside Git repo",
  callback = function()
    utils.inside_git_repo()
  end,
})

-- ref: https://vi.stackexchange.com/a/169/15292
api.nvim_create_autocmd("BufReadPre", {
  group = api.nvim_create_augroup("large_file", { clear = true }),
  pattern = "*",
  desc = "optimize for large file",
  callback = function(ev)
    local file_size_limit = 524288 -- 0.5MB
    local f = ev.file

    if fn.getfsize(f) > file_size_limit or fn.getfsize(f) == -2 then
      vim.o.eventignore = "all"
      -- show ruler
      vim.o.ruler = true

      vim.wo.relativenumber = false
      vim.wo.number = false

      vim.bo.swapfile = false
      vim.bo.bufhidden = "unload"
      vim.bo.undolevels = -1
    end
  end,
})


File: lua/plugin_specs.lua
---
Content:
local utils = require("utils")

local plugin_dir = vim.fn.stdpath("data") .. "/lazy"
local lazypath = plugin_dir .. "/lazy.nvim"

if not vim.uv.fs_stat(lazypath) then
	vim.fn.system({
		"git",
		"clone",
		"--filter=blob:none",
		"https://github.com/folke/lazy.nvim.git",
		"--branch=stable",
		lazypath,
	})
end
vim.opt.rtp:prepend(lazypath)

-- check if firenvim is active
local firenvim_not_active = function()
	return not vim.g.started_by_firenvim
end

local plugin_specs = {
	-- auto-completion engine
	{ "hrsh7th/cmp-nvim-lsp", lazy = true },
	{ "hrsh7th/cmp-path", lazy = true },
	{ "hrsh7th/cmp-buffer", lazy = true },
	{ "hrsh7th/cmp-omni", lazy = true },
	{ "quangnguyen30192/cmp-nvim-ultisnips", lazy = true },
	{
		"hrsh7th/nvim-cmp",
		name = "nvim-cmp",
		event = "VeryLazy",
		dependencies = {
			"echasnovski/mini.icons",
		},
		config = function()
			require("config.nvim-cmp")
		end,
	},

	{
		"mfussenegger/nvim-lint",
		event = { "BufReadPre", "BufNewFile" },
	},

	{
		"dundalek/bloat.nvim",
		cmd = "Bloat",
	},

	{
		"dnlhc/glance.nvim",
		config = function()
			require("config.glance")
		end,
		envnt = "VeryLazy",
	},
	{
		"nvim-treesitter/nvim-treesitter",
		enabled = function()
			if vim.g.is_mac or vim.g.is_linux then
				return true
			end
			return false
		end,
		lazy = true,
		build = ":TSUpdate",
		config = function()
			require("config.treesitter")
		end,
	},

	{
		"nvim-treesitter/nvim-treesitter-textobjects",
		event = "VeryLazy",
		branch = "master",
		config = function()
			require("config.treesitter-textobjects")
		end,
	},

	{ "machakann/vim-swap", event = "VeryLazy" },

	-- IDE for Lisp
	-- 'kovisoft/slimv'
	{
		"vlime/vlime",
		enabled = function()
			return utils.executable("sbcl")
		end,
		config = function(plugin)
			vim.opt.rtp:append(plugin.dir .. "/vim")
		end,
		ft = { "lisp" },
	},

	-- Super fast buffer jump
	{
		"smoka7/hop.nvim",
		keys = { "f" },
		config = function()
			require("config.nvim_hop")
		end,
	},

	{
		"nvim-telescope/telescope.nvim",
		cmd = "Telescope",
		dependencies = {
			"nvim-telescope/telescope-symbols.nvim",
		},
	},

	{
		"ibhagwan/fzf-lua",
		config = function()
			-- calling `setup` is optional for customization
			require("config.fzf-lua")
		end,
	},
	{
		"MeanderingProgrammer/markdown.nvim",
		main = "render-markdown",
		ft = { "markdown" },
		opts = {},
	},

	-- A list of colorscheme plugin you may want to try. Find what suits you.
	{ "shaunsingh/nord.nvim", lazy = true },
	{
		"rockyzhang24/arctic.nvim",
		dependencies = { "rktjmp/lush.nvim" },
		name = "arctic",
		branch = "v2",
	},
	{ "rebelot/kanagawa.nvim", lazy = true },
	{ "miikanissi/modus-themes.nvim", priority = 1000 },
	{ "wtfox/jellybeans.nvim", priority = 1000 },
	{ "projekt0n/github-nvim-theme", name = "github-theme" },
	{ "e-ink-colorscheme/e-ink.nvim", priority = 1000 },
	{ "ficcdaf/ashen.nvim", priority = 1000 },
	{ "savq/melange-nvim", priority = 1000 },
	{ "Skardyy/makurai-nvim", priority = 1000 },
	{ "vague2k/vague.nvim", priority = 1000 },
	{ "webhooked/kanso.nvim", priority = 1000 },

	-- plugins to provide nerdfont icons
	{
		"echasnovski/mini.icons",
		version = false,
		config = function()
			-- this is the compatibility fix for plugins that only support nvim-web-devicons
			require("mini.icons").mock_nvim_web_devicons()
			require("mini.icons").tweak_lsp_kind()
		end,
		lazy = false,
	},

	{
		"nvim-lualine/lualine.nvim",
		event = "BufRead",
		cond = firenvim_not_active,
		config = function()
			require("config.lualine")
		end,
	},

	{
		"akinsho/bufferline.nvim",
		event = { "BufEnter" },
		cond = firenvim_not_active,
		config = function()
			require("config.bufferline")
		end,
	},

	-- fancy start screen
	{
		"nvimdev/dashboard-nvim",
		cond = firenvim_not_active,
		config = function()
			require("config.dashboard-nvim")
		end,
	},

	{
		"echasnovski/mini.indentscope",
		version = false,
		config = function()
			local mini_indent = require("mini.indentscope")
			mini_indent.setup({
				draw = {
					animation = mini_indent.gen_animation.none(),
				},
				symbol = "",
			})
		end,
	},
	{
		"luukvbaal/statuscol.nvim",
		opts = {},
		config = function()
			require("config.nvim-statuscol")
		end,
	},
	{
		"kevinhwang91/nvim-ufo",
		dependencies = "kevinhwang91/promise-async",
		event = "VeryLazy",
		opts = {},
		init = function()
			vim.o.foldcolumn = "1" -- '0' is not bad
			vim.o.foldlevel = 99 -- Using ufo provider need a large value, feel free to decrease the value
			vim.o.foldlevelstart = 99
			vim.o.foldenable = true
		end,
		config = function()
			require("config.nvim_ufo")
		end,
	},
	-- Highlight URLs inside vim
	{ "itchyny/vim-highlighturl", event = "BufReadPost" },

	{ "nvim-lua/plenary.nvim", lazy = true },

	-- notification plugin
	{
		"rcarriga/nvim-notify",
		event = "VeryLazy",
		config = function()
			require("config.nvim-notify")
		end,
	},

	-- Only install these plugins if ctags are installed on the system
	-- show file tags in vim window
	{
		"liuchengxu/vista.vim",
		enabled = function()
			return utils.executable("ctags")
		end,
		cmd = "Vista",
	},

	-- Snippet engine and snippet template

	{
		"SirVer/ultisnips",
		dependencies = {
			"honza/vim-snippets",
		},
		event = "InsertEnter",
		config = function()
			require("config.ultisnips").setup()
		end,
	},

	-- Automatic insertion and deletion of a pair of characters
	{
		"kylechui/nvim-surround",
		version = "*",
		event = "InsertEnter",
		config = function()
			require("config.nvim-surround")
		end,
	},

	-- Comment plugin
	{ "tpope/vim-commentary", keys = {
		{ "gc", mode = "n" },
		{ "gc", mode = "v" },
	} },

	-- Multiple cursor plugin like Sublime Text?
	{ "mg979/vim-visual-multi" },

	-- Show undo history visually
	{ "simnalamburt/vim-mundo", cmd = { "MundoToggle", "MundoShow" } },

	-- Manage your yank history
	{
		"gbprod/yanky.nvim",
		config = function()
			require("config.yanky")
		end,
		cmd = "YankyRingHistory",
	},

	-- Handy unix command inside Vim (Rename, Move etc.)
	{ "tpope/vim-eunuch", cmd = { "Rename", "Delete" } },

	-- Repeat vim motions
	{ "tpope/vim-repeat", event = "VeryLazy" },

	{ "nvim-zh/better-escape.vim", event = { "InsertEnter" } },

	{
		"lyokha/vim-xkbswitch",
		enabled = function()
			return vim.g.is_mac and utils.executable("xkbswitch")
		end,
		event = { "InsertEnter" },
	},

	{
		"Neur1n/neuims",
		enabled = function()
			return vim.g.is_win
		end,
		event = { "InsertEnter" },
	},

	-- Git command inside vim
	{
		"tpope/vim-fugitive",
		event = "User InGitRepo",
		config = function()
			require("config.fugitive")
		end,
	},

	-- Better git log display
	{ "rbong/vim-flog", cmd = { "Flog" } },
	{
		"akinsho/git-conflict.nvim",
		version = "*",
		event = "VeryLazy",
		config = function()
			require("config.git-conflict")
		end,
	},
	{
		"ruifm/gitlinker.nvim",
		event = "User InGitRepo",
		config = function()
			require("config.git-linker")
		end,
	},

	-- Show git change (change, delete, add) signs in vim sign column
	{
		"lewis6991/gitsigns.nvim",
		config = function()
			require("config.gitsigns")
		end,
	},

	{
		"sindrets/diffview.nvim",
		cmd = { "DiffviewOpen" },
	},

	{
		"kevinhwang91/nvim-bqf",
		ft = "qf",
		config = function()
			require("config.bqf")
		end,
	},

	-- Another markdown plugin
	{ "preservim/vim-markdown", ft = { "markdown" } },

	-- Faster footnote generation
	{ "vim-pandoc/vim-markdownfootnotes", ft = { "markdown" } },

	-- Vim tabular plugin for manipulate tabular, required by markdown plugins
	{ "godlygeek/tabular", ft = { "markdown" } },

	-- Markdown previewing (only for Mac and Windows)
	{
		"iamcco/markdown-preview.nvim",
		enabled = function()
			return vim.g.is_win or vim.g.is_mac
		end,
		build = "cd app && npm install && git restore .",
		ft = { "markdown" },
	},

	{
		"rhysd/vim-grammarous",
		enabled = function()
			return vim.g.is_mac
		end,
		ft = { "markdown" },
	},

	{ "chrisbra/unicode.vim", keys = { "ga" }, cmd = { "UnicodeSearch" } },

	-- Additional powerful text object for vim, this plugin should be studied
	-- carefully to use its full power
	{ "wellle/targets.vim", event = "VeryLazy" },

	-- Plugin to manipulate character pairs quickly
	{ "machakann/vim-sandwich", event = "VeryLazy" },

	-- Only use these plugin on Windows and Mac and when LaTeX is installed
	{
		"lervag/vimtex",
		ft = { "tex" },
		enabled = function()
			return utils.executable("latex")
		end,
		config = function()
			vim.g.vimtex_view_method = "zathura"
			vim.g.vimtex_compiler_method = "latexmk"
			vim.g.vimtex_quickfix_mode = 0
			vim.g.vimtex_quickfix_enabled = 1
			vim.g.vimtex_syntax_enabled = 0
			--vim.g.tex_conceal = "abdmg"
			vim.g.vimtex_filetypes = { "tex" }
			vim.g.vimtex_mappings_disable = { ["n"] = { "K" } }
			vim.opt.conceallevel = 2
		end,
	},

	{
		"epwalsh/obsidian.nvim",
		lazy = "VeryLazy",
		ft = "markdown",
		dependencies = {
			"nvim-lua/plenary.nvim",
			"nvim-telescope/telescope.nvim",
			"hrsh7th/nvim-cmp",
		},
		config = function()
			require("config.obsidian-nvim")
		end,
	},

	-- Since tmux is only available on Linux and Mac, we only enable these plugins
	-- for Linux and Mac
	-- .tmux.conf syntax highlighting and setting check
	{
		"tmux-plugins/vim-tmux",
		enabled = function()
			return utils.executable("tmux")
		end,
		ft = { "tmux" },
	},

	{ "tpope/vim-scriptease", cmd = { "Scriptnames", "Messages", "Verbose" } },

	-- Asynchronous command execution
	{ "skywind3000/asyncrun.vim", lazy = true, cmd = { "AsyncRun" } },
	{ "cespare/vim-toml", ft = { "toml" }, branch = "main" },

	-- Edit text area in browser using nvim
	{
		"glacambre/firenvim",
		enabled = function()
			return vim.g.is_win or vim.g.is_mac
		end,
		-- it seems that we can only call the firenvim function directly.
		-- Using vim.fn or vim.cmd to call this function will fail.
		build = function()
			local firenvim_path = plugin_dir .. "/firenvim"
			vim.opt.runtimepath:append(firenvim_path)
			vim.cmd("runtime! firenvim.vim")

			-- macOS will reset the PATH when firenvim starts a nvim process, causing the PATH variable to change unexpectedly.
			-- Here we are trying to get the correct PATH and use it for firenvim.
			-- See also https://github.com/glacambre/firenvim/blob/master/TROUBLESHOOTING.md#make-sure-firenvims-path-is-the-same-as-neovims
			local path_env = vim.env.PATH
			local prologue = string.format('export PATH="%s"', path_env)
			-- local prologue = "echo"
			local cmd_str = string.format(":call firenvim#install(0, '%s')", prologue)
			vim.cmd(cmd_str)
		end,
	},
	-- Debugger plugin
	{
		"sakhnik/nvim-gdb",
		enabled = function()
			return vim.g.is_win or vim.g.is_linux
		end,
		build = { "bash install.sh" },
		lazy = true,
	},

	-- Session management plugin
	{ "tpope/vim-obsession", cmd = "Obsession" },

	{
		"ojroques/vim-oscyank",
		enabled = function()
			return vim.g.is_linux
		end,
		cmd = { "OSCYank", "OSCYankReg" },
	},

	-- The missing auto-completion for cmdline!
	{
		"gelguy/wilder.nvim",
		build = ":UpdateRemotePlugins",
	},

	-- showing keybindings
	{
		"folke/which-key.nvim",
		event = "VeryLazy",
		config = function()
			require("config.which-key")
		end,
	},

	{
		"folke/snacks.nvim",
		priority = 1000,
		lazy = false,
		opts = {
			input = {
				enabled = true,
				win = {
					relative = "cursor",
					backdrop = true,
				},
			},
		},
	},

	-- show and trim trailing whitespaces
	{ "jdhao/whitespace.nvim", event = "VeryLazy" },

	{
		"stevearc/oil.nvim",
		lazy = false,
		config = function()
			require("config.oil")
		end,
	},

	{
		"zbirenbaum/copilot.lua",
		event = "VeryLazy",
		config = function()
			require("config.copilot")
		end,
	},
	{
		"j-hui/fidget.nvim",
		event = "BufRead",
		tag = "legacy",
		config = function()
			require("config.fidget-nvim")
		end,
	},
	{
		"folke/lazydev.nvim",
		ft = "lua", -- only load on lua files
		opts = {
			library = {
				-- See the configuration section for more details
				-- Load luvit types when the `vim.uv` word is found
				{ path = "${3rd}/luv/library", words = { "vim%.uv" } },
			},
		},
	},
	{
		"smjonas/live-command.nvim",
		-- live-command supports semantic versioning via Git tags
		-- tag = "2.*",
		event = "VeryLazy",
		config = function()
			require("config.live-command")
		end,
		event = "VeryLazy",
	},
	{
		"nvim-neorg/neorg",
		ft = "norg",
		dependencies = {
			"nvim-neorg/lua-utils.nvim",
		},
		config = function()
			require("config.neorg")
		end,
	},
	{
		-- show hint for code actions, the user can also implement code actions themselves,
		-- see discussion here: https://github.com/neovim/neovim/issues/14869
		"kosayoda/nvim-lightbulb",
		config = function()
			require("config.lightbulb")
		end,
		event = "LspAttach",
	},

	{
		"Bekaboo/dropbar.nvim",
		event = "VeryLazy",
	},
	{
		"catgoose/nvim-colorizer.lua",
		event = "BufReadPre",
		opts = { -- set to setup table
		},
	},
}

---@diagnostic disable-next-line: missing-fields
require("lazy").setup({
	spec = plugin_specs,
	ui = {
		border = "rounded",
		title = "Plugin Manager",
		title_pos = "center",
	},
	rocks = {
		enabled = false,
		hererocks = false,
	},
})


File: lua/mappings.lua
---
Content:
local keymap = vim.keymap
local uv = vim.uv

-- Save key strokes (now we do not need to press shift to enter command mode).
keymap.set({ "n", "x" }, ";", ":")

-- Turn the word under cursor to upper case
keymap.set("i", "<c-u>", "<Esc>viwUea")

-- Turn the current word into title case
keymap.set("i", "<c-t>", "<Esc>b~lea")

-- Paste non-linewise text above or below current line, see https://stackoverflow.com/a/1346777/6064933
keymap.set("n", "<leader>p", "m`o<ESC>p``", { desc = "paste below current line" })
keymap.set("n", "<leader>P", "m`O<ESC>p``", { desc = "paste above current line" })

-- Shortcut for faster save and quit
--keymap.set("n", "<leader>w", "<cmd>update<cr>", { silent = true, desc = "save buffer" })

-- Saves the file if modified and quit
keymap.set("n", "<leader>q", "<cmd>x<cr>", { silent = true, desc = "quit current window" })

-- Quit all opened buffers
keymap.set("n", "<leader>Q", "<cmd>qa!<cr>", { silent = true, desc = "quit nvim" })

keymap.set("n", [[\x]], "<cmd>windo lclose <bar> cclose <cr>", {
  silent = true,
  desc = "close qf and location list",
})

-- Delete a buffer, without closing the window, see https://stackoverflow.com/q/4465095/6064933
keymap.set("n", [[\d]], "<cmd>bprevious <bar> bdelete #<cr>", {
  silent = true,
  desc = "delete current buffer",
})

keymap.set("n", [[\D]], function()
  local buf_ids = vim.api.nvim_list_bufs()
  local cur_buf = vim.api.nvim_win_get_buf(0)

  for _, buf_id in pairs(buf_ids) do
    -- do not Delete unlisted buffers, which may lead to unexpected errors
    if vim.api.nvim_get_option_value("buflisted", { buf = buf_id }) and buf_id ~= cur_buf then
      vim.api.nvim_buf_delete(buf_id, { force = true })
    end
  end
end, {
  desc = "delete other buffers",
})

keymap.set("n", "<space>D", "<cmd>bprevious <bar> bdelete #<cr>", {
  silent = true,
  desc = "delete current buffer",
})

-- Insert a blank line below or above current line (do not move the cursor),
-- see https://stackoverflow.com/a/16136133/6064933
keymap.set("n", "<space>o", "printf('m`%so<ESC>``', v:count1)", {
  expr = true,
  desc = "insert line below",
})

keymap.set("n", "<space>O", "printf('m`%sO<ESC>``', v:count1)", {
  expr = true,
  desc = "insert line above",
})

-- Move the cursor based on physical lines, not the actual lines.
keymap.set("n", "j", "v:count == 0 ? 'gj' : 'j'", { expr = true })
keymap.set("n", "k", "v:count == 0 ? 'gk' : 'k'", { expr = true })
keymap.set("n", "^", "g^")
keymap.set("n", "0", "g0")

-- Do not include white space characters when using $ in visual mode,
-- see https://vi.stackexchange.com/q/12607/15292
keymap.set("x", "$", "g_")

-- Go to start or end of line easier
keymap.set({ "n", "x" }, "H", "^")
keymap.set({ "n", "x" }, "L", "g_")

-- Continuous visual shifting (does not exit Visual mode), `gv` means
-- to reselect previous visual area, see https://superuser.com/q/310417/736190
keymap.set("x", "<", "<gv")
keymap.set("x", ">", ">gv")

-- Edit and reload nvim config file quickly
keymap.set("n", "<leader>co", "<cmd>tabnew $MYVIMRC <bar> tcd %:h<cr>", {
  silent = true,
  desc = "open init.lua",
})

keymap.set("n", "<leader>cr", function()
  vim.cmd([[
      update $MYVIMRC
      source $MYVIMRC
    ]])
  vim.notify("Nvim config successfully reloaded!", vim.log.levels.INFO, { title = "nvim-config" })
end, {
  silent = true,
  desc = "reload init.lua",
})

-- Reselect the text that has just been pasted, see also https://stackoverflow.com/a/4317090/6064933.
keymap.set("n", "<leader>v", "printf('`[%s`]', getregtype()[0])", {
  expr = true,
  desc = "reselect last pasted area",
})

-- Always use very magic mode for searching
keymap.set("n", "/", [[/\v]])

-- Search in selected region
-- xnoremap / :<C-U>call feedkeys('/\%>'.(line("'<")-1).'l\%<'.(line("'>")+1)."l")<CR>

-- Change current working directory locally and print cwd after that,
-- see https://vim.fandom.com/wiki/Set_working_directory_to_the_current_file
keymap.set("n", "<leader>cd", "<cmd>lcd %:p:h<cr><cmd>pwd<cr>", { desc = "change cwd" })

-- Use Esc to quit builtin terminal
keymap.set("t", "<Esc>", [[<c-\><c-n>]])

-- Toggle spell checking
keymap.set("n", "<F11>", "<cmd>set spell!<cr>", { desc = "toggle spell" })
keymap.set("i", "<F11>", "<c-o><cmd>set spell!<cr>", { desc = "toggle spell" })

-- Change text without putting it into the vim register,
-- see https://stackoverflow.com/q/54255/6064933
keymap.set("n", "c", '"_c')
keymap.set("n", "C", '"_C')
keymap.set("n", "cc", '"_cc')
keymap.set("x", "c", '"_c')

-- Remove trailing whitespace characters
keymap.set("n", "<leader><space>", "<cmd>StripTrailingWhitespace<cr>", { desc = "remove trailing space" })

-- Copy entire buffer.
keymap.set("n", "<leader>y", "<cmd>%yank<cr>", { desc = "yank entire buffer" })

-- Copy file path to clipboard
keymap.set(
  "n",
  "<space>yp",
  '"+yy:let @+=expand("%:p")<CR>:echo "Copied path: " . @+<CR>',
  { desc = "copy file path", silent = true }
)

-- Copy file name to clipboard
keymap.set(
  "n",
  "<space>yn",
  '"+yy:let @+=expand("%:t")<CR>:echo "Copied filename: " . @+<CR>',
  { desc = "copy file name", silent = true }
)

-- Move between buffers
vim.api.nvim_set_keymap(
  "n",
  "<Tab>",
  ":if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR>:bnext<CR>",
  { noremap = true, silent = true }
)
vim.api.nvim_set_keymap(
  "n",
  "<S-Tab>",
  ":if &modifiable && !&readonly && &modified <CR> :write<CR> :endif<CR>:bprevious<CR>",
  { noremap = true, silent = true }
)

-- Toggle cursor column
keymap.set("n", "<leader>cl", "<cmd>call utils#ToggleCursorCol()<cr>", { desc = "toggle cursor column" })

-- Move current line up and down
keymap.set("n", "<A-k>", '<cmd>call utils#SwitchLine(line("."), "up")<cr>', { desc = "move line up" })
keymap.set("n", "<A-j>", '<cmd>call utils#SwitchLine(line("."), "down")<cr>', { desc = "move line down" })

-- Move current visual-line selection up and down
keymap.set("x", "<A-k>", '<cmd>call utils#MoveSelection("up")<cr>', { desc = "move selection up" })

keymap.set("x", "<A-j>", '<cmd>call utils#MoveSelection("down")<cr>', { desc = "move selection down" })

-- Replace visual selection with text in register, but not contaminate the register,
-- see also https://stackoverflow.com/q/10723700/6064933.
keymap.set("x", "p", '"_c<Esc>p')

-- Go to a certain buffer
keymap.set("n", "gb", '<cmd>call buf_utils#GoToBuffer(v:count, "forward")<cr>', {
  desc = "go to buffer (forward)",
})
keymap.set("n", "gB", '<cmd>call buf_utils#GoToBuffer(v:count, "backward")<cr>', {
  desc = "go to buffer (backward)",
})

-- Switch windows
keymap.set("n", "<left>", "<c-w>h")
keymap.set("n", "<Right>", "<C-W>l")
keymap.set("n", "<Up>", "<C-W>k")
keymap.set("n", "<Down>", "<C-W>j")

-- Text objects for URL
keymap.set({ "x", "o" }, "iu", "<cmd>call text_obj#URL()<cr>", { desc = "URL text object" })

-- Text objects for entire buffer
keymap.set({ "x", "o" }, "iB", ":<C-U>call text_obj#Buffer()<cr>", { desc = "buffer text object" })

-- Do not move my cursor when joining lines.
keymap.set("n", "J", function()
  vim.cmd([[
      normal! mzJ`z
      delmarks z
    ]])
end, {
  desc = "join lines without moving cursor",
})

keymap.set("n", "gJ", function()
  -- we must use `normal!`, otherwise it will trigger recursive mapping
  vim.cmd([[
      normal! mzgJ`z
      delmarks z
    ]])
end, {
  desc = "join lines without moving cursor",
})

-- Break inserted text into smaller undo units when we insert some punctuation chars.
local undo_ch = { ",", ".", "!", "?", ";", ":" }
for _, ch in ipairs(undo_ch) do
  keymap.set("i", ch, ch .. "<c-g>u")
end

-- insert semicolon in the end
keymap.set("i", "<A-;>", "<Esc>miA;<Esc>`ii")

-- Go to the beginning and end of current line in insert mode quickly
keymap.set("i", "<C-A>", "<HOME>")
keymap.set("i", "<C-E>", "<END>")

-- Go to beginning of command in command-line mode
keymap.set("c", "<C-A>", "<HOME>")

-- Delete the character to the right of the cursor
keymap.set("i", "<C-D>", "<DEL>")
keymap.set("n", "<leader>cb", function()
  local cnt = 0
  local blink_times = 7
  local timer = uv.new_timer()
  if timer == nil then
    return
  end

  timer:start(
    0,
    100,
    vim.schedule_wrap(function()
      vim.cmd([[
      set cursorcolumn!
      set cursorline!
    ]])

      if cnt == blink_times then
        timer:close()
      end

      cnt = cnt + 1
    end)
  )
end, { desc = "show cursor" })

-- Mapping para crear un nuevo todo con <leader>td
keymap.set("n", "<space>nt", "i- [ ] <Esc>A", { desc = "insert new todo item" })

keymap.set("n", "<space>x", function()
  local line = vim.api.nvim_get_current_line()
  local new_line

  if line:match("- %[ %]") then
    new_line = line:gsub("- %[ %]", "- [x]", 1)
  elseif line:match("- %[x%]") then
    new_line = line:gsub("- %[x%]", "- [ ]", 1)
  else
    return
  end

  vim.api.nvim_set_current_line(new_line)
end, { desc = "toggle todo completion status" })

keymap.set("n", "<leader>wo", function()
  local wiki_dir = vim.fn.expand("~/wiki")
  if vim.fn.isdirectory(wiki_dir) == 1 then
    vim.cmd("cd " .. wiki_dir)
    vim.notify("Moved to: " .. wiki_dir, vim.log.levels.INFO)
  else
    vim.notify("~/wiki not found: " .. wiki_dir, vim.log.levels.ERROR)
  end
end, { desc = "Go to wiki directory" })

keymap.set("n", "<space>gx", function()
  local url = vim.fn.expand("<cfile>")
  if url:match("^https?://") then
    vim.fn.system("firefox " .. url)
  else
    print("Not a valid URL")
  end
end, { desc = "open URL under cursor in Firefox" })


File: lua/lsp/clangd.lua
---
Content:
return {
	cmd = {
		"clangd",
		"--background-index",
		"--clang-tidy",
		"--header-insertion=iwyu",
		"--completion-style=detailed",
		"--function-arg-placeholders",
		"--fallback-style=llvm",
	},
	filetypes = { "c", "cpp", "objc", "objcpp", "cuda", "proto" },
	root_markers = {
		".clangd",
		".clang-tidy",
		".clang-format",
		"compile_commands.json",
		"compile_flags.txt",
		"configure.ac",
		".git"
	},
	init_options = {
		usePlaceholders = true,
		completeUnimported = true,
		clangdFileStatus = true,
	},
	capabilities = {
		offsetEncoding = { "utf-16" },
	},
}


File: lua/lsp/typescript.lua
---
Content:
require("typescript-tools").setup({
	filetypes = {
		"javascript",
		"javascriptreact",
		"typescript",
		"typescriptreact",
		"vue",
	},
	settings = {
		tsserver_plugins = {
			"@vue/typescript-plugin",
		},
	},
	capabilities = require("lsp.capabilities"),
})


File: lua/lsp/texlab.lua
---
Content:
return {
	cmd = { "texlab" },
	filetypes = { "tex", "plaintex", "bib" },
	root_markers = {
		".latexmkrc",
		".texlabroot",
		"texlabroot",
		"Tectonic.toml",
		".git",
	},
	settings = {
		texlab = {
			build = {
				executable = "latexmk",
				args = { "-pdf", "-interaction=nonstopmode", "-synctex=1", "%f" },
				onSave = false,
			},
			forwardSearch = {
				executable = "zathura",
				args = { "--synctex-forward", "%l:1:%f", "%p" },
			},
			completion = {
				triggerCharacters = { "\\", "{", "}" },
			},
			chktex = {
				onOpenAndSave = false,
				onEdit = false,
			},
			diagnosticsDelay = 300,
		},
	},
}


File: lua/lsp/lua_ls.lua
---
Content:
return {
	cmd = { "lua-language-server" },
	filetypes = { "lua" },
	root_markers = { ".luarc.json", ".luacheckrc", ".git" },
	settings = {
		Lua = {
			runtime = {
				version = "LuaJIT",
			},
			diagnostics = {
				globals = { "vim" },
			},
			workspace = {
				library = vim.api.nvim_get_runtime_file("", true),
				checkThirdParty = false,
			},
			telemetry = {
				enable = false,
			},
		},
	},
}


File: lua/lsp/bashls.lua
---
Content:
return {
	cmd = { "bash-language-server", "start" },
	filetypes = { "sh", "bash" },
	root_markers = { ".git", ".bashrc", "bash_profile" },
}


File: lua/lsp/pyright.lua
---
Content:
return {
	cmd = { "pyright-langserver", "--stdio" },
	filetypes = { "python" },
	root_markers = {
		"pyproject.toml",
		"setup.py",
		"setup.cfg",
		"requirements.txt",
		"Pipfile",
		"pyrightconfig.json",
		".git"
	},
	settings = {
		python = {
			analysis = {
				autoSearchPaths = true,
				useLibraryCodeForTypes = true,
				diagnosticMode = "workspace",
				typeCheckingMode = "basic", -- "off" | "basic" | "strict"
				autoImportCompletions = true,
				stubPath = vim.fn.stdpath("data") .. "/lazy/python-type-stubs",
			},
		},
	},
}


File: lua/lsp/on_attach.lua
---
Content:
return function(client, bufnr)
  -- Notificacin opcional para saber que se conect
  vim.notify("LSP Attached: " .. client.name, vim.log.levels.INFO, { title = "LSP" })

  local map = function(mode, l, r, opts)
    opts = opts or {}
    opts.buffer = bufnr
    opts.noremap = true
    opts.silent = true
    vim.keymap.set(mode, l, r, opts)
  end

  -- Keymaps
  map("n", "gd", vim.lsp.buf.definition, { desc = "LSP: Ir a Definicin" })
  map("n", "K", vim.lsp.buf.hover, { desc = "LSP: Mostrar Documentacin" })
  map("n", "gi", vim.lsp.buf.implementation, { desc = "LSP: Ir a Implementacin" })
  map("n", "<space>rn", vim.lsp.buf.rename, { desc = "LSP: Renombrar" })
  map({ "n", "v" }, "<space>ca", vim.lsp.buf.code_action, { desc = "LSP: Acciones de Cdigo" })
  map("n", "gr", vim.lsp.buf.references, { desc = "LSP: Mostrar Referencias" })
end


File: lua/lsp/rust_analyzer.lua
---
Content:
return {
	cmd = { "rust-analyzer" },
	filetypes = { "rust" },
	root_markers = { "Cargo.toml", "rust-project.json", ".git" },
	settings = {
		["rust-analyzer"] = {
			cargo = {
				allFeatures = true,
				loadOutDirsFromCheck = true,
				runBuildScripts = true,
			},
			checkOnSave = {
				allFeatures = true,
				command = "clippy",
				extraArgs = { "--no-deps" },
			},
			procMacro = {
				enable = true,
				ignored = {
					["async-trait"] = { "async_trait" },
					["napi-derive"] = { "napi" },
					["async-recursion"] = { "async_recursion" },
				},
			},
			inlayHints = {
				bindingModeHints = {
					enable = false,
				},
				chainingHints = {
					enable = true,
				},
				closingBraceHints = {
					enable = true,
					minLines = 25,
				},
				closureReturnTypeHints = {
					enable = "never",
				},
				lifetimeElisionHints = {
					enable = "never",
					useParameterNames = false,
				},
				maxLength = 25,
				parameterHints = {
					enable = true,
				},
				reborrowHints = {
					enable = "never",
				},
				renderColons = true,
				typeHints = {
					enable = true,
					hideClosureInitialization = false,
					hideNamedConstructor = false,
				},
			},
		},
	},
}


File: lua/lsp/vimls.lua
---
Content:
return {
	cmd = { "vim-language-server", "--stdio" },
	filetypes = { "vim" },
	root_markers = { ".git", "." },
	init_options = {
		diagnostic = {
			enable = true,
		},
		indexes = {
			count = 3,
			gap = 100,
			projectRootPatterns = { "runtime", "nvim", ".git", "autoload", "plugin" },
			runtimepath = true,
		},
		iskeyword = "@,48-57,_,192-255,-#",
		runtimepath = "",
		suggest = {
			fromRuntimepath = true,
			fromVimruntime = true,
		},
		vimruntime = "",
	},
}


File: lua/lsp/utils.lua
---
Content:
local M = {}

M.get_default_capabilities = function()
	local capabilities = vim.lsp.protocol.make_client_capabilities()

	-- required by nvim-ufo
	capabilities.textDocument.foldingRange = {
		dynamicRegistration = false,
		lineFoldingOnly = true,
	}

	return capabilities
end

function M.find_root(markers)
	local file_path = vim.api.nvim_buf_get_name(0)
	if file_path == "" then
		return nil
	end

	local dir = vim.fn.fnamemodify(file_path, ":h")
	local root = vim.fs.find(markers, { path = dir, upward = true })[1]
	return root
end

function show_active_lsps()
	local clients = vim.lsp.get_active_clients({ bufnr = 0 })

	if vim.tbl_isempty(clients) then
		vim.notify("No hay clientes LSP activos para este buffer.", vim.log.levels.INFO)
		return
	end

	local client_names = {}
	for _, client in ipairs(clients) do
		table.insert(client_names, client.name)
	end

	vim.notify("Active LSPs: " .. table.concat(client_names, ", "), vim.log.levels.INFO)
end

-- define command to show active LSPs
vim.api.nvim_create_user_command("LspInfo", show_active_lsps, {})

return M


File: lua/lsp/ltex.lua
---
Content:
return {
	cmd = { "ltex-ls" },
	filetypes = { "bib", "gitcommit", "markdown", "org", "plaintex", "rst", "rnoweb", "tex", "pandoc" },
	root_markers = { ".git", "." },
	settings = {
		ltex = {
			language = "auto",
			dictionary = {},
			disabledRules = {},
			hiddenFalsePositives = {},
			latex = {
				commands = {},
				environments = {},
			},
			markdown = {
				nodes = {},
			},
		},
	},
}


File: lua/lsp/capabilities.lua
---
Content:
local capabilities = vim.lsp.protocol.make_client_capabilities()
local cmp_capabilities = require("cmp_nvim_lsp").default_capabilities()

return vim.tbl_deep_extend("force", capabilities, cmp_capabilities)


File: lua/lsp/ruff.lua
---
Content:
return {
	cmd = { "ruff", "server", "--preview" },
	filetypes = { "python" },
	root_markers = {
		"pyproject.toml",
		"ruff.toml",
		".ruff.toml",
		"setup.py",
		".git",
	},
	init_options = {
		settings = {
			args = {},
		},
	},
	settings = {
		organizeImports = true,
		fixAll = true,
	},
}


File: lua/lsp/yamlls.lua
---
Content:
return {
	cmd = { "yaml-language-server", "--stdio" },
	filetypes = { "yaml", "yml", "yaml.docker-compose", "yaml.gitlab" },
	root_markers = { ".git", "." },
	settings = {
		yaml = {
			keyOrdering = false,
			format = {
				enable = true,
			},
			validate = true,
			hover = true,
			completion = true,
			schemas = {
				["https://json.schemastore.org/github-workflow.json"] = "/.github/workflows/*",
				["https://json.schemastore.org/github-action.json"] = "/.github/action.{yml,yaml}",
				["https://json.schemastore.org/ansible-stable-2.9.json"] = "roles/tasks/**/*.{yml,yaml}",
				["https://json.schemastore.org/prettierrc.json"] = ".prettierrc.{yml,yaml}",
				["https://json.schemastore.org/kustomization.json"] = "kustomization.{yml,yaml}",
				["https://json.schemastore.org/ansible-playbook.json"] = "*play*.{yml,yaml}",
				["https://json.schemastore.org/chart.json"] = "Chart.{yml,yaml}",
				["https://json.schemastore.org/docker-compose.json"] = "*docker-compose*.{yml,yaml}",
				["https://json.schemastore.org/gitlab-ci.json"] = "*gitlab-ci*.{yml,yaml}",
				["kubernetes"] = "*.k8s.{yml,yaml}",
			},
		},
	},
}


File: lua/lsp/json.lua
---
Content:
-- https://github.com/vscode-langservers/vscode-json-languageserver
require("lspconfig").jsonls.setup({
	settings = {
		json = {
			schemas = {
				{ fileMatch = { "jsconfig.json" }, url = "https://json.schemastore.org/jsconfig" },
				{ fileMatch = { "tsconfig.json" }, url = "https://json.schemastore.org/tsconfig" },
				{ fileMatch = { "package.json" }, url = "https://json.schemastore.org/package" },
				{
					fileMatch = { ".prettierrc.json", ".prettierrc" },
					url = "https://json.schemastore.org/prettierrc.json",
				},
				{ fileMatch = { ".eslintrc.json" }, url = "https://json.schemastore.org/eslintrc.json" },
			},
		},
	},
	capabilities = require("lsp.capabilities"),
})


File: lua/lsp/hls.lua
---
Content:
return {
	cmd = { "haskell-language-server-wrapper", "--lsp" },
	filetypes = { "haskell", "lhaskell" },
	root_markers = {
		"*.cabal",
		"stack.yaml",
		"cabal.project",
		"package.yaml",
		"hie.yaml",
		".git",
	},
	settings = {
		haskell = {
			cabalFormattingProvider = "cabalfmt",
			formattingProvider = "ormolu",
		},
	},
}


File: lua/lsp/init.lua
---
Content:
local base_capabilities = require("lsp.capabilities")
local on_attach = require("lsp.on_attach")
local lsp_utils = require("lsp.utils")
local general_utils = require("utils")

local server_configs_path = "lsp"
local server_files = vim.api.nvim_get_runtime_file(server_configs_path .. "/*.lua", true)
local available_servers = {}

for _, path in ipairs(server_files) do
	local server_name = vim.fn.fnamemodify(path, ":t:r")
	if
		server_name ~= "init"
		and server_name ~= "capabilities"
		and server_name ~= "on_attach"
		and server_name ~= "utils"
	then
		local success, config = pcall(require, server_configs_path .. "." .. server_name)
		if success then
			available_servers[server_name] = config
		else
			vim.notify("Error cargando config LSP: " .. server_name, vim.log.levels.ERROR, { title = "LSP Loader" })
		end
	end
end

vim.api.nvim_create_autocmd("FileType", {
	pattern = "*",
	group = vim.api.nvim_create_augroup("J_LspAutoStart", { clear = true }),
	callback = function(args)
		local ft = args.match
		for server_name, server_config in pairs(available_servers) do
			if vim.tbl_contains(server_config.filetypes or {}, ft) then
				if not general_utils.executable(server_config.cmd[1]) then
					vim.notify(
						string.format("LSP no encontrado: %s", server_config.cmd[1]),
						vim.log.levels.WARN,
						{ title = server_name }
					)
					goto continue
				end

				local final_config = {
					name = server_name,
					cmd = server_config.cmd,
					filetypes = server_config.filetypes,
					init_options = server_config.init_options,
					root_dir = lsp_utils.find_root(server_config.root_markers or {}),
					capabilities = vim.tbl_deep_extend(
						"force",
						vim.deepcopy(base_capabilities),
						server_config.capabilities or {}
					),
					on_attach = on_attach,
				}

				vim.lsp.start(final_config)
				::continue::
			end
		end
	end,
})

vim.diagnostic.config({
	underline = true,
	virtual_text = {
		spacing = 4,
		prefix = "",
	},
	signs = true,
	update_in_insert = false,
	severity_sort = true,
})

local signs = { Error = " ", Warn = " ", Hint = " ", Info = " " }
for type, icon in pairs(signs) do
	local hl = "DiagnosticSign" .. type
	vim.fn.sign_define(hl, { text = icon, texthl = hl, numhl = hl })
end


File: ftdetect/shell.vim
---
Content:
augroup shell_filetypes
  autocmd!
  autocmd BufRead,BufNewFile *.sh,*.bash,*.zsh,*.ksh,*.dash,*.profile,*.bashrc,*.zshrc,.zprofile setlocal filetype=sh
  autocmd BufRead,BufNewFile *.zsh,.zshrc,.zprofile let b:is_zsh = 1
  autocmd BufRead,BufNewFile *.bash,.bashrc,.bash_profile let b:is_bash = 1
  autocmd BufRead * 
    \ if getline(1) =~ '^#!.*zsh' |
    \   let b:is_zsh = 1 |
    \ elseif getline(1) =~ '^#!.*bash' |
    \   let b:is_bash = 1 |
    \ endif
augroup END


File: ftdetect/snippets.vim
---
Content:
augroup det_snippet
  autocmd!
  autocmd BufRead,BufNewFile *.snippets set filetype=snippets
augroup END


File: ftdetect/pdc.vim
---
Content:
augroup det_md
  autocmd!
  autocmd BufRead,BufNewFile *.pdc set filetype=markdown
augroup END


File: ginit.vim
---
Content:
" Fix key mapping issues for GUI
inoremap <silent> <S-Insert>  <C-R>+
cnoremap <S-Insert> <C-R>+
nnoremap <silent> <C-6> <C-^>

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                          config for nvim-qt                          "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
" To check if neovim-qt is running, use `exists('g:GuiLoaded')`,
" see https://github.com/equalsraf/neovim-qt/issues/219
if exists('g:GuiLoaded')
  " call GuiWindowMaximized(1)
  GuiTabline 0
  GuiPopupmenu 0
  GuiLinespace 2
  GuiFont! Hack\ NF:h10:l
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                           config for fvim                            "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if exists('g:fvim_loaded')
  set termguicolors
  colorscheme gruvbox8_hard
  set guifont=Hack\ NF:h13
  " Cursor tweaks
  FVimCursorSmoothMove v:true
  FVimCursorSmoothBlink v:true

  " Background composition, can be 'none', 'blur' or 'acrylic'
  FVimBackgroundComposition 'none'
  FVimBackgroundOpacity 1.0
  FVimBackgroundAltOpacity 1.0

  " Title bar tweaks (themed with colorscheme)
  FVimCustomTitleBar v:true

  " Debug UI overlay
  FVimDrawFPS v:false
  " Font debugging -- draw bounds around each glyph
  FVimFontDrawBounds v:false

  " Font tweaks
  FVimFontAntialias v:true
  FVimFontAutohint v:true
  FVimFontHintLevel 'full'
  FVimFontSubpixel v:true
  FVimFontLigature v:true
  " can be 'default', '14.0', '-1.0' etc.
  FVimFontLineHeight '+1'

  " Try to snap the fonts to the pixels, reduces blur
  " in some situations (e.g. 100% DPI).
  FVimFontAutoSnap v:true

  " Font weight tuning, possible values are 100..900
  FVimFontNormalWeight 100
  FVimFontBoldWeight 700

  FVimUIPopupMenu v:false
endif

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                             config for neovide                             "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
if exists("g:neovide")
  set guifont=Hack\ NF:h10
  let g:neovide_transparency = 1.0
  let g:neovide_cursor_animation_length = 0.1
  let g:neovide_cursor_trail_size=0.3
  let g:neovide_cursor_vfx_mode = ""
  let g:neovide_cursor_vfx_particle_density=10.0
  let g:neovide_cursor_vfx_opacity=150.0
endif


File: viml_conf/options.vim
---
Content:
scriptencoding utf-8

" change fillchars for folding, vertical split, end of buffer, and message separator
set fillchars=fold:\ ,foldsep:\ ,foldopen:,foldclose:,vert:\,eob:\ ,msgsep:,diff:

" Split window below/right when creating horizontal/vertical windows
set splitbelow splitright

" avoid the flickering when splitting window horizontal
set splitkeep=screen

" Time in milliseconds to wait for a mapped sequence to complete,
" see https://unix.stackexchange.com/q/36882/221410 for more info
set timeoutlen=500

set updatetime=500  " For CursorHold events

" Clipboard settings, always use clipboard for all delete, yank, change, put
" operation, see https://stackoverflow.com/q/30691466/6064933
if !empty(provider#clipboard#Executable())
  set clipboard+=unnamedplus
endif

" Disable creating swapfiles, see https://stackoverflow.com/q/821902/6064933
set noswapfile

" Ignore certain files and folders when globing
set wildignore+=*.o,*.obj,*.dylib,*.bin,*.dll,*.exe
set wildignore+=*/.git/*,*/.svn/*,*/__pycache__/*,*/build/**
set wildignore+=*.jpg,*.png,*.jpeg,*.bmp,*.gif,*.tiff,*.svg,*.ico
set wildignore+=*.pyc,*.pkl
set wildignore+=*.DS_Store
set wildignore+=*.aux,*.bbl,*.blg,*.brf,*.fls,*.fdb_latexmk,*.synctex.gz,*.xdv
set wildignorecase  " ignore file and dir name cases in cmd-completion

" Set up backup directory
let g:backupdir=expand(stdpath('data') . '/backup//')
let &backupdir=g:backupdir

" Skip backup for patterns in option wildignore
let &backupskip=&wildignore
set backup  " create backup for files
set backupcopy=yes  " copy the original file to backupdir and overwrite it

" General tab settings
set tabstop=2       " number of visual spaces per TAB
set softtabstop=2   " number of spaces in tab when editing
set shiftwidth=2    " number of spaces to use for autoindent
set expandtab       " expand tab to spaces so that tabs are spaces

" Set matching pairs of characters and highlight matching brackets
set matchpairs+=<:>,:,:,:,:,:,:

set number relativenumber  " Show line number and relative line number

" Ignore case in general, but become case-sensitive when uppercase is present
set ignorecase smartcase

" File and script encoding settings for vim
set fileencoding=utf-8
set fileencodings=ucs-bom,utf-8,cp936,gb18030,big5,euc-jp,euc-kr,latin1

" Break line at predefined characters
set linebreak
" Character to show before the lines that have been soft-wrapped
set showbreak=

" List all matches and complete till longest common string
set wildmode=list:longest

" Minimum lines to keep above and below cursor when scrolling
set scrolloff=3

" Use mouse to select and resize windows, etc.
set mouse=
set mousemodel=popup  " Set the behaviour of mouse
set mousescroll=ver:1,hor:0

" Disable showing current mode on command line since statusline plugins can show it.
set noshowmode

set fileformats=unix,dos  " Fileformats to use for new files

" Ask for confirmation when handling unsaved or read-only files
set confirm

set visualbell noerrorbells  " Do not use visual and errorbells
set history=500  " The number of command and search history to keep

" Use list mode and customized listchars
set list listchars=tab:\ ,extends:,precedes:,nbsp:

" Auto-write the file based on some condition
set autowrite

" Show hostname, full path of file and last-mod time on the window title. The
" meaning of the format str for strftime can be found in
" http://man7.org/linux/man-pages/man3/strftime.3.html. The function to get
" lastmod time is drawn from https://stackoverflow.com/q/8426736/6064933
set title
set titlestring=
set titlestring=%{utils#Get_titlestr()}

" Persistent undo even after you close a file and re-open it
set undofile

" Do not show "match xx of xx" and other messages during auto-completion
set shortmess+=c

" Do not show search match count on bottom right (seriously, I would strain my
" neck looking at it). Using plugins like vim-anzu or nvim-hlslens is a better
" choice, IMHO.
set shortmess+=S

" Disable showing intro message (:intro)
set shortmess+=I

set messagesopt=wait:5000,history:500

" Completion behaviour
" set completeopt+=noinsert  " Auto select the first completion entry
set completeopt+=menuone  " Show menu even if there is only one item
set completeopt-=preview  " Disable the preview window

set pumheight=10  " Maximum number of items to show in popup menu
set pumblend=5  " pseudo transparency for completion menu

set winblend=0  " pseudo transparency for floating window
set winborder=none
" Insert mode key word completion setting
set complete+=kspell complete-=w complete-=b complete-=u complete-=t

set spelllang=en,cjk  " Spell languages
set spellsuggest+=9  " show 9 spell suggestions at most

" Align indent to next multiple value of shiftwidth. For its meaning,
" see http://vim.1045645.n5.nabble.com/shiftround-option-td5712100.html
set shiftround

set virtualedit=block  " Virtual edit is useful for visual block edit

" Correctly break multi-byte characters such as CJK,
" see https://stackoverflow.com/q/32669814/6064933
set formatoptions+=mM

" Tilde (~) is an operator, thus must be followed by motions like `e` or `w`.
set tildeop

set synmaxcol=250  " Text after this column number is not highlighted
set nostartofline

" External program to use for grep command
if executable('rg')
  set grepprg=rg\ --vimgrep\ --no-heading\ --smart-case
  set grepformat=%f:%l:%c:%m
endif

" Enable true color support. Do not set this option if your terminal does not
" support true colors! For a comprehensive list of terminals supporting true
" colors, see https://github.com/termstandard/colors and https://gist.github.com/XVilka/8346728.
set termguicolors

" Set up cursor color and shape in various mode, ref:
" https://github.com/neovim/neovim/wiki/FAQ#how-to-change-cursor-color-in-the-terminal
set guicursor=n-v-c:block-Cursor/lCursor,i-ci-ve:ver25-Cursor2/lCursor2,r-cr:hor20,o:hor20

set signcolumn=yes:1

" Remove certain character from file name pattern matching
set isfname-==
set isfname-=,

" diff options
set diffopt=
set diffopt+=vertical  " show diff in vertical position
set diffopt+=filler  " show filler for deleted lines
set diffopt+=closeoff  " turn off diff when one file window is closed
set diffopt+=context:3  " context for diff
set diffopt+=internal,indent-heuristic,algorithm:histogram
set diffopt+=linematch:60

set nowrap  " do no wrap
set noruler


File: viml_conf/plugins.vim
---
Content:
scriptencoding utf-8

" Plugin specification and lua stuff
lua require('plugin_specs')

" Use short names for common plugin manager commands to simplify typing.
" To use these shortcuts: first activate command line with `:`, then input the
" short alias, e.g., `pi`, then press <space>, the alias will be expanded to
" the full command automatically.
call utils#Cabbrev('pi', 'Lazy install')
call utils#Cabbrev('pud', 'Lazy update')
call utils#Cabbrev('pc', 'Lazy clean')
call utils#Cabbrev('ps', 'Lazy sync')

""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
"                      configurations for vim script plugin                  "
""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

"""""""""""""""""""""""""UltiSnips settings"""""""""""""""""""
" Trigger configuration. Do not use <tab> if you use YouCompleteMe
let g:UltiSnipsExpandTrigger='<c-j>'

" Do not look for SnipMate snippets
let g:UltiSnipsEnableSnipMate = 0

" Shortcut to jump forward and backward in tabstop positions
let g:UltiSnipsJumpForwardTrigger='<c-j>'
let g:UltiSnipsJumpBackwardTrigger='<c-k>'

" Configuration for custom snippets directory, see
" https://jdhao.github.io/2019/04/17/neovim_snippet_s1/ for details.
let g:UltiSnipsSnippetDirectories=['UltiSnips', 'my_snippets']

"""""""""""""""""""""""""" vlime settings """"""""""""""""""""""""""""""""
command! -nargs=0 StartVlime call jobstart(printf("sbcl --load %s/vlime/lisp/start-vlime.lisp", g:package_home))

""""""""""""""""""""""""""" vista settings """"""""""""""""""""""""""""""""""
let g:vista#renderer#icons = {
      \ 'member': '',
      \ }

" Do not echo message on command line
let g:vista_echo_cursor = 0
" Stay in current window when vista window is opened
let g:vista_stay_on_open = 0

nnoremap <silent> <Space>t :<C-U>Vista!!<CR>

""""""""""""""""""""""""vim-mundo settings"""""""""""""""""""""""
let g:mundo_verbose_graph = 0
let g:mundo_width = 80

nnoremap <silent> <Space>u :MundoToggle<CR>

""""""""""""""""""""""""""""better-escape.vim settings"""""""""""""""""""""""""
let g:better_escape_interval = 200

""""""""""""""""""""""""""""vim-xkbswitch settings"""""""""""""""""""""""""
let g:XkbSwitchEnabled = 1

"""""""""""""""""""""""""""""" neoformat settings """""""""""""""""""""""
let g:neoformat_enabled_python = ['black', 'yapf']
let g:neoformat_cpp_clangformat = {
      \ 'exe': 'clang-format',
      \ 'args': ['--style="{IndentWidth: 4}"']
      \ }
let g:neoformat_c_clangformat = {
      \ 'exe': 'clang-format',
      \ 'args': ['--style="{IndentWidth: 4}"']
      \ }

let g:neoformat_enabled_cpp = ['clangformat']
let g:neoformat_enabled_c = ['clangformat']

"""""""""""""""""""""""""vim-markdown settings"""""""""""""""""""
" Disable header folding
let g:vim_markdown_folding_disabled = 1

" Whether to use conceal feature in markdown
let g:vim_markdown_conceal = 1

" Disable math tex conceal and syntax highlight
let g:tex_conceal = ''
let g:vim_markdown_math = 0

" Support front matter of various format
let g:vim_markdown_frontmatter = 1  " for YAML format
let g:vim_markdown_toml_frontmatter = 1  " for TOML format
let g:vim_markdown_json_frontmatter = 1  " for JSON format

" Let the TOC window autofit so that it doesn't take too much space
let g:vim_markdown_toc_autofit = 1

"""""""""""""""""""""""""markdown-preview settings"""""""""""""""""""
" Only setting this for suitable platforms
if g:is_win || g:is_mac
  " Do not close the preview tab when switching to other buffers
  let g:mkdp_auto_close = 0

  " Shortcuts to start and stop markdown previewing
  nnoremap <silent> <M-m> :<C-U>MarkdownPreview<CR>
  nnoremap <silent> <M-S-m> :<C-U>MarkdownPreviewStop<CR>
endif

""""""""""""""""""""""""vim-grammarous settings""""""""""""""""""""""""""""""
if g:is_mac
  let g:grammarous#languagetool_cmd = 'languagetool'
  let g:grammarous#disabled_rules = {
      \ '*' : ['WHITESPACE_RULE', 'EN_QUOTES', 'ARROWS', 'SENTENCE_WHITESPACE',
      \        'WORD_CONTAINS_UNDERSCORE', 'COMMA_PARENTHESIS_WHITESPACE',
      \        'EN_UNPAIRED_BRACKETS', 'UPPERCASE_SENTENCE_START',
      \        'ENGLISH_WORD_REPEAT_BEGINNING_RULE', 'DASH_RULE', 'PLUS_MINUS',
      \        'PUNCTUATION_PARAGRAPH_END', 'MULTIPLICATION_SIGN', 'PRP_CHECKOUT',
      \        'CAN_CHECKOUT', 'SOME_OF_THE', 'DOUBLE_PUNCTUATION', 'HELL',
      \        'CURRENCY', 'POSSESSIVE_APOSTROPHE', 'ENGLISH_WORD_REPEAT_RULE',
      \        'NON_STANDARD_WORD', 'AU', 'DATE_NEW_YEAR'],
      \ }

  augroup grammarous_map
    autocmd!
    autocmd FileType markdown nmap <buffer> <leader>x <Plug>(grammarous-close-info-window)
    autocmd FileType markdown nmap <buffer> <c-n> <Plug>(grammarous-move-to-next-error)
    autocmd FileType markdown nmap <buffer> <c-p> <Plug>(grammarous-move-to-previous-error)
  augroup END
endif

""""""""""""""""""""""""unicode.vim settings""""""""""""""""""""""""""""""
nmap ga <Plug>(UnicodeGA)

""""""""""""""""""""""""""""vim-sandwich settings"""""""""""""""""""""""""""""
" Map s to nop since s in used by vim-sandwich. Use cl instead of s.
nmap s <Nop>
omap s <Nop>

""""""""""""""""""""""""""""vim-matchup settings"""""""""""""""""""""""""""""
" Improve performance
let g:matchup_matchparen_deferred = 1
let g:matchup_matchparen_timeout = 100
let g:matchup_matchparen_insert_timeout = 30

" Enhanced matching with matchup plugin

" Whether to enable matching inside comment or string
let g:matchup_delim_noskips = 0

" Show offscreen match pair in popup window
let g:matchup_matchparen_offscreen = {'method': 'popup'}

"""""""""""""""""""""""""" asyncrun.vim settings """"""""""""""""""""""""""
" Automatically open quickfix window of 6 line tall after asyncrun starts
let g:asyncrun_open = 6
if g:is_win
  " Command output encoding for Windows
  let g:asyncrun_encs = 'gbk'
endif

""""""""""""""""""""""""""""""firenvim settings""""""""""""""""""""""""""""""
if exists('g:started_by_firenvim') && g:started_by_firenvim
  if g:is_mac
    set guifont=Iosevka\ Nerd\ Font:h18
  else
    set guifont=Consolas
  endif

  " general config for firenvim
  let g:firenvim_config = {
      \ 'globalSettings': {
          \ 'alt': 'all',
      \  },
      \ 'localSettings': {
          \ '.*': {
              \ 'cmdline': 'neovim',
              \ 'priority': 0,
              \ 'selector': 'textarea',
              \ 'takeover': 'never',
          \ },
      \ }
  \ }

  function s:setup_firenvim() abort
    set signcolumn=no
    set noruler
    set noshowcmd
    set laststatus=0
    set showtabline=0
  endfunction

  augroup firenvim
    autocmd!
    autocmd BufEnter * call s:setup_firenvim()
    autocmd BufEnter sqlzoo*.txt set filetype=sql
    autocmd BufEnter github.com_*.txt set filetype=markdown
    autocmd BufEnter stackoverflow.com_*.txt set filetype=markdown
  augroup END
endif

""""""""""""""""""""""""""""""nvim-gdb settings""""""""""""""""""""""""""""""
nnoremap <leader>dp :<C-U>GdbStartPDB python -m pdb %<CR>

""""""""""""""""""""""""""""""wilder.nvim settings""""""""""""""""""""""""""""""
call timer_start(250, { -> s:wilder_init() })

function! s:wilder_init() abort
  try
    call wilder#setup({
          \ 'modes': [':', '/', '?'],
          \ 'next_key': '<Tab>',
          \ 'previous_key': '<S-Tab>',
          \ 'accept_key': '<C-y>',
          \ 'reject_key': '<C-e>'
          \ })

    call wilder#set_option('pipeline', [
          \   wilder#branch(
          \     wilder#cmdline_pipeline({
          \       'language': 'python',
          \       'fuzzy': 1,
          \       'sorter': wilder#python_difflib_sorter(),
          \       'debounce': 30,
          \     }),
          \     wilder#python_search_pipeline({
          \       'pattern': wilder#python_fuzzy_pattern(),
          \       'sorter': wilder#python_difflib_sorter(),
          \       'engine': 're',
          \       'debounce': 30,
          \     }),
          \   ),
          \ ])

    let l:hl = wilder#make_hl('WilderAccent', 'Pmenu', [{}, {}, {'foreground': '#f4468f'}])
    call wilder#set_option('renderer', wilder#popupmenu_renderer({
          \ 'highlighter': wilder#basic_highlighter(),
          \ 'max_height': 15,
          \ 'highlights': {
          \   'accent': l:hl,
          \ },
          \ 'left': [' ', wilder#popupmenu_devicons(),],
          \ 'right': [' ', wilder#popupmenu_scrollbar(),],
          \ 'apply_incsearch_fix': 0,
          \ }))
  catch /^Vim\%((\a\+)\)\=:E117/
    echohl Error |echomsg "Wilder.nvim missing"| echohl None
  endtry
endfunction


File: spell/en.utf-8.add
---
Content:
AED
API
Autocommands
BufRead
Builtin
Bzier
CER
CMD
CentOS
Cmder
Ctrl
DLL
DT
Deoplete
Deteval
Esc
Exif
Firefox
Foxmail
GPU
GPUs
GUIs
GhostText
GitHub
HomeBrew
ICCF
ICDAR
IDE
IoU
Iterm2
JPEG
JSON
LSP
Linters
Listary
MPI
MXNet
MacOS
Matplotlib
Neomake
Nvim
Numpy
OpenCV
PIL
PNG
POSIX
Pandoc
Plugin
Plugins
PowerShell
PyTorch
Pynvim
RCTW
Ripgrep
TOC
TensorFlow
UI
URLs
Uber
Ubuntu
UltiSnips
Ultisnips
Unindent
VOC
VimConf
WSL
X11
YouCompleteMe
Zsh
ack
ag
appimage
autocommand
autocommands
autocompletion
autoload
backend
backtick
base64
bashrc
blog
bruteforce
builtin
cmder
colorscheme
conda
config
configs
css
css_intro/!
ctags
deoplete
dict
diff
dir
docstrings
emoji
env
epub
favicon
favicons
filetype
filetypes
filetypes/!
firenvim
fontconfig
fzf
gcc
grep
gutentags
homebrew
horovod
inline
iterm2
jedi
jpg
keras
linters
linting
lookaround
lookbehind
lua
macOS
maskrcnn
mergetools
metadata
mobi
modeline
modelines
mouseless
namespace
ndarray
neovim
nerdtree
nvim
opentype
pdflatex
perl
plugin
plugins
png
popup
pylint
quickfix
refractor
regex
repo
rg
ripgrep
runtimepath
smartphone
solarized
specicial/!
statusline
statuslines
tabline
tabstops
tagbar
terminfo
tex
textline
tmux
truetype
uWSGI
ultisnips
uninstall
usepackage
uwsgi
vimrc
vimscript
vimtex
warmup
wildmenu
workflow
wsltty
zplug
zsh
zinit
pycodestyle
pep8
pyflakes
pyls
flake8
sbcl
quicklisp
REPL
vlime
Matplotlib's
MiKTeX
FontManager
ttc
xnoremap
wiki
backticks
Reddit
LeaderF
tabpage
ccls
cmake
LLVM
llvm
subsampling
refactor
colorschemes
gruvbox8
gruvbox
Gruvbox
monokai
NeoSolarized
FiraCode
libc
printf
CMake
lsp
PPTX
libreoffice
PPT
pptx
pdf
unoconv
python3
imagemagick
ghostscript
poppler
Tqdm
tqdm
cmd
ThreadPoolExecutor
Cygwin
mintty
iTerm
stdin
unicode
ClashX
Qv2ray
socks5
v2ray
V2Ray
Dockerfile
pip3
dein
pynvim
iTerm2
neoformat
documentation/!
documentation
WSGI
ncurses
powerline
repos
hugo
ZOC
stackexchange
https
username
url
dev
Miniconda
Semshi
Alacritty
vim/!
Vim/!
Vim
vim
RPC
SumatraPDF/!
api
YAML
TOML
pandoc
textwidth
bytecode
CPython
nohup
stdout
stderr
UTC
CJK
numpy
LibreOffice
rebase
rebasing
glibc
Clangd
clangd
cheatsheet
redis
Disqus
submodules
stackoverflow
hostname
strftime
shiftwidth
whitespace
treesitter
linter
MySQL
advocator
Hexo
pybind11
OSC
minpac
ctrl
IME
emacs
Elisp
conf
MELPA
smartparens
Tpope
extmarks
extmark
CTAN
MikTex/!
MikTeX
softwares/!
Zong
cjk
backupcopy
nowritebackup
nvim's
linux
zshrc
pdftoppm
pdf2image
pdffonts
myers
difftool
vimdiff
softmax
lib64
toolset
sym
ffmpeg
PyAV
mp4
vint
npm
js
sudo
ps1
tpm
hacky
PCRE
teardown
github
fastgit
EOL
PyCharm
deduplication
STL
delimitMate
lspconfig
lualine
Keymap
iCloud
keyframe
maskRCNN
vundle
ycm
ftplugin
vim9
dotfile
magit
xelatex
subarray
fvim
CUDA
cuda
cpu
jdhao
whitelisted
BST
autocmd
init
miniconda
tsinghua
pylsp
mypy
isort
ustc
PyTorch
maxcdn
torchvision
FFmpeg
pyav
wezterm
frac
argmax
NeruIPS
InfoNCE
LSTM
linkedin
hotmail
datetime
csv
iterable
dataframe
CRNN
ICPR
matplotlib
scikit
NumPy
cudnn
SGD
ImageNet
ReLU
CIFAR
ResNet
XGBoost
Shenzhen
Tanh
Kaggle
minist
src
RGBA
yapf
Vimming
overfitting
PCA
SVM
KNN
leetcode
Logitech
WTF
tensorboard
Nvidia
GPG
manpage
metatable
open3d
pyntcloud
param
reddit
viml
PostgreSQL
CNY
wechat
ziroom
Postgres
plpgsql
postgres
PySpark
winbar
cmdline
shada
async
localhost
JetBrains
localhost
MariaDB
SQLite
Pgadmin
Datagrip
mysql
cwd
pyright
stubgen
pylance
variadic
Vimium
Databricks
Jira databricks
FastAPI
pylintrc
PYTHONPATH
Uvicorn
qpdf
Elasticsearch
kibana
submodule
unix
GCP
Kubernetes
pubsub
Luarocks
luarocks
mkdir
rmdir
txt
snakecase
pwd
chown
chgrp
chmod
rwx
Jira
keymaps
Neovim
markdownlint
MD013
init
lua
Cmd
TMUX
cheatsheet
pomodoros
Todoist
overlearning
Linter
Wyszynski
Nvim
nvim
WWDC
Async
async
Unscoped
structs
enums
MainActor
Nonisolated
german
Sendable
#empathore
NSLock
NSRecursiveLock
#empathore/!
reentrancy
Todos
Dotfiles
dotfiles
dotfile
config
Homebrew
Heredoc
heredoc
Brewfile
homebrew
zsh
Hereword
sudo
W3
css
TailWindCSS
SSHFS


File: init.lua
---
Content:
vim.loader.enable()

local utils = require("utils")
local expected_version = "0.11.2"
utils.is_compatible_version(expected_version)

local config_dir = vim.fn.stdpath("config")
---@cast config_dir string

-- some global settings
require("globals")
-- setting options in nvim
vim.cmd("source " .. vim.fs.joinpath(config_dir, "viml_conf/options.vim"))
-- various autocommands
require("custom-autocmd")
-- all the user-defined mappings
require("mappings")
-- Nvim quality of life improvements
require("improvements")

-- all the plugins installed and their configurations
vim.cmd("source " .. vim.fs.joinpath(config_dir, "viml_conf/plugins.vim"))

-- diagnostic related config
require("diagnostic-conf")

-- lsp configuration
require("lsp")

-- colorscheme settings
require("colorschemes")
local color_scheme = require("colorschemes")

-- Load colorscheme
color_scheme.load_colorscheme("nord")


File: Session.vim
---
Content:
let SessionLoad = 1
let s:so_save = &g:so | let s:siso_save = &g:siso | setg so=0 siso=0 | setl so=-1 siso=-1
let v:this_session=expand("<sfile>:p")
silent only
silent tabonly
cd ~/.dotfiles/.config/nvim
if expand('%') == '' && !&modified && line('$') <= 1 && getline(1) == ''
  let s:wipebuf = bufnr('%')
endif
let s:shortmess_save = &shortmess
if &shortmess =~ 'A'
  set shortmess=aoOA
else
  set shortmess=aoO
endif
badd +492 lua/plugin_specs.lua
argglobal
%argdel
$argadd lua/plugin_specs.lua
edit lua/plugin_specs.lua
argglobal
setlocal foldmethod=manual
setlocal foldexpr=v:lua.vim.treesitter.foldexpr()
setlocal foldmarker={{{,}}}
setlocal foldignore=#
setlocal foldlevel=99
setlocal foldminlines=1
setlocal foldnestmax=20
setlocal foldenable
silent! normal! zE
sil! 7,13fold
sil! 6,14fold
sil! 19,20fold
sil! 34,35fold
sil! 37,38fold
sil! 30,39fold
sil! 42,44fold
sil! 47,49fold
sil! 55,56fold
sil! 52,57fold
sil! 61,62fold
sil! 59,64fold
sil! 69,70fold
sil! 68,72fold
sil! 76,77fold
sil! 66,78fold
sil! 85,86fold
sil! 81,87fold
sil! 96,97fold
sil! 99,100fold
sil! 94,102fold
sil! 109,110fold
sil! 106,111fold
sil! 117,118fold
sil! 114,119fold
sil! 124,126fold
sil! 122,127fold
sil! 129,133fold
sil! 138,142fold
sil! 159,162fold
sil! 156,164fold
sil! 171,172fold
sil! 167,173fold
sil! 180,181fold
sil! 176,182fold
sil! 189,190fold
sil! 186,191fold
sil! 200,201fold
sil! 199,203fold
sil! 197,204fold
sil! 194,205fold
sil! 210,211fold
sil! 207,212fold
sil! 219,223fold
sil! 225,226fold
sil! 214,227fold
sil! 238,239fold
sil! 235,240fold
sil! 247,248fold
sil! 245,250fold
sil! 257,258fold
sil! 261,262fold
sil! 255,263fold
sil! 271,272fold
sil! 267,273fold
sil! 277,279fold
sil! 277,279fold
sil! 291,292fold
sil! 289,294fold
sil! 307,308fold
sil! 305,310fold
sil! 315,316fold
sil! 313,318fold
sil! 325,326fold
sil! 322,327fold
sil! 336,337fold
sil! 332,338fold
sil! 343,344fold
sil! 340,345fold
sil! 351,352fold
sil! 349,353fold
sil! 356,358fold
sil! 364,365fold
sil! 361,366fold
sil! 381,382fold
sil! 379,385fold
sil! 390,391fold
sil! 388,393fold
sil! 409,410fold
sil! 412,421fold
sil! 406,422fold
sil! 427,428fold
sil! 425,429fold
sil! 434,435fold
sil! 432,438fold
sil! 446,447fold
sil! 444,449fold
sil! 461,462fold
sil! 466,478fold
sil! 459,479fold
sil! 484,485fold
sil! 482,488fold
sil! 496,497fold
sil! 494,499fold
sil! 503,505fold
sil! 512,513fold
sil! 509,514fold
sil! 524,526fold
sil! 522,527fold
sil! 521,528fold
sil! 517,529fold
sil! 539,540fold
sil! 536,541fold
sil! 546,547fold
sil! 543,548fold
sil! 554,555fold
sil! 550,556fold
sil! 562,565fold
sil! 561,566fold
sil! 558,567fold
sil! 574,575fold
sil! 569,577fold
sil! 582,583fold
sil! 585,586fold
sil! 579,587fold
sil! 593,594fold
sil! 589,596fold
sil! 599,601fold
sil! 603,607fold
sil! 23,608fold
sil! 614,617fold
sil! 619,621fold
sil! 612,622fold
let &fdl = &fdl
23
sil! normal! zo
let s:l = 492 - ((21 * winheight(0) + 21) / 42)
if s:l < 1 | let s:l = 1 | endif
keepjumps exe s:l
normal! zt
keepjumps 492
normal! 047|
tabnext 1
if exists('s:wipebuf') && len(win_findbuf(s:wipebuf)) == 0 && getbufvar(s:wipebuf, '&buftype') isnot# 'terminal'
  silent exe 'bwipe ' . s:wipebuf
endif
unlet! s:wipebuf
set winheight=1 winwidth=20
let &shortmess = s:shortmess_save
let s:sx = expand("<sfile>:p:r")."x.vim"
if filereadable(s:sx)
  exe "source " . fnameescape(s:sx)
endif
let &g:so = s:so_save | let &g:siso = s:siso_save
set hlsearch
nohlsearch
let g:this_session = v:this_session
let g:this_obsession = v:this_session
doautoall SessionLoadPost
unlet SessionLoad
" vim: set ft=vim :


File: lazy-lock.json
---
Content:
{
  "arctic": { "branch": "v2", "commit": "9052ab87b1d6e9b746ab8dde6576e2876ffda4c7" },
  "ashen.nvim": { "branch": "main", "commit": "638fbfe0845068cd49a7d6e0c9c1a34e91f899cd" },
  "asyncrun.vim": { "branch": "master", "commit": "e17c49c67d1dd847cd1d7d6077a7168816f546cc" },
  "better-escape.vim": { "branch": "master", "commit": "6b16a45a839727977277f6ab11bded63e9ed86bb" },
  "bloat.nvim": { "branch": "master", "commit": "f90bef655ac40fecbaae53e10db1cf7894d090b1" },
  "bufferline.nvim": { "branch": "main", "commit": "655133c3b4c3e5e05ec549b9f8cc2894ac6f51b3" },
  "cmp-buffer": { "branch": "main", "commit": "b74fab3656eea9de20a9b8116afa3cfc4ec09657" },
  "cmp-nvim-lsp": { "branch": "main", "commit": "a8912b88ce488f411177fc8aed358b04dc246d7b" },
  "cmp-nvim-ultisnips": { "branch": "main", "commit": "2be0eda0f7fbf47ebd9fbdace369cc45d57acf49" },
  "cmp-omni": { "branch": "main", "commit": "4ef610bbd85a5ee4e97e09450c0daecbdc60de86" },
  "cmp-path": { "branch": "main", "commit": "c6635aae33a50d6010bf1aa756ac2398a2d54c32" },
  "copilot.lua": { "branch": "master", "commit": "c1bb86abbed1a52a11ab3944ef00c8410520543d" },
  "dashboard-nvim": { "branch": "master", "commit": "c42fcfbd96dfcaa486c0a0ab52494316f1c31350" },
  "diffview.nvim": { "branch": "main", "commit": "4516612fe98ff56ae0415a259ff6361a89419b0a" },
  "dropbar.nvim": { "branch": "master", "commit": "b695c346fd180d504c1d135435cbcfba08ad3946" },
  "e-ink.nvim": { "branch": "main", "commit": "0f9131236ef0f443144d5545db02fa726f80bbd3" },
  "fidget.nvim": { "branch": "main", "commit": "0ba1e16d07627532b6cae915cc992ecac249fb97" },
  "fzf-lua": { "branch": "main", "commit": "7af7336ce013b31fc5a386bf9aca44aa2005d68c" },
  "git-conflict.nvim": { "branch": "main", "commit": "4bbfdd92d547d2862a75b4e80afaf30e73f7bbb4" },
  "github-theme": { "branch": "main", "commit": "c106c9472154d6b2c74b74565616b877ae8ed31d" },
  "gitlinker.nvim": { "branch": "master", "commit": "cc59f732f3d043b626c8702cb725c82e54d35c25" },
  "gitsigns.nvim": { "branch": "main", "commit": "1b0350ab707713b2bc6c236151f1a324175347b1" },
  "glance.nvim": { "branch": "master", "commit": "bf86d8b79dce808e65fdb6e9269d0b4ed6d2eefc" },
  "hop.nvim": { "branch": "master", "commit": "9c6a1dd9afb53a112b128877ccd583a1faa0b8b6" },
  "jellybeans.nvim": { "branch": "main", "commit": "362a54e2400b4fd54b1ee78261be99c301982853" },
  "kanagawa.nvim": { "branch": "master", "commit": "debe91547d7fb1eef34ce26a5106f277fbfdd109" },
  "kanso.nvim": { "branch": "main", "commit": "f0b41d6235bf0b4032304202ca84d2cdeb6fb1cb" },
  "lazy.nvim": { "branch": "main", "commit": "6c3bda4aca61a13a9c63f1c1d1b16b9d3be90d7a" },
  "lazydev.nvim": { "branch": "main", "commit": "2367a6c0a01eb9edb0464731cc0fb61ed9ab9d2c" },
  "live-command.nvim": { "branch": "main", "commit": "05b9f886628f3e9e6122e734c1fac4f13dcb64b4" },
  "lua-utils.nvim": { "branch": "main", "commit": "e565749421f4bbb5d2e85e37c3cef9d56553d8bd" },
  "lualine.nvim": { "branch": "master", "commit": "a94fc68960665e54408fe37dcf573193c4ce82c9" },
  "lush.nvim": { "branch": "main", "commit": "45a79ec4acb5af783a6a29673a999ce37f00497e" },
  "makurai-nvim": { "branch": "main", "commit": "a273b061d7300c3e10d6202dd65c6152136f9ae0" },
  "markdown.nvim": { "branch": "main", "commit": "95bc2eced6c3700942d54668d37c35f9bdb6a0cb" },
  "melange-nvim": { "branch": "master", "commit": "ce42f6b629beeaa00591ba73a77d3eeac4cf28ce" },
  "mini.icons": { "branch": "main", "commit": "94848dad1589a199f876539bd79befb0c5e3abf0" },
  "mini.indentscope": { "branch": "main", "commit": "5fdc3edf7bb1b6365980c2c47dac2f19ec93c97b" },
  "modus-themes.nvim": { "branch": "master", "commit": "61b8c10ec636f42baf6c845edb14b9ae2723711f" },
  "neorg": { "branch": "main", "commit": "9d75ae8e2625db240636870dd7f029c9a82ab9ef" },
  "nord.nvim": { "branch": "master", "commit": "80c1e5321505aeb22b7a9f23eb82f1e193c12470" },
  "nvim-bqf": { "branch": "main", "commit": "9cbec7cf8ad2a902a0a41241ad16c3489620321b" },
  "nvim-cmp": { "branch": "main", "commit": "b5311ab3ed9c846b585c0c15b7559be131ec4be9" },
  "nvim-colorizer.lua": { "branch": "master", "commit": "517df88cf2afb36652830df2c655df2da416a0ae" },
  "nvim-gdb": { "branch": "master", "commit": "cf00140361cabcd4e55a987fd9770a92ee682301" },
  "nvim-lightbulb": { "branch": "master", "commit": "aa3a8b0f4305b25cfe368f6c9be9923a7c9d0805" },
  "nvim-lint": { "branch": "master", "commit": "2b0039b8be9583704591a13129c600891ac2c596" },
  "nvim-notify": { "branch": "master", "commit": "b5825cf9ee881dd8e43309c93374ed5b87b7a896" },
  "nvim-surround": { "branch": "main", "commit": "8dd9150ca7eae5683660ea20cec86edcd5ca4046" },
  "nvim-tree.lua": { "branch": "master", "commit": "b0b49552c9462900a882fe772993b01d780445fe" },
  "nvim-treesitter": { "branch": "master", "commit": "42fc28ba918343ebfd5565147a42a26580579482" },
  "nvim-treesitter-textobjects": { "branch": "master", "commit": "89ebe73cd2836db80a22d9748999ace0241917a5" },
  "nvim-ufo": { "branch": "main", "commit": "80fe8215ba566df2fbf3bf4d25f59ff8f41bc0e1" },
  "obsidian.nvim": { "branch": "main", "commit": "14e0427bef6c55da0d63f9a313fd9941be3a2479" },
  "oil.nvim": { "branch": "master", "commit": "08c2bce8b00fd780fb7999dbffdf7cd174e896fb" },
  "plenary.nvim": { "branch": "master", "commit": "857c5ac632080dba10aae49dba902ce3abf91b35" },
  "promise-async": { "branch": "main", "commit": "119e8961014c9bfaf1487bf3c2a393d254f337e2" },
  "snacks.nvim": { "branch": "main", "commit": "bc0630e43be5699bb94dadc302c0d21615421d93" },
  "statuscol.nvim": { "branch": "main", "commit": "c46172d0911aa5d49ba5f39f4351d1bb7aa289cc" },
  "tabular": { "branch": "master", "commit": "12437cd1b53488e24936ec4b091c9324cafee311" },
  "targets.vim": { "branch": "master", "commit": "6325416da8f89992b005db3e4517aaef0242602e" },
  "telescope-symbols.nvim": { "branch": "master", "commit": "a6d0127a53d39b9fc2af75bd169d288166118aec" },
  "telescope.nvim": { "branch": "master", "commit": "b4da76be54691e854d3e0e02c36b0245f945c2c7" },
  "ultisnips": { "branch": "master", "commit": "b22a86f9dcc5257624bff3c72d8b902eac468aad" },
  "unicode.vim": { "branch": "master", "commit": "c7ae86b93e70e816377ad194789bab0f5639dce2" },
  "vague.nvim": { "branch": "main", "commit": "41b6b9a985c9091d0ec8571191e89d6950968cec" },
  "vim-commentary": { "branch": "master", "commit": "64a654ef4a20db1727938338310209b6a63f60c9" },
  "vim-eunuch": { "branch": "master", "commit": "e86bb794a1c10a2edac130feb0ea590a00d03f1e" },
  "vim-flog": { "branch": "master", "commit": "665b16ac8915f746bc43c9572b4581a5e9047216" },
  "vim-fugitive": { "branch": "master", "commit": "593f831d6f6d779cbabb70a4d1e6b1b1936a88af" },
  "vim-highlighturl": { "branch": "master", "commit": "7179156ccc68168e7ef8f1eae28edf36911f5a3c" },
  "vim-markdown": { "branch": "master", "commit": "8f6cb3a6ca4e3b6bcda0730145a0b700f3481b51" },
  "vim-markdownfootnotes": { "branch": "master", "commit": "2b288149f48cfaf7465d25bb094ed62898f5e5b0" },
  "vim-mundo": { "branch": "master", "commit": "2ceda8c65f7b3f9066820729fc02003a09df91f9" },
  "vim-obsession": { "branch": "master", "commit": "ed9dfc7c2cc917ace8b24f4f9f80a91e05614b63" },
  "vim-oscyank": { "branch": "main", "commit": "d67d76b2f19b868b70a1cf33a779d71dc092cb30" },
  "vim-repeat": { "branch": "master", "commit": "65846025c15494983dafe5e3b46c8f88ab2e9635" },
  "vim-sandwich": { "branch": "master", "commit": "74cf93d58ccc567d8e2310a69860f1b93af19403" },
  "vim-scriptease": { "branch": "master", "commit": "cdb5981d47ac98221a408ae2e7cae66524d9e872" },
  "vim-snippets": { "branch": "master", "commit": "f0a3184d9f90b96b044d5914625a25c554d7f301" },
  "vim-swap": { "branch": "master", "commit": "9358bfdc5e377aa13e7c2c2dd8699ba32b0dcf83" },
  "vim-tmux": { "branch": "master", "commit": "cfe76281efc29890548cf9eedd42ad51c7a1faf0" },
  "vim-toml": { "branch": "main", "commit": "1b63257680eeb65677eb1ca5077809a982756d58" },
  "vim-visual-multi": { "branch": "master", "commit": "a6975e7c1ee157615bbc80fc25e4392f71c344d4" },
  "vimtex": { "branch": "master", "commit": "e10525a5aa65e2544f11e680dd81c77fba800248" },
  "vista.vim": { "branch": "master", "commit": "1e90efad6e32c4f7d16b1ca8f49bf63d0693802e" },
  "which-key.nvim": { "branch": "main", "commit": "370ec46f710e058c9c1646273e6b225acf47cbed" },
  "whitespace.nvim": { "branch": "master", "commit": "fda1dd48e63e62a0ebd270c38d87e246b29c3616" },
  "wilder.nvim": { "branch": "master", "commit": "679f348dc90d80ff9ba0e7c470c40a4d038dcecf" },
  "yanky.nvim": { "branch": "main", "commit": "04775cc6e10ef038c397c407bc17f00a2f52b378" }
}


